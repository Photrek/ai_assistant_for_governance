[
  {
    "prompt": "pluts?",
    "completion": "Built with by Harmonic Laboratories\nThis documentation is for plu-ts v0.7.0 , if you are using a previous version it is suggested to install the latest version, feel free to ask for help in the Harmonic Labs' discord server\nplu-ts\nplu-ts is a library designed for building Cardano dApps in an efficient and developer friendly way.\nplu-ts\nIt is composed of two main parts:\nplu-ts/onchain\nplu-ts/offchain\nsee Getting Started to begin your journey in plu-ts\nplu-ts was designed with the following goals in mind, in order of importance:\nplu-ts"
  },
  {
    "prompt": "Getting Started?",
    "completion": "npm\nnpm install @harmoniclabs/plu-ts\nnpm install @harmoniclabs/plu-ts\nnpm is the package manager use by NodeJS you can install node and npm from the NodeJS website\nnpm\nNodeJS\nnode\nnpm\nNodeJS\ngit clone https://github.com/HarmonicLabs/plu-tscd plu-tsnpm run build\ngit clone https://github.com/HarmonicLabs/plu-tscd plu-tsnpm run build\ndist\nThe library is then available in the dist folder.\ndist\nYou can move the directory where you need it\nFirst create a new directory where to build your project\nmkdir my-pluts-projectcd my-pluts-project\nmkdir my-pluts-projectcd my-pluts-project\nThen initialize your node project with npm\nnpm\nnpm init\nnpm init\nInstall typescript and the typescript compiler tsc if it is not already available globally\ntypescript\ntsc\nnpm install --save-dev typescript\nnpm install --save-dev typescript\nFinally install plu-ts\nplu-ts\nnpm install @harmoniclabs/plu-ts\nnpm install @harmoniclabs/plu-ts\nHave a look at Examples for some example project\nnpm"
  },
  {
    "prompt": "Examples?",
    "completion": "Some examples using plu-ts and tools\nYou can find the last version here.\nIn this example project we'll write our first smart contract and interact with it using the CIP-0030 standard.\nNow that we are a bit more familiar on how to interact properly with a smart contract,\nNow we can continue with a simple minting policy example."
  },
  {
    "prompt": "Onchain?",
    "completion": "Core concepts\nAs we saw in Concepts plu-ts is an eDSL embedded in Typescript, as such we have two type systems; the Typescript one and the plu-ts one\n5 items\n3 items\n1 items\n3 items\n8 items\n2 items"
  },
  {
    "prompt": "Offchain?",
    "completion": "Cardano ledger types implementation and the \"TxBuilder\" API\n10 items\n27 items\n8 items\n6 items\n5 items"
  },
  {
    "prompt": "Tools?",
    "completion": "Tools that will help you build great things\ncardanocli-pluts\nkoios-pluts\nblockfrost-pluts"
  },
  {
    "prompt": "Hello pluts?",
    "completion": "You can find the last version here.\nAll we need to build a Smart contract and interact with it is:\nplu-ts\nInfact, plu-ts allows you to write the smart contract and create transactions.\nplu-ts\nTo submit the tranasction we will use the koios API, with a simple POST request to the submit endpoint; but we'll think about that later.\nSo for now our pre-requisites add up to:\nplu-ts\nnpm\nusign git we clone a very simple template project:\ngit\ngit clone https://github.com/HarmonicLabs/plu-ts-starter.gitmv plu-ts-starter hello-plutscd hello-plutsgit remote remove origin\ngit clone https://github.com/HarmonicLabs/plu-ts-starter.gitmv plu-ts-starter hello-plutscd hello-plutsgit remote remove origin\nthis gives us a simple project structure:\n./hello-plutsâ”œâ”€â”€ package.jsonâ”œâ”€â”€ package-lock.jsonâ”œâ”€â”€ Introductionâ”œâ”€â”€ srcâ”‚ â”œâ”€â”€ contract.tsâ”‚ â”œâ”€â”€ index.tsâ”‚ â”œâ”€â”€ MyDatumâ”‚ â”‚ â””â”€â”€ index.tsâ”‚ â””â”€â”€ MyRedeemerâ”‚ â””â”€â”€ index.tsâ””â”€â”€ tsconfig.json\n./hello-plutsâ”œâ”€â”€ package.jsonâ”œâ”€â”€ package-lock.jsonâ”œâ”€â”€ Introductionâ”œâ”€â”€ srcâ”‚ â”œâ”€â”€ contract.tsâ”‚ â”œâ”€â”€ index.tsâ”‚ â”œâ”€â”€ MyDatumâ”‚ â”‚ â””â”€â”€ index.tsâ”‚ â””â”€â”€ MyRedeemerâ”‚ â””â”€â”€ index.tsâ””â”€â”€ tsconfig.json\nNow we only need to run npm install to automatically add the plu-ts library.\nnpm install\nplu-ts\nnpm install\nnpm install\net voil we are ready to start!\nIf we now navigate to src/contract.ts we see we have a very simple validator already!\nsrc/contract.ts\nimport { Address, bool, compile, makeValidator, PaymentCredentials, pBool, pfn, Script, ScriptType, V2 } from \"@harmoniclabs/plu-ts\";import MyDatum from \"./MyDatum\";import MyRedeemer from \"./MyRedeemer\";export const contract = pfn([ MyDatum.type, MyRedeemer.type, V2.PScriptContext.type], bool)(( datum, redeemer, ctx ) => // always suceeds pBool( true ));///////////////////////////////////////////////////////////////////// ------------------------------------------------------------- //// ------------------------- utilities ------------------------- //// ------------------------------------------------------------- /////////////////////////////////////////////////////////////////////export const untypedValidator = makeValidator( contract );export const compiledContract = compile( untypedValidator );export const script = new Script( ScriptType.PlutusV2, compiledContract);export const scriptMainnetAddr = new Address( \"mainnet\", new PaymentCredentials( \"script\", script.hash ));export const scriptTestnetAddr = new Address( \"testnet\", new PaymentCredentials( \"script\", script.hash.clone() ));export default contract;\nimport { Address, bool, compile, makeValidator, PaymentCredentials, pBool, pfn, Script, ScriptType, V2 } from \"@harmoniclabs/plu-ts\";import MyDatum from \"./MyDatum\";import MyRedeemer from \"./MyRedeemer\";export const contract = pfn([ MyDatum.type, MyRedeemer.type, V2.PScriptContext.type], bool)(( datum, redeemer, ctx ) => // always suceeds pBool( true ));///////////////////////////////////////////////////////////////////// ------------------------------------------------------------- //// ------------------------- utilities ------------------------- //// ------------------------------------------------------------- /////////////////////////////////////////////////////////////////////export const untypedValidator = makeValidator( contract );export const compiledContract = compile( untypedValidator );export const script = new Script( ScriptType.PlutusV2, compiledContract);export const scriptMainnetAddr = new Address( \"mainnet\", new PaymentCredentials( \"script\", script.hash ));export const scriptTestnetAddr = new Address( \"testnet\", new PaymentCredentials( \"script\", script.hash.clone() ));export default contract;\nLet's focus only on the contract for now;\nthis contract expects a MyDatum, a MyRedeemer and finally a PScriptContext to validate a transaction.\nMyDatum\nMyRedeemer\nPScriptContext\nAll of the three above are just Structs\nStruct\nMyDatum and MyRedeemer are types defined by us respectively in src/MyDatum/index.ts and src/MyRedeemer/index.ts\nMyDatum\nMyRedeemer\nsrc/MyDatum/index.ts\nsrc/MyRedeemer/index.ts\nimport { int, pstruct } from \"@harmoniclabs/plu-ts\";// modify the Datum as you preferconst MyDatum = pstruct({ Num: { number: int }, NoDatum: {}});export default MyDatum;\nimport { int, pstruct } from \"@harmoniclabs/plu-ts\";// modify the Datum as you preferconst MyDatum = pstruct({ Num: { number: int }, NoDatum: {}});export default MyDatum;\nimport { pstruct } from \"@harmoniclabs/plu-ts\";// modify the Redeemer as you preferconst MyRedeemer = pstruct({ Option1: {}, Option2: {}});export default MyRedeemer;\nimport { pstruct } from \"@harmoniclabs/plu-ts\";// modify the Redeemer as you preferconst MyRedeemer = pstruct({ Option1: {}, Option2: {}});export default MyRedeemer;\nwhereas PScriptContext is a predefined data structure that is passed by the cardano-node itself that will run our smart contract.\nPScriptContext\ncardano-node\nfinally, the contract is used in src/index.ts which is our entry point.\nsrc/index.ts\nimport { script } from \"./contract\";console.log(\"validator compiled succesfully! ðŸŽ‰\\n\");console.log( JSON.stringify( script.toJson(), undefined, 2 ));\nimport { script } from \"./contract\";console.log(\"validator compiled succesfully! ðŸŽ‰\\n\");console.log( JSON.stringify( script.toJson(), undefined, 2 ));\nthe index just imports script from src/contract.ts adn prints it out in the json form.\nscript\nsrc/contract.ts\nif we go back to src/contract.ts we see that the script is obtained using the following steps:\nsrc/contract.ts\nmakeValidator\n/* ... */export const untypedValidator = makeValidator( contract );export const compiledContract = compile( untypedValidator );export const script = new Script( ScriptType.PlutusV2, compiledContract);/* ... */\n/* ... */export const untypedValidator = makeValidator( contract );export const compiledContract = compile( untypedValidator );export const script = new Script( ScriptType.PlutusV2, compiledContract);/* ... */\ncompile\n/* ... */export const untypedValidator = makeValidator( contract );export const compiledContract = compile( untypedValidator );export const script = new Script( ScriptType.PlutusV2, compiledContract);/* ... */\n/* ... */export const untypedValidator = makeValidator( contract );export const compiledContract = compile( untypedValidator );export const script = new Script( ScriptType.PlutusV2, compiledContract);/* ... */\nScript\n/* ... */export const untypedValidator = makeValidator( contract );export const compiledContract = compile( untypedValidator );export const script = new Script( ScriptType.PlutusV2, compiledContract);/* ... */\n/* ... */export const untypedValidator = makeValidator( contract );export const compiledContract = compile( untypedValidator );export const script = new Script( ScriptType.PlutusV2, compiledContract);/* ... */\nthat is all we need for now.\nIf we did every step of above correctly we should be able to run\nnpm run start\nnpm run start\nand the output should look like:\nvalidator compiled succesfully! ðŸŽ‰{ \"type\": \"PlutusScriptV2\", \"description\": \"\", \"cborHex\": \"56550100002225333573466644494400c0080045261601\"}\nvalidator compiled succesfully! ðŸŽ‰{ \"type\": \"PlutusScriptV2\", \"description\": \"\", \"cborHex\": \"56550100002225333573466644494400c0080045261601\"}\nWell congratulations !\nthis is your first compiled smart contract !\nBut we won't stop here for sure!\nLet's personalize this smart contract.\nWe want to personalize the smart contract so that:\nowner\nTo make sure the transaction is signed by us we'll keep track of an owner in the datum (the first argument we saw in the contract).\nowner\nThe datum helps us keep track of the history of the input the smart contract is validating.\nCurrently our datum is a struct, but it could be really anything;\nand all we need to keep track of an owner is just a public key hash.\nso in src/contract.ts we'll change MyDatum to PPubKeyHash:\nsrc/contract.ts\nMyDatum\nPPubKeyHash\nPPubKeyHash is just an Alias for bytestrings (of type bs)\nPPubKeyHash\nAlias\nbs\nimport { Address, bool, compile, makeValidator, PaymentCredentials, pBool, pfn, Script, ScriptType, V2 } from \"@harmoniclabs/plu-ts\";import MyDatum from \"./MyDatum\";import MyRedeemer from \"./MyRedeemer\";const contract = pfn([ PPubKeyHash.type, MyRedeemer.type, V2.PScriptContext.type], bool)// we should also change the name of the variable here// from `datum` to `owner`(( owner, redeemer, ctx ) => // always suceeds pBool( true ));/* ... */\nimport { Address, bool, compile, makeValidator, PaymentCredentials, pBool, pfn, Script, ScriptType, V2 } from \"@harmoniclabs/plu-ts\";import MyDatum from \"./MyDatum\";import MyRedeemer from \"./MyRedeemer\";const contract = pfn([ PPubKeyHash.type, MyRedeemer.type, V2.PScriptContext.type], bool)// we should also change the name of the variable here// from `datum` to `owner`(( owner, redeemer, ctx ) => // always suceeds pBool( true ));/* ... */\nThe second condtion requires us to send some message to the contract.\nThis is done thanks to the redeemer (or the second argument of a validator).\nThe redeemer is the argument specified by the user that interacts with the smart contract\nonce again, all we need in order to have a message is just a bytestring, nothing more complex,\nbytestring\nso we'll change MyRedeemer to the primitive type bs\nMyRedeemer\nbs\nimport { Address, bool, compile, makeValidator, PaymentCredentials, pBool, pfn, Script, ScriptType, V2 } from \"@harmoniclabs/plu-ts\";import MyDatum from \"./MyDatum\";import MyRedeemer from \"./MyRedeemer\";const contract = pfn([ PPubKeyHash.type, bs, V2.PScriptContext.type], bool)// we should also change the name of the variable here// from `redeemer` to `message`(( owner, message, ctx ) => // always suceeds pBool( true ));/* ... */\nimport { Address, bool, compile, makeValidator, PaymentCredentials, pBool, pfn, Script, ScriptType, V2 } from \"@harmoniclabs/plu-ts\";import MyDatum from \"./MyDatum\";import MyRedeemer from \"./MyRedeemer\";const contract = pfn([ PPubKeyHash.type, bs, V2.PScriptContext.type], bool)// we should also change the name of the variable here// from `redeemer` to `message`(( owner, message, ctx ) => // always suceeds pBool( true ));/* ... */\nfinally we'll check both the conditions in the body of the function.\nso we'll first create a term that checks that the message is the one expected:\nconst isBeingPolite = message.eq(\"Hello plu-ts\");\nconst isBeingPolite = message.eq(\"Hello plu-ts\");\nthen we'll check that the transaction is signed by the owner specified in the datum.\nto do so we need informations about the tranasaction and who signed it.\nall the informations about the tranasaction are in the tx field of the PScriptContext\ntx\nPScriptContext\nan in particular we are interested in the signatories field\nsignatories\nctx.tx.signatories;\nctx.tx.signatories;\nsince this is a list of all the required singers we chan use all the TermList methods; of which some allows us to check that at leat one element of the list respects a given property:\nTermList\nsome\nconst signedByOwner = ctx.tx.signatories.some( owner.eqTerm );\nconst signedByOwner = ctx.tx.signatories.some( owner.eqTerm );\nand finally, we put all together\n/* ... */const contract = pfn([ PPubKeyHash.type, bs, V2.PScriptContext.type], bool)(( owner, message, ctx ) => { const isBeingPolite = message.eq(\"Hello plu-ts\"); const signedByOwner = ctx.tx.signatories.some( owner.eqTerm ); return isBeingPolite.and( signedByOwner );});/* ... */\n/* ... */const contract = pfn([ PPubKeyHash.type, bs, V2.PScriptContext.type], bool)(( owner, message, ctx ) => { const isBeingPolite = message.eq(\"Hello plu-ts\"); const signedByOwner = ctx.tx.signatories.some( owner.eqTerm ); return isBeingPolite.and( signedByOwner );});/* ... */\nnow runing the program with npm run start gives us back:\nnpm run start\nvalidator compiled succesfully! ðŸŽ‰{ \"type\": \"PlutusScriptV2\", \"description\": \"\", \"cborHex\": \"58fd58fb0100003232323232323232323232222533357346664446600e66e3c00922010c48656c6c6f20706c752d74730013300823371e00200866014002464660180024640026601ceb8dd6180a0009aba1001375c0066eb800800452616225333573400400229408cc01c852891119802980200109801800912999ab9a00214a20024460026aae78dd5001119801000a5eb108c0088d5d01801000911980190801111198028011801800980091111919980398020009801800801198020018011191801119801001000918011198010010009112999aab9f001003133002357420026ae880048d5d09aba2357446ae88d5d11aba2357446ae88d5d100081\"}\nvalidator compiled succesfully! ðŸŽ‰{ \"type\": \"PlutusScriptV2\", \"description\": \"\", \"cborHex\": \"58fd58fb0100003232323232323232323232222533357346664446600e66e3c00922010c48656c6c6f20706c752d74730013300823371e00200866014002464660180024640026601ceb8dd6180a0009aba1001375c0066eb800800452616225333573400400229408cc01c852891119802980200109801800912999ab9a00214a20024460026aae78dd5001119801000a5eb108c0088d5d01801000911980190801111198028011801800980091111919980398020009801800801198020018011191801119801001000918011198010010009112999aab9f001003133002357420026ae880048d5d09aba2357446ae88d5d11aba2357446ae88d5d100081\"}\nWe did it! We wrote our first contract!\nnow that we have our personal contract we'll use [Koios] to help us with the offchain.\nfor better integration we can install the koios-pluts package so that we can make requests to koios and have actual plu-ts values.\nkoios-pluts\nnpm install @harmoniclabs/koios-pluts\nnpm install @harmoniclabs/koios-pluts\neventually we'll also need some help with binary data\nnpm install @harmoniclabs/uint8array-utils\nnpm install @harmoniclabs/uint8array-utils\nthen to keep the project clean we'll create a new offchain folder, under src\noffchain\nsrc\nmkdir src/offchain\nmkdir src/offchain\nTo make sure we do all our requests in testnet koios-pluts exposes the utility class KoiosProvoder which will keep in mind the network we are operating in for us.\nkoios-pluts\nKoiosProvoder\nlet's build an instance:\nimport { KoiosProvider } from \"@harmoniclabs/koios-pluts\"export const koios = new KoiosProvider(\"testnet\");export default koios;\nimport { KoiosProvider } from \"@harmoniclabs/koios-pluts\"export const koios = new KoiosProvider(\"testnet\");export default koios;\nTo build a TxBuilder we'll need to fetch the current protocol parameters, that is an asyncronous operation;\nTxBuilder\nso we'll write an asnyc function that constructs our transaction builder:\nimport { koios } from \"./koios\"/** * we don't want to do too many API call if we already have our `txBuilder` * * so after the first call we'll store a copy here.**/let _cachedTxBuilder: TxBuilder | undefined = undefinedexport default async function getTxBuilder(): Promise<TxBuilder>{ if(!( _cachedTxBuilder instanceof TxBuilder )) _cachedTxBuilder = new TxBuilder( \"testnet\", await koios.epoch.protocolParams() // defaults to current epoch ); return _cachedTxBuilder;}\nimport { koios } from \"./koios\"/** * we don't want to do too many API call if we already have our `txBuilder` * * so after the first call we'll store a copy here.**/let _cachedTxBuilder: TxBuilder | undefined = undefinedexport default async function getTxBuilder(): Promise<TxBuilder>{ if(!( _cachedTxBuilder instanceof TxBuilder )) _cachedTxBuilder = new TxBuilder( \"testnet\", await koios.epoch.protocolParams() // defaults to current epoch ); return _cachedTxBuilder;}\nYou can use the Cardano Testnet Faucet.\nJust be sure to select the Preprod testnet.\ncardano-cli\nIf you are in a server environment (such as NodeJS, Deno or Bun) you can generate a testnet address by frist running\ncardano-cli address key-gen \\ --verification-key-file path/to/pubKey.vkey \\ --signing-key-file path/to/privKey.skey\ncardano-cli address key-gen \\ --verification-key-file path/to/pubKey.vkey \\ --signing-key-file path/to/privKey.skey\nand then using the verification key (public key) to generate an address.\nThis can be done both using cardano-cli or using plu-ts itself\ncardano-cli\nplu-ts\nconst myTestnetAddress = new Address( \"testnet\", new PaymentCredentials( \"pubKey\", PublicKey.fromCbor( JSON.parse( // the result of `cardano-cli` is a json file readFileSync( \"path/to/pubKey.vkey\", { encoding: \"utf8\" } ) ).cborHex ).hash ))\nconst myTestnetAddress = new Address( \"testnet\", new PaymentCredentials( \"pubKey\", PublicKey.fromCbor( JSON.parse( // the result of `cardano-cli` is a json file readFileSync( \"path/to/pubKey.vkey\", { encoding: \"utf8\" } ) ).cborHex ).hash ))\ncardano-cli address build \\ --payment-verification-key-file path/to/pubKey.vkey \\ --testnet-magic 1\ncardano-cli address build \\ --payment-verification-key-file path/to/pubKey.vkey \\ --testnet-magic 1\nonce you finish with your tADA make sure to return them to the faucet.\ntADA have no real world value but are still limited, and onther developers will need them!\nto return tADA to the faucet just send them to the following testnet address:\naddr_test1qqr585tvlc7ylnqvz8pyqwauzrdu0mxag3m7q56grgmgu7sxu2hyfhlkwuxupa9d5085eunq2qywy7hvmvej456flknswgndm3\naddr_test1qqr585tvlc7ylnqvz8pyqwauzrdu0mxag3m7q56grgmgu7sxu2hyfhlkwuxupa9d5085eunq2qywy7hvmvej456flknswgndm3\nnow that we have received our tADA we can start playng.\ntADA\nFirs we need to access them in our code.\nWe can do so by querying the utxos at the address you received the tADA to.\nsince we'll query our utxos some times we make an utility function for that.\nimport type { UTxO } from \"@harmoniclabs/plu-ts\"import { koios } from \"./koios\";export default async function queryMyUtxos(): Promise<UTxO[]>{ return await koios.address.utxos( \"<paste your tesnet address here>\" )}\nimport type { UTxO } from \"@harmoniclabs/plu-ts\"import { koios } from \"./koios\";export default async function queryMyUtxos(): Promise<UTxO[]>{ return await koios.address.utxos( \"<paste your tesnet address here>\" )}\nnow that we can access our utxos we can finally start building transactions.\nThe first transaction we want to do is to deploy the smart contract and found it.\nLet's check we got everything:\nTxBuilder\nyes, we can go!\nimport { Address, Value, DataB, Script, Tx } from \"@harmoniclabs/plu-ts\"import { scriptTestnetAddr } from \"../contract\";import getTxBuilder from \"./getTxBuilder\";import queryMyUtxos from \"./queryMyUtxos\";export default async function getDeployAndFoundTx( script: Script ): Promise<Tx>{ const txBuilder = await getTxBuilder(); const myUTxOs = await queryMyUtxos(); return txBuilder.buildSync({ inputs: [{ utxo: myUTxOs[0] }], outputs: [ { // output which holds the reference script address: scriptTestnetAddr, value: Value.lovelaces( 10_000_000 ), // an utxo with no datum that sits // that a script address (like in this case) // is locked FOREVER // this way no one will be able to \"un-deploy\" our smart contract datum: undefined, refScript: script }, { // output holding the founds that we'll spend later address: scriptTestnetAddr, value: Value.lovelaces( 10_000_000 ), // remeber to include a datum datum: new DataB( // remember we set the datum to be the public key hash? // we can extract it from the address as follows // first create an address form the bech32 form Address.fromString( \"<paste your address here>\" ) // then extract the pyament credential hash .paymentCreds.hash.toBuffer() ) } ], // send everything left back to us changeAddress: \"<paste your address here>\" });}\nimport { Address, Value, DataB, Script, Tx } from \"@harmoniclabs/plu-ts\"import { scriptTestnetAddr } from \"../contract\";import getTxBuilder from \"./getTxBuilder\";import queryMyUtxos from \"./queryMyUtxos\";export default async function getDeployAndFoundTx( script: Script ): Promise<Tx>{ const txBuilder = await getTxBuilder(); const myUTxOs = await queryMyUtxos(); return txBuilder.buildSync({ inputs: [{ utxo: myUTxOs[0] }], outputs: [ { // output which holds the reference script address: scriptTestnetAddr, value: Value.lovelaces( 10_000_000 ), // an utxo with no datum that sits // that a script address (like in this case) // is locked FOREVER // this way no one will be able to \"un-deploy\" our smart contract datum: undefined, refScript: script }, { // output holding the founds that we'll spend later address: scriptTestnetAddr, value: Value.lovelaces( 10_000_000 ), // remeber to include a datum datum: new DataB( // remember we set the datum to be the public key hash? // we can extract it from the address as follows // first create an address form the bech32 form Address.fromString( \"<paste your address here>\" ) // then extract the pyament credential hash .paymentCreds.hash.toBuffer() ) } ], // send everything left back to us changeAddress: \"<paste your address here>\" });}\nnow that we have a Tx we are just two steps away from it to be registered on-chain:\nTx\nto sign a transaciton you'll need the private key of your address.\ndepending on your environment then there are two ways to sign it:\nIn the browser we can use the CIP-0030 standard to sign the transaction.\nthe standard wants us to pass the CBOR of the transaction encoded as hex string.\nthat is not a problem because we can get it as follows:\ntx.toCbor().toString()\ntx.toCbor().toString()\nit then returns a new CBOR encoded as hex string which represents the signature.\nwe can add the signature to our transaction as follows:\nconst witnessSet = TxWitnessSet.fromCbor( \"<CIP-0030 'signTx' result here>\");for(const vkeyWit of witnessSet.vkeyWitnesses){ tx.addVKeyWitness( vkeyWit )}\nconst witnessSet = TxWitnessSet.fromCbor( \"<CIP-0030 'signTx' result here>\");for(const vkeyWit of witnessSet.vkeyWitnesses){ tx.addVKeyWitness( vkeyWit )}\nso all together becomes\nasync function signWithBrowser( tx: Tx, cip30wallet: any ): void{ const witnessSet = TxWitnessSet.fromCbor( await cip30wallet.signTx( tx.toCbor().toString() ) ); for(const vkeyWit of witnessSet.vkeyWitnesses) { tx.addVKeyWitness( vkeyWit ) }}\nasync function signWithBrowser( tx: Tx, cip30wallet: any ): void{ const witnessSet = TxWitnessSet.fromCbor( await cip30wallet.signTx( tx.toCbor().toString() ) ); for(const vkeyWit of witnessSet.vkeyWitnesses) { tx.addVKeyWitness( vkeyWit ) }}\nIf we are in a server environmet is very likely we have our private key stored in some file.\nso we can just read the private key from there.\nOnce we have teh private key we can then use it to sign the transaction; plu-ts handles the cryptography\nplu-ts\ntx.signWith( privateKey )\ntx.signWith( privateKey )\nand that's it\nso the final code is:\nfunction signWithServer( tx: Tx ): void{ tx.signWith( PrivateKey.fromCbor( JSON.parse( // the result of `cardano-cli` is a json file readFileSync( \"path/to/privKey.skey\", { encoding: \"utf8\" } ) ).cborHex ) );}\nfunction signWithServer( tx: Tx ): void{ tx.signWith( PrivateKey.fromCbor( JSON.parse( // the result of `cardano-cli` is a json file readFileSync( \"path/to/privKey.skey\", { encoding: \"utf8\" } ) ).cborHex ) );}\nnow we can finally deploy the smart contract all we need to do is just call the koios endpoint\n/* onther imports */import { koios } from \"./offchain/koios\"/* ... */async function main(){ let tx = await getDeployAndFoundTx( script ); signWithServer( tx ); await koios.tx.submit( tx );}main();\n/* onther imports */import { koios } from \"./offchain/koios\"/* ... */async function main(){ let tx = await getDeployAndFoundTx( script ); signWithServer( tx ); await koios.tx.submit( tx );}main();\nThe last step is to build a new trasaction that will allow us to spend the founds we sent to the contract.\nApart for this step the process very similar.\nIf you remember we deployed our script to an UTxO that is locked forever.\nWe need that UTxO to interact with the contract.\nwe could query but we already have all the infos to build it ourselves.\nan UTxO is composed by a TxOutRef and a TxOut\nUTxO\nTxOutRef\nTxOut\nthe TxOutRef is just the hash of the Tx` that generated it and the index in the order of the outputs.\nTxOutRef is just the hash of the\nso our TxOutRef is:\nTxOutRef\nconst txOutRef = new TxOutRef({ id: tx.hash, index: 0});\nconst txOutRef = new TxOutRef({ id: tx.hash, index: 0});\nand the TxOut is the resolved reference, and we know exactly what's on that utxo:\nTxOut\nconst txOut = new TxOut({ address: scriptTestnetAddr, value: Value.lovelaces( 10_000_000 ), refScript: script});\nconst txOut = new TxOut({ address: scriptTestnetAddr, value: Value.lovelaces( 10_000_000 ), refScript: script});\nso our reference utxo is\nconst myRefUtxo = new UTxO({ utxoRef: txOutRef, resolved: txOut});\nconst myRefUtxo = new UTxO({ utxoRef: txOutRef, resolved: txOut});\nwith that utxo reference we can build our tranasction\nimport { DataB, isData, Hash32, Tx, UTxO } from \"@harmoniclabs/plu-ts\"import { scriptTestnetAddr } from \"../contract\";import * as uint8array from \"@harmoniclabs/uint8array-utils\";import koios from \"./koios\";import getTxBuilder from \"./getTxBuilder\";import queryMyUtxos from \"./queryMyUtxos\";export default async function getSpendPoliteTx( myRefUtxo: UTxO ): Promise<Tx>{ const txBuilder = await getTxBuilder(); const myUTxOs = await queryMyUtxos(); // find the other utxo of the previous tx const utxoToSpend = (await koios.address.utxos( scriptTestnetAddr )) .find( utxo => isData( utxo.resolved.datum ) ); if( utxoToSpend === undefined ) { throw \"uopsie, are you sure your tx had enough time to get to the blockchain?\" } return txBuilder.buildSync({ inputs: [ { utxo: utxoToSpend, // we must include the utxo that holds our script referenceScriptV2: { refUtxo: myRefUtxo, datum: \"inline\", // the datum is present already on `utxoToSpend` redeemer: new DataB( uint8array.fromAscii(\"Hello plu-ts\") ) // be polite } } ], // make sure to include collateral when using contracts collaterals: [ myUTxOs[0] ], // send everything back to us changeAddress: \"addr_test1vpv03vsr8mtgu7sftu82x0y3nmv4fs6xnkw5jvrkw3luw3ck4hmfa\" });}\nimport { DataB, isData, Hash32, Tx, UTxO } from \"@harmoniclabs/plu-ts\"import { scriptTestnetAddr } from \"../contract\";import * as uint8array from \"@harmoniclabs/uint8array-utils\";import koios from \"./koios\";import getTxBuilder from \"./getTxBuilder\";import queryMyUtxos from \"./queryMyUtxos\";export default async function getSpendPoliteTx( myRefUtxo: UTxO ): Promise<Tx>{ const txBuilder = await getTxBuilder(); const myUTxOs = await queryMyUtxos(); // find the other utxo of the previous tx const utxoToSpend = (await koios.address.utxos( scriptTestnetAddr )) .find( utxo => isData( utxo.resolved.datum ) ); if( utxoToSpend === undefined ) { throw \"uopsie, are you sure your tx had enough time to get to the blockchain?\" } return txBuilder.buildSync({ inputs: [ { utxo: utxoToSpend, // we must include the utxo that holds our script referenceScriptV2: { refUtxo: myRefUtxo, datum: \"inline\", // the datum is present already on `utxoToSpend` redeemer: new DataB( uint8array.fromAscii(\"Hello plu-ts\") ) // be polite } } ], // make sure to include collateral when using contracts collaterals: [ myUTxOs[0] ], // send everything back to us changeAddress: \"addr_test1vpv03vsr8mtgu7sftu82x0y3nmv4fs6xnkw5jvrkw3luw3ck4hmfa\" });}\nWe can re use the fuctions defined above for both signing and submission.\nso all we need to do now is really just put everything together\nimport { script, scriptTestnetAddr } from \"./contract\";import { koios } from \"./offchain/koios\";/* ... */async main(){ let tx = await getDeployAndFoundTx( script ); await signTxServer( tx ); await koios.tx.submit( tx ); console.log( \"waiting for tx '\" + tx.hash.toString() + \"' to be on-chain...\") await koios.tx.waitConfirmed( tx ); const myRefUtxo = new UTxO({ utxoRef: new TxOutRef({ id: tx.hash, index: 0 }), resolved: new TxOut({ address: scriptTestnetAddr, value: Value.lovelaces( 10_000_000 ), refScript: script }) }); tx = await getSpendPoliteTx( myRefUtxo ) signWithServer( tx ); await koios.tx.submit( tx ); console.log( \"waiting for tx '\" + tx.hash.toString() + \"' to be on-chain...\\n\\n\") await koios.tx.waitConfirmed( tx ); console.log( `Unlocked ${ tx.body.inputs[0].resolved.value.lovelaces / BigInt(1_000_00) } tADA ` + `from ${scriptTestnetAddr.toString()}!\\n\\n` + `Check the transaction on Cardanoscan: https://preview.cardanoscan.io/transaction/${tx.hash.toString()}?tab=contracts` )}main();\nimport { script, scriptTestnetAddr } from \"./contract\";import { koios } from \"./offchain/koios\";/* ... */async main(){ let tx = await getDeployAndFoundTx( script ); await signTxServer( tx ); await koios.tx.submit( tx ); console.log( \"waiting for tx '\" + tx.hash.toString() + \"' to be on-chain...\") await koios.tx.waitConfirmed( tx ); const myRefUtxo = new UTxO({ utxoRef: new TxOutRef({ id: tx.hash, index: 0 }), resolved: new TxOut({ address: scriptTestnetAddr, value: Value.lovelaces( 10_000_000 ), refScript: script }) }); tx = await getSpendPoliteTx( myRefUtxo ) signWithServer( tx ); await koios.tx.submit( tx ); console.log( \"waiting for tx '\" + tx.hash.toString() + \"' to be on-chain...\\n\\n\") await koios.tx.waitConfirmed( tx ); console.log( `Unlocked ${ tx.body.inputs[0].resolved.value.lovelaces / BigInt(1_000_00) } tADA ` + `from ${scriptTestnetAddr.toString()}!\\n\\n` + `Check the transaction on Cardanoscan: https://preview.cardanoscan.io/transaction/${tx.hash.toString()}?tab=contracts` )}main();\nIf everything whent trough correctly running the program wiht npm run start should now show something like:\nnpm run start\nUnlocked 10 tADA from addr_test1vabcd... !Check the transaction on Cardanoscan: https://preview.cardanoscan.io/transaction/beefcaffee...?tab=contracts\nUnlocked 10 tADA from addr_test1vabcd... !Check the transaction on Cardanoscan: https://preview.cardanoscan.io/transaction/beefcaffee...?tab=contracts\ntADA\nWhen you are done playing the testnet be sure to return your tADA to the faucet.\ntADA\nHere, as a bonus you can build the transaction yourself!\nconst returnTADA = txBuilder.buildSync({ inputs: (await koios.address.utxos(\"<paste your address here>\")) .map( utxo => ({ utxo }) ) // wrap in the expected input format // the faucet address changeAddress: \"addr_test1qqr585tvlc7ylnqvz8pyqwauzrdu0mxag3m7q56grgmgu7sxu2hyfhlkwuxupa9d5085eunq2qywy7hvmvej456flknswgndm3\"})\nconst returnTADA = txBuilder.buildSync({ inputs: (await koios.address.utxos(\"<paste your address here>\")) .map( utxo => ({ utxo }) ) // wrap in the expected input format // the faucet address changeAddress: \"addr_test1qqr585tvlc7ylnqvz8pyqwauzrdu0mxag3m7q56grgmgu7sxu2hyfhlkwuxupa9d5085eunq2qywy7hvmvej456flknswgndm3\"})\nowner\ntADA"
  },
  {
    "prompt": "Vesting?",
    "completion": "Now that we are a bit more familiar on how to interact properly with a smart contract, let's do a step forward and see if we can come up with a slightly more complex contract.\nThe final result can be found at HarmonicLabs/vesting-pluts.\nHarmonicLabs/vesting-pluts\nCheck package.json file at HarmonicLabs/vesting-pluts for versions of packages used lately.\npackage.json\nHarmonicLabs/vesting-pluts\nWe will once again start from the plu-ts-starter template (with the plu-ts version ~0.8.2) :\nplu-ts-starter\ngit clone https://github.com/HarmonicLabs/plu-ts-starter.gitmv plu-ts-starter vesting-plutscd vesting-plutsgit remote remove origin\ngit clone https://github.com/HarmonicLabs/plu-ts-starter.gitmv plu-ts-starter vesting-plutscd vesting-plutsgit remote remove origin\nthis gives us a simple project structure:\n./vesting-plutsâ”œâ”€â”€ package.jsonâ”œâ”€â”€ package-lock.jsonâ”œâ”€â”€ Introductionâ”œâ”€â”€ srcâ”‚ â”œâ”€â”€ contract.tsâ”‚ â”œâ”€â”€ index.tsâ”‚ â”œâ”€â”€ MyDatumâ”‚ â”‚ â””â”€â”€ index.tsâ”‚ â””â”€â”€ MyRedeemerâ”‚ â””â”€â”€ index.tsâ””â”€â”€ tsconfig.json\n./vesting-plutsâ”œâ”€â”€ package.jsonâ”œâ”€â”€ package-lock.jsonâ”œâ”€â”€ Introductionâ”œâ”€â”€ srcâ”‚ â”œâ”€â”€ contract.tsâ”‚ â”œâ”€â”€ index.tsâ”‚ â”œâ”€â”€ MyDatumâ”‚ â”‚ â””â”€â”€ index.tsâ”‚ â””â”€â”€ MyRedeemerâ”‚ â””â”€â”€ index.tsâ””â”€â”€ tsconfig.json\nJust like the Hello plu-ts example; this project already comes with plu-ts as dependency; all we need to do to then is to run\nnpm install\nnpm install\nThis time instead of working with Browser wallets, we will generate key pairs using Web Crypto API and thus generate address. We will also be making use of Blockfrost API to interact with the contract, address, transaction on/to-be-on chain (enabled with the package @harmoniclabs/blockfrost-pluts)\n@harmoniclabs/blockfrost-pluts\nBefore we dive in let's get familiar with the starter template.\nIf we now navigate to src/contract.ts we see we have a very simple validator already!\nsrc/contract.ts\nimport { Address, compile, Credential, pfn, Script, ScriptType, PScriptContext, unit, passert } from \"@harmoniclabs/plu-ts\";export const contract = pfn([ PScriptContext.type], unit )(( { redemeer, tx, purpose } ) => { // always succeeds return passert.$(true)});///////////////////////////////////////////////////////////////////// ------------------------------------------------------------- //// ------------------------- utilities ------------------------- //// ------------------------------------------------------------- /////////////////////////////////////////////////////////////////////export const compiledContract = compile( contract );export const script = new Script( ScriptType.PlutusV3, compiledContract);export const scriptMainnetAddr = new Address( \"mainnet\", Credential.script( script.hash ));export const scriptTestnetAddr = new Address( \"testnet\", Credential.script( script.hash.clone() ));export default contract;\nimport { Address, compile, Credential, pfn, Script, ScriptType, PScriptContext, unit, passert } from \"@harmoniclabs/plu-ts\";export const contract = pfn([ PScriptContext.type], unit )(( { redemeer, tx, purpose } ) => { // always succeeds return passert.$(true)});///////////////////////////////////////////////////////////////////// ------------------------------------------------------------- //// ------------------------- utilities ------------------------- //// ------------------------------------------------------------- /////////////////////////////////////////////////////////////////////export const compiledContract = compile( contract );export const script = new Script( ScriptType.PlutusV3, compiledContract);export const scriptMainnetAddr = new Address( \"mainnet\", Credential.script( script.hash ));export const scriptTestnetAddr = new Address( \"testnet\", Credential.script( script.hash.clone() ));export default contract;\nLet's focus only on the contract for now.\nAs per the latest Plutus V3, this contract expects a mandatory PScriptContext to validate a transaction.\nPScriptContext\nPScriptContext is a predefined data structure that is passed by the cardano-node itself that will run our smart contract.\nPScriptContext\ncardano-node\nFinally, the contract is used in src/index.ts which is our entry point.\nsrc/index.ts\nimport { script } from \"./contract\";console.log(\"validator compiled successfully! ðŸŽ‰\\n\");console.log( JSON.stringify( script.toJson(), undefined, 2 ));\nimport { script } from \"./contract\";console.log(\"validator compiled successfully! ðŸŽ‰\\n\");console.log( JSON.stringify( script.toJson(), undefined, 2 ));\nThe index just imports script from src/contract.ts and prints it out in the json form.\nscript\nsrc/contract.ts\nIf we go back to src/contract.ts we see that the script is obtained using the following steps:\nsrc/contract.ts\ncompile\nexport const compiledContract = compile( contract );export const script = new Script( ScriptType.PlutusV3, compiledContract);\nexport const compiledContract = compile( contract );export const script = new Script( ScriptType.PlutusV3, compiledContract);\nScript\nexport const compiledContract = compile( contract );export const script = new Script( ScriptType.PlutusV3, compiledContract);\nexport const compiledContract = compile( contract );export const script = new Script( ScriptType.PlutusV3, compiledContract);\nThat is all we need for now.\nIf we did every step above correctly, we should be able to run\nnpm run start\nnpm run start\nand the output should look like:\nvalidator compiled successfully! ðŸŽ‰{ \"type\": \"PlutusScriptV3\", \"description\": \"\", \"cborHex\": \"515001010023259800800c5268b2ae689441\"}\nvalidator compiled successfully! ðŸŽ‰{ \"type\": \"PlutusScriptV3\", \"description\": \"\", \"cborHex\": \"515001010023259800800c5268b2ae689441\"}\nWell congratulations !\nThis is your first compiled smart contract !\nBut we won't stop here for sure!\nLet's personalize this smart contract.\nThe contract should succeed if the following two conditions are met:\nPPubKeyHash\nFinite\ndeadline\nVestingDatum\nThe first thing we notice is that we need a custom datum.\nLet's create a folder VestingDatum with index.ts file to define the types beneficiary and deadline in the contract should hold.\nVestingDatum\nindex.ts\nbeneficiary\ndeadline\nNow, modify src/contract.ts as follows\nsrc/contract.ts\nimport { PPubKeyHash, int, pstruct } from \"@harmoniclabs/plu-ts\";// modify the Datum as you preferconst VestingDatum = pstruct({ VestingDatum: { beneficiary: PPubKeyHash.type, deadline: int // posix time }});export default VestingDatum;\nimport { PPubKeyHash, int, pstruct } from \"@harmoniclabs/plu-ts\";// modify the Datum as you preferconst VestingDatum = pstruct({ VestingDatum: { beneficiary: PPubKeyHash.type, deadline: int // posix time }});export default VestingDatum;\nThere is no change in the contract signature, as all details about the transaction and the purpose of the script within the transaction are embedded within PScriptContext.\nPScriptContext\n/* imports */export const contract = pfn([ PScriptContext.type], unit)(( {redeemer, tx, purpose} ) => { /* contract logic */});/* other code */\n/* imports */export const contract = pfn([ PScriptContext.type], unit)(( {redeemer, tx, purpose} ) => { /* contract logic */});/* other code */\nWe know for sure that we need 2 conditions. So we will check them separately using two terms- signedByBeneficiary and deadlineReached.\nsignedByBeneficiary\ndeadlineReached\nNow that we have our datum structure, we can use it in the contract definition.\n/* imports */export const contract = pfn([ PScriptContext.type], unit)(( {redeemer, tx, purpose} ) => { const maybeDatum = plet( pmatch(purpose) .onSpending(({ datum }) => datum) ._(_ => perror(PMaybe(data).type)) ); const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) ) const signedByBeneficiary = tx.signatories.some( datum.beneficiary.eq ) // inlined const deadlineReached = plet( pmatch( tx.interval.from.bound ) .onPFinite(({ n: lowerInterval }) => datum.deadline.ltEq( lowerInterval ) ) ._( _ => pBool( false ) ) ) return passert.$( (ptraceIfFalse.$(pdelay(pStr(\"Error in signedByBenificiary\"))).$(signedByBeneficiary)) .and( ptraceIfFalse.$(pdelay(pStr(\"deadline not reached or not specified\"))).$( deadlineReached ) ) );});/* other code */\n/* imports */export const contract = pfn([ PScriptContext.type], unit)(( {redeemer, tx, purpose} ) => { const maybeDatum = plet( pmatch(purpose) .onSpending(({ datum }) => datum) ._(_ => perror(PMaybe(data).type)) ); const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) ) const signedByBeneficiary = tx.signatories.some( datum.beneficiary.eq ) // inlined const deadlineReached = plet( pmatch( tx.interval.from.bound ) .onPFinite(({ n: lowerInterval }) => datum.deadline.ltEq( lowerInterval ) ) ._( _ => pBool( false ) ) ) return passert.$( (ptraceIfFalse.$(pdelay(pStr(\"Error in signedByBenificiary\"))).$(signedByBeneficiary)) .and( ptraceIfFalse.$(pdelay(pStr(\"deadline not reached or not specified\"))).$( deadlineReached ) ) );});/* other code */\nWe just initialize them to pBool( false ) so that if we forget them the contract fails.\npBool( false )\nBut we can already see the structure of the contract this way: we have two conditions, and we want both to be true.\n// inlined\nAs defined above the terms are inlined every time that are used.\nThis is because we are not using plet to create an actual plu-ts variable. Instead we are just holding a reference to that piece of code.\nplet\nplu-ts\nThis is not necessarily bad because it helps making the contract more readable (and plet would have inlined the term anyway in this particular case for efficiency).\nplet\nBut, it is definitely useful to keep in mind that what we have is always inlined with a small comment.\nsignedByBeneficiary\nThe first condition for the contract to succeed is:\nthe transaction is signed by the PPubKeyHash defined in the UTxO datum;\nPPubKeyHash\nTo check that we can use the signatories field defined in the PTxInfo struct.\nsignatories\nPTxInfo\nWe can access the field from the transaction using the dot notation:\ntx.signatories\ntx.signatories\nThe signatories field is a list of PPubKeyHash; so we have access to all the TermList methods.\nsignatories\nPPubKeyHash\nTermList\nso we can use the some method to check that at least one element of the list satisfies a given predicate.\nsome\nIn our case:\ntx.signatories.some( signer => signer.eq( datum.beneficiary ) );\ntx.signatories.some( signer => signer.eq( datum.beneficiary ) );\nOr the equivalent (but slightly more efficient)\ntx.signatories.some( datum.beneficiary.eq );\ntx.signatories.some( datum.beneficiary.eq );\nHere, we would define the beneficiary and deadline in datum of the spending transaction(in src/app/createVesting.ts).\nbeneficiary\ndeadline\ndatum\nsrc/app/createVesting.ts\nTo use them, extract the maybeDatum from purpose, and then properly type convert to ultimately get datum:\nmaybeDatum\npurpose\ndatum\nconst maybeDatum = plet( pmatch(purpose) .onSpending(({ datum }) => datum) ._(_ => perror(PMaybe(data).type)));const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) )\nconst maybeDatum = plet( pmatch(purpose) .onSpending(({ datum }) => datum) ._(_ => perror(PMaybe(data).type)));const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) )\nAnd that's it!\nOur signedByBeneficiary condition is ready\nsignedByBeneficiary\nconst maybeDatum = plet( pmatch(purpose) .onSpending(({ datum }) => datum) ._(_ => perror(PMaybe(data).type)));const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) )const signedByBeneficiary = tx.signatories.some( datum.beneficiary.eq )\nconst maybeDatum = plet( pmatch(purpose) .onSpending(({ datum }) => datum) ._(_ => perror(PMaybe(data).type)));const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) )const signedByBeneficiary = tx.signatories.some( datum.beneficiary.eq )\ndeadlineReached\nNow we can pass to the second condition:\nthe transaction lower bound is Finite and greater than the datum deadline field\nFinite\ndeadline\nThat is due to how time is handled on-chain.\nHandling time on chain is definitely not something simple due to the fact that the underlying system is distributed.\nThat means that we can't really be 100 sure of the exact moment the script is executed.\nTo work around this problem, time is represented on chain with a range in which the transaction is considered valid.\nIf ever the transaction where sent outside of the range, it would be rejected by the node before even executing the script!\nSo we can at least be sure that the script is executed in the given time range.\nWe can access the transaction validity time range trough the interval property of the PTxInfo struct.\ninterval\nPTxInfo\nThis is done once again using the dot notation:\ntx.interval\ntx.interval\nThe interval type is somewhat complex due to the nested structure; we have\ninterval\nfrom\nto\nbound\ninclusive\nbound\nbound\nconst PExtended = pstruct({ PNegInf: {}, PFinite: { n: int }, PPosInf: {}});\nconst PExtended = pstruct({ PNegInf: {}, PFinite: { n: int }, PPosInf: {}});\nwhere PFinite is the one we are interested in.\nPFinite\nSo reaching the bound field is the easy part and can be done as follows:\nbound\ntx.interval.from.bound\ntx.interval.from.bound\nBut then we have to use pmatch to understand what constructor was used.\npmatch\nIn particular, we are only interested in the PFinite one. So we'll use the underscore (_) wildcard to match the other two.\nPFinite\n_\npmatch( tx.interval.from.bound ).onPFinite(({ n: lowerInterval }) => /* deadline condition */)._( _ => pBool( false ) )\npmatch( tx.interval.from.bound ).onPFinite(({ n: lowerInterval }) => /* deadline condition */)._( _ => pBool( false ) )\nNow that we have access to the transaction lower bound, we can finally check for the deadline to have been passed.\ndatum.deadline.ltEq( lowerInterval )\ndatum.deadline.ltEq( lowerInterval )\nThe final deadlineReached condition becomes:\ndeadlineReached\n// inlinedconst deadlineReached = plet( pmatch( tx.interval.from.bound ) .onPFinite(({ n: lowerInterval }) => datum.deadline.ltEq( lowerInterval ) ) ._( _ => pBool( false ) ))\n// inlinedconst deadlineReached = plet( pmatch( tx.interval.from.bound ) .onPFinite(({ n: lowerInterval }) => datum.deadline.ltEq( lowerInterval ) ) ._( _ => pBool( false ) ))\nFor debugging closely in case the contract fails due to deadlineReached condition, and to throw a specific error in that case, we can add pTrace to the return statement and modify it as:\ndeadlineReached\npTrace\nreturn passert.$( (ptraceIfFalse.$(pdelay(pStr(\"Error in signedByBenificiary\"))).$(signedByBeneficiary)) .and( ptraceIfFalse.$(pdelay(pStr(\"deadline not reached or not specified\"))).$( deadlineReached ) ));\nreturn passert.$( (ptraceIfFalse.$(pdelay(pStr(\"Error in signedByBenificiary\"))).$(signedByBeneficiary)) .and( ptraceIfFalse.$(pdelay(pStr(\"deadline not reached or not specified\"))).$( deadlineReached ) ));\nOur smart contract should now look something like this:\nexport const contract = pfn([ PScriptContext.type], unit)(( {redeemer, tx, purpose} ) => { const maybeDatum = plet( pmatch(purpose) .onSpending(({ datum }) => datum) ._(_ => perror(PMaybe(data).type)) ); const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) ) const signedByBeneficiary = tx.signatories.some( datum.beneficiary.eq ) // inlined const deadlineReached = plet( pmatch( tx.interval.from.bound ) .onPFinite(({ n: lowerInterval }) => datum.deadline.ltEq( lowerInterval ) ) ._( _ => pBool( false ) ) ) return passert.$( (ptraceIfFalse.$(pdelay(pStr(\"Error in signedByBenificiary\"))).$(signedByBeneficiary)) .and( ptraceIfFalse.$(pdelay(pStr(\"deadline not reached or not specified\"))).$( deadlineReached ) ) );});\nexport const contract = pfn([ PScriptContext.type], unit)(( {redeemer, tx, purpose} ) => { const maybeDatum = plet( pmatch(purpose) .onSpending(({ datum }) => datum) ._(_ => perror(PMaybe(data).type)) ); const datum = plet( punsafeConvertType( maybeDatum.unwrap, VestingDatum.type ) ) const signedByBeneficiary = tx.signatories.some( datum.beneficiary.eq ) // inlined const deadlineReached = plet( pmatch( tx.interval.from.bound ) .onPFinite(({ n: lowerInterval }) => datum.deadline.ltEq( lowerInterval ) ) ._( _ => pBool( false ) ) ) return passert.$( (ptraceIfFalse.$(pdelay(pStr(\"Error in signedByBenificiary\"))).$(signedByBeneficiary)) .and( ptraceIfFalse.$(pdelay(pStr(\"deadline not reached or not specified\"))).$( deadlineReached ) ) );});\nAs we saw in the Hello plu-ts example project, we can compile the contract by passing the term to the compile function.\ncompile\nWe finally pass the compiled Contract to the Script constructor so that we can use it properly.\nScript\n/* contract definition above */export const compiledContract = compile( contract );export const script = new Script( ScriptType.PlutusV3, compiledContract);/* some other code */\n/* contract definition above */export const compiledContract = compile( contract );export const script = new Script( ScriptType.PlutusV3, compiledContract);/* some other code */\nSo now running the project using\nnpm run start\nnpm run start\nwe should see something like this\nvalidator compiled successfully! ðŸŽ‰{ \"type\": \"PlutusScriptV3\", \"description\": \"\", \"cborHex\": \"59022d59022a0101003232323232323223232323259800800c5268b2ae686644b3001002800c5282ae6866016292011c4572726f7220696e207369676e6564427942656e69666963696172790033233009214a04446644b30010028a51800aae68600800426006002466e3cdd71aba10020013323323009235740600400200297ac475c6eb0c8d5d09aba2357446ae88d5d11aba2357446ae88d5d10008010998058a48125646561646c696e65206e6f742072656163686564206f72206e6f7420737065636966696564003298009aba1300735742600e646ae84d5d11aba2357446ae88d5d11aba235744002007001919b89375a600e0066eb4d5d0800c005222232332598009800a400110038acc004c00520028802456600260029002440162cab9a2ae68ab9a1b8735573a0026aae78004dd500209281802991aba135573c6ea8004ca6002646ae84d5d11aba2001003800c00600300191803000c005222222232332598009800a400110038acc004c00520028802456600260029002440162b300130014801a200d1598009800a401110078acc004c005200a8804459573455cd1573455cd1573455cd0dc39aab9d00135573c0026ea801c4c60086ae84004c00c0048d5d09aba2001235573c6ea800488cc00c84008888cc014008c00c004c0088888ca600260080033003001801200c3300400300222259800800c00e2660046ae84004d5d1000aaae7c46460044660040040024600446600400400244b30010018a51899ab9c50024a0ab9a1\"}\nvalidator compiled successfully! ðŸŽ‰{ \"type\": \"PlutusScriptV3\", \"description\": \"\", \"cborHex\": \"59022d59022a0101003232323232323223232323259800800c5268b2ae686644b3001002800c5282ae6866016292011c4572726f7220696e207369676e6564427942656e69666963696172790033233009214a04446644b30010028a51800aae68600800426006002466e3cdd71aba10020013323323009235740600400200297ac475c6eb0c8d5d09aba2357446ae88d5d11aba2357446ae88d5d10008010998058a48125646561646c696e65206e6f742072656163686564206f72206e6f7420737065636966696564003298009aba1300735742600e646ae84d5d11aba2357446ae88d5d11aba235744002007001919b89375a600e0066eb4d5d0800c005222232332598009800a400110038acc004c00520028802456600260029002440162cab9a2ae68ab9a1b8735573a0026aae78004dd500209281802991aba135573c6ea8004ca6002646ae84d5d11aba2001003800c00600300191803000c005222222232332598009800a400110038acc004c00520028802456600260029002440162b300130014801a200d1598009800a401110078acc004c005200a8804459573455cd1573455cd1573455cd0dc39aab9d00135573c0026ea801c4c60086ae84004c00c0048d5d09aba2001235573c6ea800488cc00c84008888cc014008c00c004c0088888ca600260080033003001801200c3300400300222259800800c00e2660046ae84004d5d1000aaae7c46460044660040040024600446600400400244b30010018a51899ab9c50024a0ab9a1\"}\nFirst and foremost, we need to setup Blockfrost API to use in our app.\nIt is enabled by the package @harmoniclabs/blockfrost-pluts. In your terminal, do\n@harmoniclabs/blockfrost-pluts\nnpm install @harmoniclabs/blockfrost-pluts\nnpm install @harmoniclabs/blockfrost-pluts\nGo to https://blockfrost.io/ and create a new project for this example (a free plan is more than enough for now). Make sure to pick Preprod as your preferred network.\nPreprod\nOnce done, navigate to the Dashboard and copy over PROJECT_ID to setup.\nNow, create file blockfrost.ts within src/app:\nblockfrost.ts\nsrc/app\nimport { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";function blockfrost () { const provider = new BlockfrostPluts({ projectId: \"Paste your PROJECT_ID here\" }); return provider;}export default blockfrost;\nimport { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";function blockfrost () { const provider = new BlockfrostPluts({ projectId: \"Paste your PROJECT_ID here\" }); return provider;}export default blockfrost;\nMake sure to not check-in your PROJECT_ID into any versioning systems. Alternatively, you can always use environment variables here.\nTo enable blockfrost within other files, we will instantiate blockfrost() with the PROJECT_ID.\nblockfrost()\nTo perform transactions through Blockfrost, we need to instantiate our TxBuilder with Blockfrost.\nTxBuilder\nCreate file getTxBuilder.ts within src/app, exporting method getTxBuilder() which will thus be used to instantiate an instance of TxBuilder and further used.\ngetTxBuilder.ts\nsrc/app\ngetTxBuilder()\nTxBuilder\nimport { TxBuilder } from \"@harmoniclabs/plu-ts\";import { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";/** * we don't want to do too many API call if we already have our `txBuilder` * * so after the first call we'll store a copy here.**/let _cachedTxBuilder: TxBuilder | undefined = undefinedexport default async function getTxBuilder(Blockfrost: BlockfrostPluts): Promise<TxBuilder>{ if(!( _cachedTxBuilder instanceof TxBuilder )) { const parameters = await Blockfrost.getProtocolParameters(); _cachedTxBuilder = new TxBuilder(parameters); } return _cachedTxBuilder;}\nimport { TxBuilder } from \"@harmoniclabs/plu-ts\";import { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";/** * we don't want to do too many API call if we already have our `txBuilder` * * so after the first call we'll store a copy here.**/let _cachedTxBuilder: TxBuilder | undefined = undefinedexport default async function getTxBuilder(Blockfrost: BlockfrostPluts): Promise<TxBuilder>{ if(!( _cachedTxBuilder instanceof TxBuilder )) { const parameters = await Blockfrost.getProtocolParameters(); _cachedTxBuilder = new TxBuilder(parameters); } return _cachedTxBuilder;}\nWe will use the native npm script functionality to define some scripts to interact arbitrarily with our new contract.\nnpm\nWe can define a new script by adding an entry in the scripts field of the package.json file that you find in the root of the project.\nscripts\npackage.json\nRight now you should see something like this:\n\"scripts\": { \"build\": \"tsc -p ./tsconfig.json && tsc-alias -p ./tsconfig.json\", \"start\": \"npm run build && node dist/index.js\"},\n\"scripts\": { \"build\": \"tsc -p ./tsconfig.json && tsc-alias -p ./tsconfig.json\", \"start\": \"npm run build && node dist/index.js\"},\nWe can add our own scripts by specifying the script name as key and the command to execute as value.\nAs an example, say we want a better name for the \"start\" script, we could do something like:\n\"start\"\n\"scripts\": { \"build\": \"tsc -p ./tsconfig.json && tsc-alias -p ./tsconfig.json\", \"start\": \"npm run build && node dist/index.js\", \"vesting:compile\": \"npm run start\"},\n\"scripts\": { \"build\": \"tsc -p ./tsconfig.json && tsc-alias -p ./tsconfig.json\", \"start\": \"npm run build && node dist/index.js\", \"vesting:compile\": \"npm run start\"},\nNow running\nnpm run vesting:compile\nnpm run vesting:compile\nis equivalent to npm run start.\nnpm run start\nTo keep the project clean we'll create a new directory under src called app where all our scripts will be.\nsrc\napp\n./vesting-plutsâ””â”€â”€ src â””â”€â”€ app\n./vesting-plutsâ””â”€â”€ src â””â”€â”€ app\nNow we can start working with the off-chain part of plu-ts.\nLet's start by saving the compiled script to a file when we compile it.\nIn the src/index.ts file add the following:\nsrc/index.ts\nimport { existsSync } from \"fs\";import { mkdir, writeFile } from \"fs/promises\";/* old code */async function main() { if( !existsSync(\"./testnet\") ) { await mkdir(\"./testnet\"); } await writeFile(\"./testnet/vesting.plutus.json\", JSON.stringify(script.toJson(), undefined, 4))}main();\nimport { existsSync } from \"fs\";import { mkdir, writeFile } from \"fs/promises\";/* old code */async function main() { if( !existsSync(\"./testnet\") ) { await mkdir(\"./testnet\"); } await writeFile(\"./testnet/vesting.plutus.json\", JSON.stringify(script.toJson(), undefined, 4))}main();\nNow running\nnpm run vesting:compile\nnpm run vesting:compile\nshould still print a success result; but it will also create a new testnet directory with the file vesting.plutus.json in it.\ntestnet\nvesting.plutus.json\nDepending on if you are working in private or public testnet, there are 2 way to get your keys and start creating transactions.\nYou can generate your own key pair using generateKey() method from Crypto Web API. Read more about this here.\ngenerateKey()\nUsing this, to generate 2 pairs of keys, create a file genKeys.ts in the app folder that looks like this\ngenKeys.ts\napp\nimport { existsSync } from \"fs\";import { Address, Credential, PublicKey, PrivateKey, PubKeyHash } from \"@harmoniclabs/plu-ts\";import { config } from \"dotenv\";import { mkdir, writeFile } from \"fs/promises\";import pkg from 'blakejs';const { blake2b } = pkg;config();async function genKeys(){ const nKeys = 2; const promises: Promise<any>[] = []; if( !existsSync(\"./testnet\") ) { await mkdir(\"./testnet\"); } for( let i = 1; i <= nKeys; i++ ) { // generate public-private keypair let keyPair = await globalThis.crypto.subtle.generateKey( { name: \"Ed25519\", namedCurve: \"Ed25519\" }, true, [\"sign\", \"verify\"] ); // convert keyPair.(publicKey|privateKey)<CryptoKeyPair> ultimately to PublicKey which can be converted to cborString to store it for future reference // Export public key in a way compatible to Cardano CLI const publicKeyArrayBuffer = await globalThis.crypto.subtle.exportKey('raw', keyPair.publicKey); const publicKeyUint8Array = new Uint8Array(publicKeyArrayBuffer); const publicKey = new PublicKey(publicKeyUint8Array); const publicKeyHash = new PubKeyHash(blake2b(publicKeyUint8Array, undefined, 28)); // to build Credential const pubKeyJsonObj = { type: \"PaymentVerificationKeyShelley_ed25519\", description: \"Payment Verification Key\", cborHex: publicKey.toCbor().toString() }; // JSON structure similar to the one generated when by Cardano CLI const pubKeyJsonStr = JSON.stringify(pubKeyJsonObj, null, 4); await writeFile(`./testnet/payment${i}.vkey`, pubKeyJsonStr); // Export of the private key in a way that's compatible with the Cardano CLI const privateKeyArrayBuffer = await globalThis.crypto.subtle.exportKey('pkcs8', keyPair.privateKey); // privateKey cannot be exported 'raw' hence 'pkcs8' const privateKeyUint8Array = new Uint8Array(privateKeyArrayBuffer.slice(-32)); const privateKey = new PrivateKey(privateKeyUint8Array); const pvtKeyJsonObj = { type: \"PaymentSigningKeyShelley_ed25519\", description: \"Payment Signing Key\", cborHex: privateKey.toCbor().toString() }; // JSON structure similar to the one generated when by Cardano CLI const pvtKeyJsonStr = JSON.stringify(pvtKeyJsonObj, null, 4); await writeFile(`./testnet/payment${i}.skey`, pvtKeyJsonStr); // Check that the derivations went fine const pubKeyfromPriv = privateKey.derivePublicKey(); if (pubKeyfromPriv.toString() !== publicKey.toString()) { throw new Error(\"\\tPublic key derivation from private key failed\"); } else { console.log(\"\\tPublic key derivation from private key succeeded\"); } // Create the address const credential = Credential.keyHash(publicKeyHash); const address = new Address(\"testnet\", credential); await writeFile(`./testnet/address${i}.addr`, address.toString()); } // wait for all files to be copied await Promise.all( promises );}genKeys();\nimport { existsSync } from \"fs\";import { Address, Credential, PublicKey, PrivateKey, PubKeyHash } from \"@harmoniclabs/plu-ts\";import { config } from \"dotenv\";import { mkdir, writeFile } from \"fs/promises\";import pkg from 'blakejs';const { blake2b } = pkg;config();async function genKeys(){ const nKeys = 2; const promises: Promise<any>[] = []; if( !existsSync(\"./testnet\") ) { await mkdir(\"./testnet\"); } for( let i = 1; i <= nKeys; i++ ) { // generate public-private keypair let keyPair = await globalThis.crypto.subtle.generateKey( { name: \"Ed25519\", namedCurve: \"Ed25519\" }, true, [\"sign\", \"verify\"] ); // convert keyPair.(publicKey|privateKey)<CryptoKeyPair> ultimately to PublicKey which can be converted to cborString to store it for future reference // Export public key in a way compatible to Cardano CLI const publicKeyArrayBuffer = await globalThis.crypto.subtle.exportKey('raw', keyPair.publicKey); const publicKeyUint8Array = new Uint8Array(publicKeyArrayBuffer); const publicKey = new PublicKey(publicKeyUint8Array); const publicKeyHash = new PubKeyHash(blake2b(publicKeyUint8Array, undefined, 28)); // to build Credential const pubKeyJsonObj = { type: \"PaymentVerificationKeyShelley_ed25519\", description: \"Payment Verification Key\", cborHex: publicKey.toCbor().toString() }; // JSON structure similar to the one generated when by Cardano CLI const pubKeyJsonStr = JSON.stringify(pubKeyJsonObj, null, 4); await writeFile(`./testnet/payment${i}.vkey`, pubKeyJsonStr); // Export of the private key in a way that's compatible with the Cardano CLI const privateKeyArrayBuffer = await globalThis.crypto.subtle.exportKey('pkcs8', keyPair.privateKey); // privateKey cannot be exported 'raw' hence 'pkcs8' const privateKeyUint8Array = new Uint8Array(privateKeyArrayBuffer.slice(-32)); const privateKey = new PrivateKey(privateKeyUint8Array); const pvtKeyJsonObj = { type: \"PaymentSigningKeyShelley_ed25519\", description: \"Payment Signing Key\", cborHex: privateKey.toCbor().toString() }; // JSON structure similar to the one generated when by Cardano CLI const pvtKeyJsonStr = JSON.stringify(pvtKeyJsonObj, null, 4); await writeFile(`./testnet/payment${i}.skey`, pvtKeyJsonStr); // Check that the derivations went fine const pubKeyfromPriv = privateKey.derivePublicKey(); if (pubKeyfromPriv.toString() !== publicKey.toString()) { throw new Error(\"\\tPublic key derivation from private key failed\"); } else { console.log(\"\\tPublic key derivation from private key succeeded\"); } // Create the address const credential = Credential.keyHash(publicKeyHash); const address = new Address(\"testnet\", credential); await writeFile(`./testnet/address${i}.addr`, address.toString()); } // wait for all files to be copied await Promise.all( promises );}genKeys();\nAdd a new npm script vesting:genKeys\nnpm\nvesting:genKeys\n\"scripts\": { // ... \"vesting:genKeys\": \"npm run build:light && node dist/app/genKeys.js\"}\n\"scripts\": { // ... \"vesting:genKeys\": \"npm run build:light && node dist/app/genKeys.js\"}\nso that running\nnpm run vesting:genKeys\nnpm run vesting:genKeys\nshould give us 2 pairs of keys and 2 addresses under the testnet folder.\ntestnet\nRemember to fund the addresses. In this example, make sure to fund address1 and address2; just so that there has been some transactions involving these addresses, and they appear on blockchain and inturn be visible for Blockfrost. Read more about such possible Blockfrost error here.\nYou can use the Cardano Testnet Faucet to get some testnet funds. Just be sure to select Preprod testnet.\nPreprod\nIf you are working in the private testnet then you probably want to use some keys you already have.\nThen maybe you can copy those keys in the testnet folder we have here.\ntestnet\nTo do so we can set up a new setup.ts script under the app folder:\nsetup.ts\napp\nimport { existsSync } from \"fs\";import { config } from \"dotenv\";import { copyFile, mkdir } from \"fs/promises\";config();async function setup(){ const privateTestnet = process.env.PRIVATE_TESTNET_PATH ?? \".\"; const nKeys = 3; const promises: Promise<any>[] = []; if( !existsSync(\"./testnet\") ) { await mkdir(\"./testnet\"); } for( let i = 1; i <= nKeys; i++ ) { promises.push( copyFile(`${privateTestnet}/addresses/payment${i}.addr`, `./testnet/address${i}.addr`), copyFile(`${privateTestnet}/stake-delegator-keys/payment${i}.vkey`, `./testnet/payment${i}.vkey`), copyFile(`${privateTestnet}/stake-delegator-keys/payment${i}.skey`, `./testnet/payment${i}.skey`) ); } // wait for all files to be copied await Promise.all( promises );}setup();\nimport { existsSync } from \"fs\";import { config } from \"dotenv\";import { copyFile, mkdir } from \"fs/promises\";config();async function setup(){ const privateTestnet = process.env.PRIVATE_TESTNET_PATH ?? \".\"; const nKeys = 3; const promises: Promise<any>[] = []; if( !existsSync(\"./testnet\") ) { await mkdir(\"./testnet\"); } for( let i = 1; i <= nKeys; i++ ) { promises.push( copyFile(`${privateTestnet}/addresses/payment${i}.addr`, `./testnet/address${i}.addr`), copyFile(`${privateTestnet}/stake-delegator-keys/payment${i}.vkey`, `./testnet/payment${i}.vkey`), copyFile(`${privateTestnet}/stake-delegator-keys/payment${i}.skey`, `./testnet/payment${i}.skey`) ); } // wait for all files to be copied await Promise.all( promises );}setup();\nAnd then include a new npm script in package.json\nnpm script\npackage.json\n\"scripts\": { // ... \"vesting:setup\": \"npm run build:light && node dist/app/setup.js\"}\n\"scripts\": { // ... \"vesting:setup\": \"npm run build:light && node dist/app/setup.js\"}\nso that you can now run\nnpm run vesting:setup\nnpm run vesting:setup\nto have your keys and addresses copied in the testnet folder.\ntestnet\nNow we can finally start playing around with the vesting contract.\nSince we already have our file compiled and saved, it is probably a good idea to read the compiled result instead of re-compiling the contract each time we run the script.\nTo do so, we can always read the saved Script. First we need to read the vesting.plutus.json file as string.\nScript\nvesting.plutus.json\nconst scriptFile = await readFile(\"./testnet/vesting.plutus.json\", { encoding: \"utf-8\" });\nconst scriptFile = await readFile(\"./testnet/vesting.plutus.json\", { encoding: \"utf-8\" });\nThen, to finally retrieve the Script from the cborHex in the JSON file:\nScript\ncborHex\nconst script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3)\nconst script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3)\nMake sure to specify ScriptType.PlutusV3 as second argument to Script.fromCbor even though it is optional, because the defType arg is by default Script.PlutusV2 which being legacy.\nScriptType.PlutusV3\nScript.fromCbor\ndefType\nScript.PlutusV2\nFrom here we can generate the script address using the Address class (from the offchain of plu-ts) and the Script as Credential.\nAddress\nplu-ts\nScript\nCredential\nconst scriptAddr = new Address( \"testnet\", new Credential(CredentialType.Script, script.hash));\nconst scriptAddr = new Address( \"testnet\", new Credential(CredentialType.Script, script.hash));\nInstead of new Address(\"testnet\", ...), we can also do Address.testnet(...). Read more here.\nnew Address(\"testnet\", ...)\nAddress.testnet(...)\nNow, to build and send our transaction we are just missing the sender key, address and the beneficiary public key.\nOnce again we retrieve them from our saved files using node.js readFile.\nreadFile\nconst privateKeyFile = await readFile(\"./testnet/payment1.skey\", { encoding: \"utf-8\" });const privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex );const addr = await readFile(\"./testnet/address1.addr\", { encoding: \"utf-8\" });const address = Address.fromString(addr); const publicKeyFile = await readFile(\"./testnet/payment2.vkey\", { encoding: \"utf-8\" });const pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash;\nconst privateKeyFile = await readFile(\"./testnet/payment1.skey\", { encoding: \"utf-8\" });const privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex );const addr = await readFile(\"./testnet/address1.addr\", { encoding: \"utf-8\" });const address = Address.fromString(addr); const publicKeyFile = await readFile(\"./testnet/payment2.vkey\", { encoding: \"utf-8\" });const pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash;\nBefore we really start building our transaction we need some UTxOs to use as input. We can query the UTxOs available in our address through Blockfrost. Make sure to populate both the addresses with some funds.\nconst utxos = await Blockfrost.addressUtxos( address );\nconst utxos = await Blockfrost.addressUtxos( address );\nInstead of blindly assigning the first UTxO of the utxos[] as input, let us assure that we use the UTxO that has atleast 15 ada in it just to avoid possible failures.\nconst utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000)!;\nconst utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000)!;\nOur transaction will be constructed as follows:\nVestingDatum\nwhich translates to the following code\nlet tx = await txBuilder.buildSync({ inputs: [{ utxo: utxo }], collaterals: [ utxo ], outputs: [ { address: scriptAddr, value: Value.lovelaces( 10_000_000 ), datum: VestingDatum.VestingDatum({ beneficiary: pBSToData.$( pByteString( pkh.toBuffer() ) ), deadline: pIntToData.$( nowPosix + 10_000 ) }) } ], changeAddress: address});\nlet tx = await txBuilder.buildSync({ inputs: [{ utxo: utxo }], collaterals: [ utxo ], outputs: [ { address: scriptAddr, value: Value.lovelaces( 10_000_000 ), datum: VestingDatum.VestingDatum({ beneficiary: pBSToData.$( pByteString( pkh.toBuffer() ) ), deadline: pIntToData.$( nowPosix + 10_000 ) }) } ], changeAddress: address});\nThe datum attached to the output is generated using on-chain code!\ndatum\nThis is done, thanks to plu-ts, being able to evaluate on-chain code and use the result as Data.\nData\nThis way we can use the on-chain types to describe the plutus data off-chain, without the need to use low level Data elements!\nData\nNow that we have our transaction, all we need is just to Sign and Submit it.\nAnd guess what?\nThis is now extremly easy with plu-ts and Blockfrost.\nplu-ts\nBlockfrost\nawait tx.signWith( new PrivateKey(privateKey) );const submittedTx = await Blockfrost.submitTx( tx );\nawait tx.signWith( new PrivateKey(privateKey) );const submittedTx = await Blockfrost.submitTx( tx );\nAll we need to do now is to put it all together in a file createVesting.ts under the app folder.\ncreateVesting.ts\napp\nimport { Address, Credential, Hash28, PrivateKey, Value, pBSToData, pByteString, pIntToData, CredentialType, PublicKey, Script, ScriptType } from \"@harmoniclabs/plu-ts\";import VestingDatum from \"../VestingDatum\";import getTxBuilder from \"./getTxBuilder\";import { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";import blockfrost from \"./blockfrost\";import { readFile } from \"fs/promises\";async function createVesting(Blockfrost: BlockfrostPluts){ const txBuilder = await getTxBuilder(Blockfrost); const scriptFile = await readFile(\"./testnet/vesting.plutus.json\", { encoding: \"utf-8\" }); const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3) const scriptAddr = new Address( \"testnet\", new Credential(CredentialType.Script, script.hash) ); const privateKeyFile = await readFile(\"./testnet/payment1.skey\", { encoding: \"utf-8\" }); const privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex ); const addr = await readFile(\"./testnet/address1.addr\", { encoding: \"utf-8\" }); const address = Address.fromString(addr); const publicKeyFile = await readFile(\"./testnet/payment2.vkey\", { encoding: \"utf-8\" }); const pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash; const utxos = await Blockfrost.addressUtxos( address ) .catch( e => { throw new Error (\"unable to find utxos at \" + addr) }) // atleast has 10 ada const utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000)!; if (!utxo) { throw new Error(\"No utxo with more than 10 ada\"); } const nowPosix = Date.now(); let tx = await txBuilder.buildSync({ inputs: [{ utxo: utxo }], collaterals: [ utxo ], outputs: [ { address: scriptAddr, value: Value.lovelaces( 10_000_000 ), datum: VestingDatum.VestingDatum({ beneficiary: pBSToData.$( pByteString( pkh.toBuffer() ) ), deadline: pIntToData.$( nowPosix + 10_000 ) }) } ], changeAddress: address }); await tx.signWith( new PrivateKey(privateKey) ); const submittedTx = await Blockfrost.submitTx( tx ); console.log(submittedTx); }if( process.argv[1].includes(\"createVesting\") ){ createVesting(blockfrost());}\nimport { Address, Credential, Hash28, PrivateKey, Value, pBSToData, pByteString, pIntToData, CredentialType, PublicKey, Script, ScriptType } from \"@harmoniclabs/plu-ts\";import VestingDatum from \"../VestingDatum\";import getTxBuilder from \"./getTxBuilder\";import { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";import blockfrost from \"./blockfrost\";import { readFile } from \"fs/promises\";async function createVesting(Blockfrost: BlockfrostPluts){ const txBuilder = await getTxBuilder(Blockfrost); const scriptFile = await readFile(\"./testnet/vesting.plutus.json\", { encoding: \"utf-8\" }); const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3) const scriptAddr = new Address( \"testnet\", new Credential(CredentialType.Script, script.hash) ); const privateKeyFile = await readFile(\"./testnet/payment1.skey\", { encoding: \"utf-8\" }); const privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex ); const addr = await readFile(\"./testnet/address1.addr\", { encoding: \"utf-8\" }); const address = Address.fromString(addr); const publicKeyFile = await readFile(\"./testnet/payment2.vkey\", { encoding: \"utf-8\" }); const pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash; const utxos = await Blockfrost.addressUtxos( address ) .catch( e => { throw new Error (\"unable to find utxos at \" + addr) }) // atleast has 10 ada const utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000)!; if (!utxo) { throw new Error(\"No utxo with more than 10 ada\"); } const nowPosix = Date.now(); let tx = await txBuilder.buildSync({ inputs: [{ utxo: utxo }], collaterals: [ utxo ], outputs: [ { address: scriptAddr, value: Value.lovelaces( 10_000_000 ), datum: VestingDatum.VestingDatum({ beneficiary: pBSToData.$( pByteString( pkh.toBuffer() ) ), deadline: pIntToData.$( nowPosix + 10_000 ) }) } ], changeAddress: address }); await tx.signWith( new PrivateKey(privateKey) ); const submittedTx = await Blockfrost.submitTx( tx ); console.log(submittedTx); }if( process.argv[1].includes(\"createVesting\") ){ createVesting(blockfrost());}\nFor the ease of use, let's add a new npm script in package.json\nnpm script\n\"scripts\": { // ... \"vesting:create\": \"npm run build:light && node dist/app/createVesting.js\"}\n\"scripts\": { // ... \"vesting:create\": \"npm run build:light && node dist/app/createVesting.js\"}\nnow running\nnpm run vesting:create\nnpm run vesting:create\nwill generate a new UTxO for the smart contract ready to be spent!\nWe should also see a similar transaction hash in the console now.\n8b3deb9095898c4d1385269f0af00febaa547e4b4365978d073519caa52f791e\n8b3deb9095898c4d1385269f0af00febaa547e4b4365978d073519caa52f791e\nYou know the process now:\nThese are the steps needed before we can start to build the transaction and are often very similar.\nimport { Address, DataI, Credential, PrivateKey, CredentialType, Script, DataConstr, DataB, PublicKey, defaultPreprodGenesisInfos, ScriptType } from \"@harmoniclabs/plu-ts\";import getTxBuilder from \"./getTxBuilder\";import { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";import blockfrost from \"./blockfrost\";import { readFile } from \"fs/promises\";async function claimVesting(Blockfrost: BlockfrostPluts){ const txBuilder = await getTxBuilder(Blockfrost); const scriptFile = await readFile(\"./testnet/vesting.plutus.json\", { encoding: \"utf-8\" }); const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3) const scriptAddr = new Address( \"testnet\", new Credential(CredentialType.Script, script.hash) ); const privateKeyFile = await readFile(\"./testnet/payment2.skey\", { encoding: \"utf-8\" }); const privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex ); const addr = await readFile(\"./testnet/address2.addr\", { encoding: \"utf-8\" }); const address = Address.fromString(addr); const publicKeyFile = await readFile(\"./testnet/payment2.vkey\", { encoding: \"utf-8\" }); const pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash; const utxos = await Blockfrost.addressUtxos( address ) .catch( e => { throw new Error (\"unable to find utxos at \" + addr) }); // atleast has 10 ada const utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000); if (!utxo) { throw new Error(\"No utxo with more than 10 ada\"); } /// ...to be continued}\nimport { Address, DataI, Credential, PrivateKey, CredentialType, Script, DataConstr, DataB, PublicKey, defaultPreprodGenesisInfos, ScriptType } from \"@harmoniclabs/plu-ts\";import getTxBuilder from \"./getTxBuilder\";import { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";import blockfrost from \"./blockfrost\";import { readFile } from \"fs/promises\";async function claimVesting(Blockfrost: BlockfrostPluts){ const txBuilder = await getTxBuilder(Blockfrost); const scriptFile = await readFile(\"./testnet/vesting.plutus.json\", { encoding: \"utf-8\" }); const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3) const scriptAddr = new Address( \"testnet\", new Credential(CredentialType.Script, script.hash) ); const privateKeyFile = await readFile(\"./testnet/payment2.skey\", { encoding: \"utf-8\" }); const privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex ); const addr = await readFile(\"./testnet/address2.addr\", { encoding: \"utf-8\" }); const address = Address.fromString(addr); const publicKeyFile = await readFile(\"./testnet/payment2.vkey\", { encoding: \"utf-8\" }); const pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash; const utxos = await Blockfrost.addressUtxos( address ) .catch( e => { throw new Error (\"unable to find utxos at \" + addr) }); // atleast has 10 ada const utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000); if (!utxo) { throw new Error(\"No utxo with more than 10 ada\"); } /// ...to be continued}\nQuery the scriptUtxos, to specifically use the utxo that matches publicKeyHash within its datum.\nscriptUtxos\nutxo\npublicKeyHash\nconst scriptUtxos = await Blockfrost.addressUtxos( scriptAddr ) .catch( e => { throw new Error (\"unable to find utxos at \" + addr) }); // matches with the pkh const scriptUtxo = scriptUtxos.find(utxo => { if (utxo.resolved.datum instanceof DataConstr) { const pkhData = utxo.resolved.datum.fields[0]; if (pkhData instanceof DataB) { return pkh.toString() == Buffer.from( pkhData.bytes.toBuffer() ).toString(\"hex\") } } return false; }); if (!scriptUtxo) { throw new Error (\"No script utxo found for the pkh\") }\nconst scriptUtxos = await Blockfrost.addressUtxos( scriptAddr ) .catch( e => { throw new Error (\"unable to find utxos at \" + addr) }); // matches with the pkh const scriptUtxo = scriptUtxos.find(utxo => { if (utxo.resolved.datum instanceof DataConstr) { const pkhData = utxo.resolved.datum.fields[0]; if (pkhData instanceof DataB) { return pkh.toString() == Buffer.from( pkhData.bytes.toBuffer() ).toString(\"hex\") } } return false; }); if (!scriptUtxo) { throw new Error (\"No script utxo found for the pkh\") }\nNote that we are reading the keys (both private and public) of the beneficiary, we had set in the previous script, here.\nIf we used the other keys the script would fail each time!\nThis time our transaction will be formed as follows\nScript\nrequiredSigners\nctx.tx.signatories\ninvalidBefore\nOf the above, the last one sounds courious... How do we get the last slot of the blockchain?\nBlockfrost helps us with that!\nwe just have to do,\n(await Blockfrost.getChainTip()).slot!\n(await Blockfrost.getChainTip()).slot!\nBefore building the transaction, we have to ensure the txBuilder genesisInfo is set to its Preprod defaults, by:\ntxBuilder.setGenesisInfos( defaultPreprodGenesisInfos )\ntxBuilder.setGenesisInfos( defaultPreprodGenesisInfos )\nNow the Transaction can be built as follows:\nlet tx = await txBuilder.buildSync({ inputs: [ { utxo: utxo }, { utxo: scriptUtxo, inputScript: { script: script, datum: \"inline\", redeemer: new DataI( 0 ) } } ], requiredSigners: [ pkh ], // required to be included in script context collaterals: [ utxo ], changeAddress: address, invalidBefore: (await Blockfrost.getChainTip()).slot! });\nlet tx = await txBuilder.buildSync({ inputs: [ { utxo: utxo }, { utxo: scriptUtxo, inputScript: { script: script, datum: \"inline\", redeemer: new DataI( 0 ) } } ], requiredSigners: [ pkh ], // required to be included in script context collaterals: [ utxo ], changeAddress: address, invalidBefore: (await Blockfrost.getChainTip()).slot! });\nFinally, after we add the Sign and Submit code as done previously:\nawait tx.signWith( privateKey );const submittedTx = await Blockfrost.submitTx( tx )\nawait tx.signWith( privateKey );const submittedTx = await Blockfrost.submitTx( tx )\nwe can put all together in a claimVesting.ts file in the app folder:\nclaimVesting.ts\napp\nimport { Address, DataI, Credential, PrivateKey, CredentialType, Script, DataConstr, DataB, PublicKey, defaultPreprodGenesisInfos, ScriptType } from \"@harmoniclabs/plu-ts\";import getTxBuilder from \"./getTxBuilder\";import { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";import blockfrost from \"./blockfrost\";import { readFile } from \"fs/promises\";async function claimVesting(Blockfrost: BlockfrostPluts){ const txBuilder = await getTxBuilder(Blockfrost); const scriptFile = await readFile(\"./testnet/vesting.plutus.json\", { encoding: \"utf-8\" }); const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3) const scriptAddr = new Address( \"testnet\", new Credential(CredentialType.Script, script.hash) ); const privateKeyFile = await readFile(\"./testnet/payment2.skey\", { encoding: \"utf-8\" }); const privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex ); const addr = await readFile(\"./testnet/address2.addr\", { encoding: \"utf-8\" }); const address = Address.fromString(addr); const publicKeyFile = await readFile(\"./testnet/payment2.vkey\", { encoding: \"utf-8\" }); const pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash; const utxos = await Blockfrost.addressUtxos( address ) .catch( e => { throw new Error (\"unable to find utxos at \" + addr) }); // atleast has 10 ada const utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000); if (!utxo) { throw new Error(\"No utxo with more than 10 ada\"); } const scriptUtxos = await Blockfrost.addressUtxos( scriptAddr ) .catch( e => { throw new Error (\"unable to find utxos at \" + addr) }); // matches with the pkh const scriptUtxo = scriptUtxos.find(utxo => { if (utxo.resolved.datum instanceof DataConstr) { const pkhData = utxo.resolved.datum.fields[0]; if (pkhData instanceof DataB) { return pkh.toString() == Buffer.from( pkhData.bytes.toBuffer() ).toString(\"hex\") } } return false; }); if (!scriptUtxo) { throw new Error (\"No script utxo found for the pkh\") } txBuilder.setGenesisInfos( defaultPreprodGenesisInfos ) if (Buffer.from(script.hash.toBuffer()).toString(\"hex\") !== Buffer.from(scriptAddr.paymentCreds.hash.toBuffer()).toString(\"hex\")) { throw new Error(\"Script hash and script address hash do not match\"); } let tx = await txBuilder.buildSync({ inputs: [ { utxo: utxo }, { utxo: scriptUtxo, inputScript: { script: script, datum: \"inline\", redeemer: new DataI( 0 ) } } ], requiredSigners: [ pkh ], // required to be included in script context collaterals: [ utxo ], changeAddress: address, invalidBefore: (await Blockfrost.getChainTip()).slot! }); await tx.signWith( privateKey ) const submittedTx = await Blockfrost.submitTx( tx ); console.log(submittedTx); }if( process.argv[1].includes(\"claimVesting\") ){ claimVesting(blockfrost());}\nimport { Address, DataI, Credential, PrivateKey, CredentialType, Script, DataConstr, DataB, PublicKey, defaultPreprodGenesisInfos, ScriptType } from \"@harmoniclabs/plu-ts\";import getTxBuilder from \"./getTxBuilder\";import { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";import blockfrost from \"./blockfrost\";import { readFile } from \"fs/promises\";async function claimVesting(Blockfrost: BlockfrostPluts){ const txBuilder = await getTxBuilder(Blockfrost); const scriptFile = await readFile(\"./testnet/vesting.plutus.json\", { encoding: \"utf-8\" }); const script = Script.fromCbor(JSON.parse(scriptFile).cborHex, ScriptType.PlutusV3) const scriptAddr = new Address( \"testnet\", new Credential(CredentialType.Script, script.hash) ); const privateKeyFile = await readFile(\"./testnet/payment2.skey\", { encoding: \"utf-8\" }); const privateKey = PrivateKey.fromCbor( JSON.parse(privateKeyFile).cborHex ); const addr = await readFile(\"./testnet/address2.addr\", { encoding: \"utf-8\" }); const address = Address.fromString(addr); const publicKeyFile = await readFile(\"./testnet/payment2.vkey\", { encoding: \"utf-8\" }); const pkh = PublicKey.fromCbor( JSON.parse(publicKeyFile).cborHex ).hash; const utxos = await Blockfrost.addressUtxos( address ) .catch( e => { throw new Error (\"unable to find utxos at \" + addr) }); // atleast has 10 ada const utxo = utxos.find(utxo => utxo.resolved.value.lovelaces >= 15_000_000); if (!utxo) { throw new Error(\"No utxo with more than 10 ada\"); } const scriptUtxos = await Blockfrost.addressUtxos( scriptAddr ) .catch( e => { throw new Error (\"unable to find utxos at \" + addr) }); // matches with the pkh const scriptUtxo = scriptUtxos.find(utxo => { if (utxo.resolved.datum instanceof DataConstr) { const pkhData = utxo.resolved.datum.fields[0]; if (pkhData instanceof DataB) { return pkh.toString() == Buffer.from( pkhData.bytes.toBuffer() ).toString(\"hex\") } } return false; }); if (!scriptUtxo) { throw new Error (\"No script utxo found for the pkh\") } txBuilder.setGenesisInfos( defaultPreprodGenesisInfos ) if (Buffer.from(script.hash.toBuffer()).toString(\"hex\") !== Buffer.from(scriptAddr.paymentCreds.hash.toBuffer()).toString(\"hex\")) { throw new Error(\"Script hash and script address hash do not match\"); } let tx = await txBuilder.buildSync({ inputs: [ { utxo: utxo }, { utxo: scriptUtxo, inputScript: { script: script, datum: \"inline\", redeemer: new DataI( 0 ) } } ], requiredSigners: [ pkh ], // required to be included in script context collaterals: [ utxo ], changeAddress: address, invalidBefore: (await Blockfrost.getChainTip()).slot! }); await tx.signWith( privateKey ) const submittedTx = await Blockfrost.submitTx( tx ); console.log(submittedTx); }if( process.argv[1].includes(\"claimVesting\") ){ claimVesting(blockfrost());}\nAfter adding a new npm script in package.json\nnpm script\n\"scripts\": { // ... \"vesting:claim\": \"npm run build:light && node dist/app/claimVesting.js\"}\n\"scripts\": { // ... \"vesting:claim\": \"npm run build:light && node dist/app/claimVesting.js\"}\nto try claim the UTxO, we can run:\nnpm run vesting:claim\nnpm run vesting:claim\nIf you run the script shortly after you created and locked the UTxO the script will fail!\nIn the previous script, we had set a locking period of 10 seconds.\nSo you just have to have a little patience :)\nIf everything goes correctly, the program should terminate without errors. It will definitely console back the transaction hash in the terminal.\nIf you were in public testnet remember to return the tADA to the faucet.\nFor this, you can add the following file and script to automate everything.\nimport { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";import { Address, ITxBuildInput, IUTxO, PrivateKey } from \"@harmoniclabs/plu-ts\";import { readFile } from \"fs/promises\";import blockfrost from \"./blockfrost\";import getTxBuilder from \"./getTxBuilder\";async function returnFaucet(Blockfrost: BlockfrostPluts){ const utxos: (ITxBuildInput | IUTxO)[] = []; const pvtKeys: PrivateKey[] = []; for( let i = 1; i <= 2; i++ ) { const pvtKeyFile = await readFile(`./testnet/payment${i}.skey`, { encoding: \"utf-8\" }) const pvtKey = PrivateKey.fromCbor( JSON.parse(pvtKeyFile).cborHex ); pvtKeys.push( pvtKey ); const addr = await readFile(`./testnet/address${i}.addr`, { encoding: \"utf-8\" }); const address = Address.fromString(addr); const addrUtxos = await Blockfrost.addressUtxos( address ) addrUtxos.forEach( utxo => utxos.push({ utxo: utxo }) ) } const txBuilder = await getTxBuilder(Blockfrost); let returnTADATx = await txBuilder.buildSync({ inputs: utxos as any, // the faucet address changeAddress: \"addr_test1qqr585tvlc7ylnqvz8pyqwauzrdu0mxag3m7q56grgmgu7sxu2hyfhlkwuxupa9d5085eunq2qywy7hvmvej456flknswgndm3\" }); for(const privateKey of pvtKeys) { await returnTADATx.signWith( privateKey ); } const submittedTx = await Blockfrost.submitTx( returnTADATx ); console.log(submittedTx);}if( process.argv[1].includes(\"returnFaucet\") ){ returnFaucet(blockfrost());}\nimport { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";import { Address, ITxBuildInput, IUTxO, PrivateKey } from \"@harmoniclabs/plu-ts\";import { readFile } from \"fs/promises\";import blockfrost from \"./blockfrost\";import getTxBuilder from \"./getTxBuilder\";async function returnFaucet(Blockfrost: BlockfrostPluts){ const utxos: (ITxBuildInput | IUTxO)[] = []; const pvtKeys: PrivateKey[] = []; for( let i = 1; i <= 2; i++ ) { const pvtKeyFile = await readFile(`./testnet/payment${i}.skey`, { encoding: \"utf-8\" }) const pvtKey = PrivateKey.fromCbor( JSON.parse(pvtKeyFile).cborHex ); pvtKeys.push( pvtKey ); const addr = await readFile(`./testnet/address${i}.addr`, { encoding: \"utf-8\" }); const address = Address.fromString(addr); const addrUtxos = await Blockfrost.addressUtxos( address ) addrUtxos.forEach( utxo => utxos.push({ utxo: utxo }) ) } const txBuilder = await getTxBuilder(Blockfrost); let returnTADATx = await txBuilder.buildSync({ inputs: utxos as any, // the faucet address changeAddress: \"addr_test1qqr585tvlc7ylnqvz8pyqwauzrdu0mxag3m7q56grgmgu7sxu2hyfhlkwuxupa9d5085eunq2qywy7hvmvej456flknswgndm3\" }); for(const privateKey of pvtKeys) { await returnTADATx.signWith( privateKey ); } const submittedTx = await Blockfrost.submitTx( returnTADATx ); console.log(submittedTx);}"
  },
  {
    "prompt": "Minting policy?",
    "completion": "Now we can continue with a simple minting policy example.\nThe final result can be found at HarmonicLabs/simple-minting-pluts.\nHarmonicLabs/simple-minting-pluts\nWe will start from the simple-minting-pluts example:\nsimple-minting-pluts\ngit clone https://github.com/HarmonicLabs/simple-minting-pluts.gitcd simple-minting-plutsgit remote remove origin\ngit clone https://github.com/HarmonicLabs/simple-minting-pluts.gitcd simple-minting-plutsgit remote remove origin\nThis gives us a simple project structure:\n./simple-minting-plutsâ”œâ”€â”€ contractsâ”‚ â””â”€â”€ minting.tsâ”œâ”€â”€ next.config.jsâ”œâ”€â”€ next-env.d.tsâ”œâ”€â”€ package.jsonâ”œâ”€â”€ package-lock.jsonâ”œâ”€â”€ srcâ”‚ â”œâ”€â”€ componentsâ”‚ â”‚ â””â”€â”€ ConnectionHandler.tsxâ”‚ â”œâ”€â”€ offchainâ”‚ â”‚ â”œâ”€â”€ getTxBuilder.tsâ”‚ â”‚ â”œâ”€â”€ mesh-utils.tsâ”‚ â”‚ â””â”€â”€ mintNft.tsâ”‚ â”œâ”€â”€ pagesâ”‚ â”‚ â”œâ”€â”€ _app.tsxâ”‚ â”‚ â”œâ”€â”€ _document.tsxâ”‚ â”‚ â””â”€â”€ index.tsxâ”‚ â””â”€â”€ stylesâ”‚ â”œâ”€â”€ globals.cssâ”‚ â””â”€â”€ Home.module.cssâ””â”€â”€ tsconfig.json\n./simple-minting-plutsâ”œâ”€â”€ contractsâ”‚ â””â”€â”€ minting.tsâ”œâ”€â”€ next.config.jsâ”œâ”€â”€ next-env.d.tsâ”œâ”€â”€ package.jsonâ”œâ”€â”€ package-lock.jsonâ”œâ”€â”€ srcâ”‚ â”œâ”€â”€ componentsâ”‚ â”‚ â””â”€â”€ ConnectionHandler.tsxâ”‚ â”œâ”€â”€ offchainâ”‚ â”‚ â”œâ”€â”€ getTxBuilder.tsâ”‚ â”‚ â”œâ”€â”€ mesh-utils.tsâ”‚ â”‚ â””â”€â”€ mintNft.tsâ”‚ â”œâ”€â”€ pagesâ”‚ â”‚ â”œâ”€â”€ _app.tsxâ”‚ â”‚ â”œâ”€â”€ _document.tsxâ”‚ â”‚ â””â”€â”€ index.tsxâ”‚ â””â”€â”€ stylesâ”‚ â”œâ”€â”€ globals.cssâ”‚ â””â”€â”€ Home.module.cssâ””â”€â”€ tsconfig.json\nJust like the Hello plu-ts example; this project already comes with plu-ts as dependecy; all we need to do to then is to run\nnpm install\nnpm install\nFrom the project structure we see that the code can be found in the src folder and the contracts folder.\nsrc\ncontracts\nThe contracts only file is the minting.ts one; which always success and exports the compiled result.\ncontracts\nminting.ts\nimport { Address, PScriptContext, ScriptType, Credential, Script, compile, pfn, unit, passert } from \"@harmoniclabs/plu-ts\";const contract = pfn([ PScriptContext.type], unit)(({ redeemer, tx, purpose }) => { return passert.$(true);});export const compiledContract = compile(contract);export const script = new Script( ScriptType.PlutusV3, compiledContract);export const scriptTestnetAddr = new Address( \"testnet\", Credential.script(script.hash));\nimport { Address, PScriptContext, ScriptType, Credential, Script, compile, pfn, unit, passert } from \"@harmoniclabs/plu-ts\";const contract = pfn([ PScriptContext.type], unit)(({ redeemer, tx, purpose }) => { return passert.$(true);});export const compiledContract = compile(contract);export const script = new Script( ScriptType.PlutusV3, compiledContract);export const scriptTestnetAddr = new Address( \"testnet\", Credential.script(script.hash));\nThe other file is the offchain/mintNft.ts, which includes the logic for building and executing the transaction for the NFT minting.\noffchain/mintNft.ts\nimport { BrowserWallet } from \"@meshsdk/core\";import { Value, Address } from \"@harmoniclabs/plu-ts\";import { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";import { scriptTestnetAddr, script } from \"../../contracts/minting\";import { toPlutsUtxo } from \"./mesh-utils\";import getTxBuilder from \"./getTxBuilder\";export async function mintNft(wallet: BrowserWallet, projectId: string): Promise<string> { const recipient = Address.fromString( await wallet.getChangeAddress() ); const Blockfrost = new BlockfrostPluts({ projectId }); const txBuilder = await getTxBuilder(Blockfrost); const myUTxOs = (await wallet.getUtxos()).map(toPlutsUtxo); if (myUTxOs.length === 0) { throw new Error(\"have you requested founds from the faucet?\"); } const utxo = myUTxOs.find(u => u.resolved.value.lovelaces > 15_000_000); if (utxo === undefined) { throw new Error(\"not enough ada\"); } const unsignedTx = await txBuilder.buildSync({ inputs: [{ utxo }], changeAddress: recipient, collaterals: [utxo], // We need to declare a collateral return in order // to store the minted token in the user wallet collateralReturn: { address: utxo.resolved.address, value: Value.sub(utxo.resolved.value, Value.lovelaces(5_000_000)) }, // We need to declare the minting policy for the token mints: [{ // This is the name and amount of tokens we want to mint value: Value.singleAsset( scriptTestnetAddr.paymentCreds.hash, Buffer.from('Test Token'), 1 ), // We pass the script as inline and the redeemer address script: { inline: script, policyId: scriptTestnetAddr.paymentCreds.hash, redeemer: recipient.toData() } }] }); const txStr = await wallet.signTx(unsignedTx.toCbor().toString()); return await Blockfrost.submitTx(txStr);}\nimport { BrowserWallet } from \"@meshsdk/core\";import { Value, Address } from \"@harmoniclabs/plu-ts\";import { BlockfrostPluts } from \"@harmoniclabs/blockfrost-pluts\";import { scriptTestnetAddr, script } from \"../../contracts/minting\";import { toPlutsUtxo } from \"./mesh-utils\";import getTxBuilder from \"./getTxBuilder\";export async function mintNft(wallet: BrowserWallet, projectId: string): Promise<string> { const recipient = Address.fromString( await wallet.getChangeAddress() ); const Blockfrost = new BlockfrostPluts({ projectId }); const txBuilder = await getTxBuilder(Blockfrost); const myUTxOs = (await wallet.getUtxos()).map(toPlutsUtxo); if (myUTxOs.length === 0) { throw new Error(\"have you requested founds from the faucet?\"); } const utxo = myUTxOs.find(u => u.resolved.value.lovelaces > 15_000_000); if (utxo === undefined) { throw new Error(\"not enough ada\"); } const unsignedTx = await txBuilder.buildSync({ inputs: [{ utxo }], changeAddress: recipient, collaterals: [utxo], // We need to declare a collateral return in order // to store the minted token in the user wallet collateralReturn: { address: utxo.resolved.address, value: Value.sub(utxo.resolved.value, Value.lovelaces(5_000_000)) }, // We need to declare the minting policy for the token mints: [{ // This is the name and amount of tokens we want to mint value: Value.singleAsset( scriptTestnetAddr.paymentCreds.hash, Buffer.from('Test Token'), 1 ), // We pass the script as inline and the redeemer address script: { inline: script, policyId: scriptTestnetAddr.paymentCreds.hash, redeemer: recipient.toData() } }] }); const txStr = await wallet.signTx(unsignedTx.toCbor().toString()); return await Blockfrost.submitTx(txStr);}\nTo test it out run\nnpm run dev\nnpm run dev\nAnd navigate to the specified url (eg. http://localhost:3000/);\nhttp://localhost:3000/\nThen connect your wallet.\nAnd click on the Mint NFT button.\nMint NFT\nIf everything works correctly you should be prompted to sign a transaction."
  },
  {
    "prompt": "Concepts?",
    "completion": "plu-ts is a strongly typed eDSL for generating Cardano Smart Contracts.\nplu-ts\nIn order to allow the creation of efficient smart contracts, plu-ts is functional, allowing more control over the compiled result.\nplu-ts\nAs a consequence of the functional nature of the language, everything in plu-ts is an expression.\nplu-ts\neDSL stands for embedded Domain Specific Language.\nembedded Domain Specific Language\nWhat it means can be explained by analyzing the definition:\nLanguage\nDomain Specific\nplu-ts\nembedded\nplu-ts\nWhen writing plu-ts code it is important to distinguish what parts of the code are native to Typescript and what parts are plu-ts.\nplu-ts\nplu-ts\nSince Typescript is the host language, Typescript will be our starting point for learning about plu-ts.\nplu-ts"
  },
  {
    "prompt": "Types?",
    "completion": "As we saw in Concepts plu-ts is an eDSL embedded in Typescript, as such we have two type systems; the Typescript one and the plu-ts one\nplu-ts\nplu-ts\nTerm\nplu-ts\nplu-ts\nTerm\nTerm\nThe possible types a Term can keep track of are defined in PTypes, and listed here:\nTerm\nPUnit\nplu-ts\nundefined\nnull\nPInt\nPBool\nPByteString\nBuffer\nUint8Array\nPString\nstring\nPData\nobject\nPStruct\nPData\nPList<PType>\nPType\nPPair<PType1, PType2>\n[ type1 , type2 ]\nPDelayed<PType>\nPType\npforce\nPLam<PInput, POutput>\nPInput\nPOutput\nPFn<[ PInput_0 , ...PType[] ],POutput>\nPOutput\nPAlias<PType>\nPAlias<PInt>\nPInt\nPStruct<{...}>\nPData\nPSop<{...}>\nPStruct\nplu-ts\nplu-ts would not be a strongly typed language if limited to Typescript types, because the types of Typescript are only useful during compilation to javascript; and then everything is untyped!\nplu-ts\nTypescript can be compiled to Javascript. When this happens, the resulting Javascript is untyped!\nFor this reason plu-ts implements its own type through some constants and functions that can be imported.\nplu-ts\nIn the same order of above, the plu-ts equivalents are:\nplu-ts\nPUnit\nunit\nPInt\nint\nPBool\nbool\nPByteString\nbs\nPString\nstr\nPData\ndata\nPList\nlist( type )\nPPair\npair( type1, type2 )\nPDelayed\ndelayed( type )\nPLam\nlam( from, to )\nPFn\nfn([ ...inputs ], output )\ntype\nplu-ts\nAs we know, Typescript gives us the possibility to define polymorphic types trough generics.\nIn a way you could see generics as functions that take a type as input and returns another type.\nFortunately for us, plu-ts types are just values when seen from the Typescript world, so we can have some sort of generic in plu-ts too!\nplu-ts\nplu-ts\nTo see how, let's try to define the previous polymorphic types using the generic method:\nconst anyPlutsFunction = ( a: TermType, b: TermType ) => lam( a, b );const identityFunctionType = ( a: TermType ) => lam( a, a );const mkPairType = ( a: TermType, b: TermType ) => fn([ a, b ], pair( a, b ) )\nconst anyPlutsFunction = ( a: TermType, b: TermType ) => lam( a, b );const identityFunctionType = ( a: TermType ) => lam( a, a );const mkPairType = ( a: TermType, b: TermType ) => fn([ a, b ], pair( a, b ) )\nPolymorphic types defined as functions also have the advantage of being fully defined once the type arguments are passed.\nThis works great, but there's still a problem though... Typescript isn't able to infer these types!\nThis is because TermType is the generic type for all plu-ts types, so when Typescript tries to infer the type of the term, it sees the most generic type of all, and once again thinks we want to use the anonymous PType.\nTermType\nplu-ts\nPType\nTo finally solve this problem we need to make the functions generic too:\nfunction anyFunction<A extends TermType, B extends TermType>( a: A, b: B ){ return lam( a, b ) };function identityFunctionType<A extends TermType>( a: A ){ return lam( a, a ) };function mkPairType<A extends TermType, B extends TermType>( a: A, b: B ){ return fn([ a, b ], pair( a, b ) ) };\nfunction anyFunction<A extends TermType, B extends TermType>( a: A, b: B ){ return lam( a, b ) };function identityFunctionType<A extends TermType>( a: A ){ return lam( a, a ) };function mkPairType<A extends TermType, B extends TermType>( a: A, b: B ){ return fn([ a, b ], pair( a, b ) ) };\nThis way Typescript first infers the specific TermType we are passing, and with that is able to determine the exact type of the Term.\nTermType\nGenerics will turn useful especially in the case where the type requires a type variable as return type, a notable example is pif which is of type bool - a - a - a.\npif\nbool -> a -> a -> a\nplu-ts\nplu-ts"
  },
  {
    "prompt": "Values?",
    "completion": "For most of the types described there is a function to transform the Typescript version to the plu-ts equivalent.\n4 items\nThe pAlias function allows you to create a new type alias that inherits all the properties and methods of an existing type, while also providing the flexibility to define custom methods specific to the alias.\n2 items\nLike in the case of papp that is meant to work with a plu-ts function as the first argument, there are functions that are meant to work with specific types."
  },
  {
    "prompt": "Control Flow?",
    "completion": "Every programming language that wants to be turing complete has to include some sort of way to: (1) execute code conditionally and (2) repeat specific parts of the code. To satisfy those requirements, plu-ts implements the following\nAs a solution to conditional code execution plu-ts exposes an if then else construct.\nWhen we had our first look at the structs, we hinted at the possibility of custom control flows.\nThe other thing we are missing to have a proper language is some way to repeat the execution of some code."
  },
  {
    "prompt": "Evaluation and testing?",
    "completion": "plu-ts implements its own version of the CEK machine for the UPLC language. This allows any plu-ts term to be compiled to an UPLC Term and evaluated."
  },
  {
    "prompt": "Optimizations?",
    "completion": "Up until this part of the documentation we wrote plu-ts code that didn't need to re-use values, but in a real case scenario that is quite common.\nAnother great tool for optimizations is phoist and all hoisted terms.\nplet and phoist are the two main tools to use when focusing on optimizations;"
  },
  {
    "prompt": "stdlib?",
    "completion": "type definition:\ntype definition:\ntype definition:\ntype definition:\ntype definition:\ntype definition:\nThe type definition of TermFn is more complex than what it actually does; but that is only because it automatically handles functions with an unspecified (potentially infinite) number of parameters.\nTermStruct is an other type that is unnecessarily complicated."
  },
  {
    "prompt": "API?",
    "completion": "Smart contracts have to use a standard API to be sure the cardano-node evaluates them correctly; this section defines and exports all the necessary to make sure the standard is respected\n3 items\n3 items"
  },
  {
    "prompt": "TxBuilder API?",
    "completion": "\"TxBuilder\" API\nplu-ts/offchain exposes the TxBuilder class.\nITxBuildArgs\nmethod definition\n- requestedOutputSet: Value | 'ValueUnits',\n- tx: Tx\n- tx_out: TxOut\n- geneisInfos: GenesisInfos\n- slot: number | bigint\n- POSIX: number | bigint\n- tx: Tx"
  },
  {
    "prompt": "TxBuilderRunner API?",
    "completion": "\"TxBuilderRunner\" API\nThe TxBuilderRunner is an abstraction over the TxBuilder.\nITxRunnerProvider\nif any unresolved data was passed it is resolved via the provider passed;\nclears the TxBuilderRunner instance,\n- signer: Address |\n- signer: Hash28\n- validator: Script\n- label: number | bigint;\n- label: number | bigint;\n- label: number | bigint;\n- changeAddr: Address | AddressStr\n- collateral: CanResolveToUTxO\n- lovelaces: number | bigint\n- utxos: CanResolveToUTxO\\[\\]\n- utxutxoos: CanResolveToUTxO\n- address: Address | AddressStr,\n- delegator: CanBeStakeCreds\n- delegator: CanBeStakeCreds\n- assets: IValuePolicyEntry\nadds the utxos to the refInputs\n- POSIX: bigint | number (POSIX time with millisecond precision)\n- slot: bigint | number (POSIX time with millisecond precision)\n- slot: bigint | number (POSIX time with millisecond precision)\n- POSIX: bigint | number (POSIX time with millisecond precision)\n- slot: bigint | number (POSIX time with millisecond precision)\n- slot: bigint | number (POSIX time with millisecond precision)\n- stakeAddress: CanBeStakeCreds,"
  },
  {
    "prompt": "cardanoledgerts?",
    "completion": "\"cardano-ledger-ts\" API\n@harmoniclabs/cardano-ledger-ts Docs\n78 items\n11 items\n116 items\n@harmoniclabs/cardano-ledger-ts Docs\n70 items\n57 items\n1 items"
  },
  {
    "prompt": "plutusdata?",
    "completion": "\"plutus-data\" API\n@harmoniclabs/plutus-data Readme \\| API\n6 items\n12 items\n@harmoniclabs/plutus-data Readme \\| API\n1 items\n1 items"
  },
  {
    "prompt": "miscellaneous?",
    "completion": "other definitions present in plu-ts-offchain\ntype definition\neither:\neither:\ntype definition\ntype definition"
  },
  {
    "prompt": "makeRedeemerValidator?",
    "completion": "makeRedeemerValidator\nThis method is deprecated as of Plutus V3\nAs said in [makeValidator], once on-chain contracts are not typed.\nmakeValidator\nmakeRedeemerValidator is used for contract that do not expect a datum as first argument.\nmakeRedeemerValidator\nThe type signature is:\nexport function makeRedeemerValidator( typedValidator: Term< PLam< PType, PLam< typeof PScriptContext, PBool > > >, errorMessage?: string): TermFn<[PData,PData], PUnit>\nexport function makeRedeemerValidator( typedValidator: Term< PLam< PType, PLam< typeof PScriptContext, PBool > > >, errorMessage?: string): TermFn<[PData,PData], PUnit>\nAs you can see it takes any typed validator and returns a generic untyped validator so that the node will be able to evaluate it correctly.\nOptionally you can pass a string that will be included in the on-chain script and passed to ptrace in case of failure\nstring\nptrace"
  },
  {
    "prompt": "cardanoclipluts?",
    "completion": "cardanocli-pluts\ncardanocli-pluts is a library that wraps cardano-cli using Typescript allowing you to interact with the cli using the Types exposed by plu-ts\ncardanocli-pluts\nplu-ts\ncardano-node >= 1.29.0\nnode.js >= 12.19.0\nplu-ts >= 0.2.0\nimport { CardanoCliPluts } from \"@harmoniclabs/cardanocli-pluts\"import { Value } from \"@harmoniclabs/plu-ts\"const cli = new CardanoCliPluts({ network: \"testnet 42\"});async function main(){ // read a saved address from file const bobAddr = await cli.utils.readAddress( \"./addresses/bob.addr\" ); // or make a new addres using the cli const { privateKey, publicKey } = await cli.address.keyGen(); const myAddr = await cli.address.build({ payment: { publicKey } }); // query the UTxOs at myAddr const myUtxos = await cli.query.utxo({ address: myAddr }); // send some ada to bob const tx = await cli.transaction.build({ inputs: [{ utxo: myUtxos[0] }], outpus: [ { address: bobAddr, value: Value.lovelaces(2_000_000) } ], changeAddress: myAddr }); const txSigned = await cli.transaction.sign({ tx, privateKey }); // let's check everything is ok before submission console.log( JSON.stringify( txSigned.toJson(), undefined, 2 ) ); // send the transaction cli.transaction.submit({ tx: txSigned })}main()\nimport { CardanoCliPluts } from \"@harmoniclabs/cardanocli-pluts\"import { Value } from \"@harmoniclabs/plu-ts\"const cli = new CardanoCliPluts({ network: \"testnet 42\"});async function main(){ // read a saved address from file const bobAddr = await cli.utils.readAddress( \"./addresses/bob.addr\" ); // or make a new addres using the cli const { privateKey, publicKey } = await cli.address.keyGen(); const myAddr = await cli.address.build({ payment: { publicKey } }); // query the UTxOs at myAddr const myUtxos = await cli.query.utxo({ address: myAddr }); // send some ada to bob const tx = await cli.transaction.build({ inputs: [{ utxo: myUtxos[0] }], outpus: [ { address: bobAddr, value: Value.lovelaces(2_000_000) } ], changeAddress: myAddr }); const txSigned = await cli.transaction.sign({ tx, privateKey }); // let's check everything is ok before submission console.log( JSON.stringify( txSigned.toJson(), undefined, 2 ) ); // send the transaction cli.transaction.submit({ tx: txSigned })}main()"
  },
  {
    "prompt": "koiospluts?",
    "completion": "koios-pluts"
  },
  {
    "prompt": "blockfrostpluts?",
    "completion": "blockfrost-pluts"
  },
  {
    "prompt": "GenesisInfos?",
    "completion": "GenesisInfos\ninterface GenesisInfos { /** * ### POSIX timestamp of blockchain start * ## with **milliseconds precision** **/ readonly systemStartPOSIX: CanBeUInteger, /** * ### slot duration in **milliseconds** **/ readonly slotLengthInMilliseconds: CanBeUInteger}\ninterface GenesisInfos { /** * ### POSIX timestamp of blockchain start * ## with **milliseconds precision** **/ readonly systemStartPOSIX: CanBeUInteger, /** * ### slot duration in **milliseconds** **/ readonly slotLengthInMilliseconds: CanBeUInteger}\nGenesis informations usually required to convert slots to POSIX timestamps and vice versa.\ndefaultPreviewGenesisInfos\nconst defaultPreviewGenesisInfos: GenesisInfos = Object.freeze({ systemStartPOSIX: 1666656000_000, slotLengthInMilliseconds: 1000} as GenesisInfos);\nconst defaultPreviewGenesisInfos: GenesisInfos = Object.freeze({ systemStartPOSIX: 1666656000_000, slotLengthInMilliseconds: 1000} as GenesisInfos);\ndefaultPreprodGenesisInfos\nexport const defaultPreprodGenesisInfos: GenesisInfos = Object.freeze({ systemStartPOSIX: 1666656000_000, slotLengthInMilliseconds: 1000} as GenesisInfos);\nexport const defaultPreprodGenesisInfos: GenesisInfos = Object.freeze({ systemStartPOSIX: 1666656000_000, slotLengthInMilliseconds: 1000} as GenesisInfos);\ndefaultMainnetGenesisInfos\nexport const defaultMainnetGenesisInfos: GenesisInfos = Object.freeze({ systemStartPOSIX: 1506203091_000, slotLengthInMilliseconds: 1000} as GenesisInfos);\nexport const defaultMainnetGenesisInfos: GenesisInfos = Object.freeze({ systemStartPOSIX: 1506203091_000, slotLengthInMilliseconds: 1000} as GenesisInfos);\nisGenesisInfos\ntype declaraition:\nfunction isGenesisInfos( stuff: any ): stuff is GenesisInfos\nfunction isGenesisInfos( stuff: any ): stuff is GenesisInfos\ndefaultPreviewGenesisInfos\ndefaultPreprodGenesisInfos\ndefaultMainnetGenesisInfos\nisGenesisInfos"
  },
  {
    "prompt": "Struct definition?",
    "completion": "When writing programs we often need to access data that is more articulate than simple integers or booleans. For this reason plu-ts allows you to define custom data-types.\nplu-ts\npstruct\nTo define your own type all you need is the pstruct typescript function.\npstruct\npstruct takes as an argument an object that describes the structure of the new data-type and returns a Typescript class that represents our new type. You can also add custom methods to this structure, to make it more versatile.\npstruct\nThe type of a struct definition (which is the argument of pstruct) is something like:\npstruct\ntype StructDefiniton = { [constructor: string]: { [field: string]: TermType }};\ntype StructDefiniton = { [constructor: string]: { [field: string]: TermType }};\nFrom this type we can already see that a struct can have multiple constructors (at least one) and each constructor can have 0 or more named fields.\nThis characteristic of having multiple constructors will allow for the creation of custom control flows through the use of pmatch described in its own section.\npmatch\nFor now let's focus on defining some new structs and say we wanted to define a datatype that describes a Dog.\nWe could do so by writing:\n// structs with single constructors acts in a similar way of plain typescript objectconst Dog = pstruct({ // single constructor Dog: { name: str, age: Age.type }});\n// structs with single constructors acts in a similar way of plain typescript objectconst Dog = pstruct({ // single constructor Dog: { name: str, age: Age.type }});\nBut our dog needs some toys to play with when we are out. So we define a structure that describes some toys:\nconst Toy = pstruct({ Stick: {}, Ball: { size: int, isSoft: bool }, Mailman: { name: str, age: Age.type }})\nconst Toy = pstruct({ Stick: {}, Ball: { size: int, isSoft: bool }, Mailman: { name: str, age: Age.type }})\nSo now we can add a new field to better describe our dog:\nconst Dog = pstruct({ Dog: { name: str, age: Age.type, favouriteToy: Toy.type }});\nconst Dog = pstruct({ Dog: { name: str, age: Age.type, favouriteToy: Toy.type }});\nWhen defining a struct the order of the constructors and the order of the fields matters.\nIn fact at UPLC level there are no names.\nThis does have two important implications:\nDog\nconst Kid = pstruct({ Kid: { name: str, age: Age.type, toy: Toy.type }});\nconst Kid = pstruct({ Kid: { name: str, age: Age.type, toy: Toy.type }});\nTo build a plu-ts value that represents a struct you just use one of the constructors you defined.\nplu-ts\nSo if you where to create an instance of a Dog you'd just write:\nDog\nconst myDog = Dog.Dog({ name: pStr(\"Pluto\"), age: Age.from( pInt(3) ), favouriteToy: Toy.Mailman({ name: pStr(\"Bob\"), age: Age.from( pInt(42) ) })})\nconst myDog = Dog.Dog({ name: pStr(\"Pluto\"), age: Age.from( pInt(3) ), favouriteToy: Toy.Mailman({ name: pStr(\"Bob\"), age: Age.from( pInt(42) ) })})\nplu-ts\nLike aliases, structs also do have custom plu-ts types; which can be accessed using the type static property\nplu-ts\ntype\nconst typeOfToy = Toy.type;\nconst typeOfToy = Toy.type;\npstruct\nplu-ts"
  },
  {
    "prompt": "makeValidator?",
    "completion": "makeValidator\nThis method is deprecated as of Plutus V3\nOnce on-chain contracts are not typed. Instead they only receive generic data arguments.\ndata\nThis is why makeValidator exists.\nmakeValidator\nThe type signature is not too complicated:\nexport function makeValidator( typedValidator: Term< PLam< PType, PLam< PType, PLam< typeof PScriptContext, PBool > > > >, errorMessage?: string): TermFn<[PData,PData,PData], PUnit>\nexport function makeValidator( typedValidator: Term< PLam< PType, PLam< PType, PLam< typeof PScriptContext, PBool > > > >, errorMessage?: string): TermFn<[PData,PData,PData], PUnit>\nAs you can see it takes any typed validator and returns a generic untyped validator so that the node will be able to evaluate it correctly.\nmakeValidator\nAs you can see; makeValidator expects a contract with 3 arguments.\nmakeValidator\nThis means it can only be used for contracts with Spending as PScriptPurpose\nSpending\nPScriptPurpose\nFor all other purposes you likely want to use makeRedeemerValidator\nmakeRedeemerValidator\nOptionally you can pass a string that will be included in the on-chain script and passed to ptrace in case of failure\nstring\nptrace"
  },
  {
    "prompt": "compile?",
    "completion": "compile\nOnce we have our contract we need to transform it in something that the cardano node understands.\nFor that we have the compile function.\ncompile\nfunction compile( term: Term<PType>, version?: [number, number, number]): Uint8Array;\nfunction compile( term: Term<PType>, version?: [number, number, number]): Uint8Array;\ncompile takes any Term as input and returns an Uint8Array that are the flat serialization of the Term.\ncompile\nUint8Array\nflat\nIt optionally takes a tuple of 3 numbers (expected to be all positive integer) representing the contract version.\nnumber\nThe version defaults to [ 1, 0, 0 ] and is unlikely you will ever need to specify it.\n[ 1, 0, 0 ]\nflat\nThe flat format is how the contract is stored on chain.\nflat\nHowever is not the format is not how it is include in a transaction (nor how it is used by cardano-cli)\ncardano-cli\nTo use the result of compile you should pass it to a Script constructor so that it can handle the format for you.\ncompile\nScript"
  },
  {
    "prompt": "Aliases?",
    "completion": "The pAlias function allows you to create a new type alias that inherits all the properties and methods of an existing type, while also providing the flexibility to define custom methods specific to the alias. This is particularly useful when you want to create a type that behaves like an existing type but has additional functionality or a more descriptive name.\nIn some cases it might be useful to define aliases for already existing types.\nIn the current implementation, aliases do not really have any specific advantage other than making your code more expressive. Currently, aliases can be used everywhere the aliased type is accepted and vice-versa.\nGenerally speaking you may want to use aliases to define a subset of values that are meant to have a specific meaning\nExample: you might need a type that describes the name of a person; every name is a string; but not every string is a name.\nTo make clear the distinction you define an alias of the string type to be the Name type\nstring\nName\nWe define new aliases using the palias ts function:\npalias\nconst Age = palias( int );\nconst Age = palias( int );\nNow we have a new type to specifically represent ages.\nTo get a term of the aliased type you can use the from static method of the class you got from calling palias:\nfrom\npalias\nconst someAge: Term<typeof Age> = Age.from( pInt(18) );\nconst someAge: Term<typeof Age> = Age.from( pInt(18) );\nTo enhance the alias with specific custom methods, we can:\nconst Age = palias(int, \"Age\", { inDogYears: pfn([int], int)(age => age.mul(7)), nextBirthday: pfn([int], int)(age => age.add(1))});\nconst Age = palias(int, \"Age\", { inDogYears: pfn([int], int)(age => age.mul(7)), nextBirthday: pfn([int], int)(age => age.add(1))});\nwhich can be used as,\nconst myAge = Age(20);const dogYears = myAge.inDogYears(); // 140\nconst myAge = Age(20);const dogYears = myAge.inDogYears(); // 140\nIn a future version aliases will be able to add constraints over the type the are alias of as an example whe might want to force every Age to be non-negative, since a negative age doesn't really make sense\nAge\nWhen an alias will be constrained plu-ts will check for the constraints to be met each time a term with an alias is constructed and will fail the computation if the constraints are not met\nplu-ts\nplu-ts\nAs explained in the types section, aliases and structs have different plu-ts level types. To access them we need to use the type static method defined in the Alias class:\nplu-ts\ntype\nconst agePlutsType = Age.type;\nconst agePlutsType = Age.type;\nSo if we want to define a function that accepts an Age as input we would write:\nAge\nconst pisAdult = plam( Age.type, bool )( age => age.gtEq( 18 ) );\nconst pisAdult = plam( Age.type, bool )( age => age.gtEq( 18 ) );\nOr the slightly more efficient version, based on partial function application:\nconst pisAdult = plessThanEqual.$( 18 )\nconst pisAdult = plessThanEqual.$( 18 )\nplu-ts"
  },
  {
    "prompt": "PScriptContext?",
    "completion": "PScriptContext\nThe modifications in PScriptContext from V2 version are highlighted.\nPScriptContext\nType that provides the context of a script execution. This includes details about the transaction and the purpose of the script within that transaction.\nThe Script Context is probably the most important piece of data your script receives. That is because this data is passed directly by the cardano node during the contract evaluation; hence it can always be trusted.\ndefinition:\nexport const PScriptContext = pstruct({ PScriptContext: { tx: PTxInfo.type, redeemer: data, purpose: PScriptInfo.type }});\nexport const PScriptContext = pstruct({ PScriptContext: { tx: PTxInfo.type, redeemer: data, purpose: PScriptInfo.type }});\nWe see it has a single constructor that includes 3 fields:\ntx\nInformation about the transaction in which the script is being executed\ntype: PTxInfo.type\nPTxInfo.type\nredeemer\nRedeemer data that represents the inputs/parameters used for script execution\ntype: data\ndata\npurpose\nPurpose of the script being executed\ntype: PScriptInfo.type\nPScriptInfo.type\ntx\nredeemer\npurpose"
  },
  {
    "prompt": "PTxInfo?",
    "completion": "PTxInfo\nThe modifications in PTxInfo from V2 version are highlighted.\nPTxInfo\nIt includes all the information (details about inputs, outputs, fees, minting, certificates, and various associated data) about a transaction in which the script is included.\nDefinition:\nexport const PTxInfo = pstruct({ PTxInfo: { inputs: list( PTxInInfo.type ), refInputs: list( PTxInInfo.type ), outputs: list( PTxOut.type ), fee: int, // lovelaces /** mint has no lovelaces entry */ mint: PValue.type, certificates: list( PCertificate.type ), withdrawals: map( PCredential.type, int ), interval: PPOSIXTimeRange.type, signatories: list( PPubKeyHash.type ), redeemers: map( PScriptPurpose.type, data ), datums: map( PDatumHash.type, data ), id: PTxId.type, votes: map( PVoter.type, map( PTxOutRef.type, PVote.type ) ), proposalProcedures: list( PProposalProcedure.type ), currentTreasury: PMaybe( int ).type, treasuryDonation: PMaybe( int ).type, }});\nexport const PTxInfo = pstruct({ PTxInfo: { inputs: list( PTxInInfo.type ), refInputs: list( PTxInInfo.type ), outputs: list( PTxOut.type ), fee: int, // lovelaces /** mint has no lovelaces entry */ mint: PValue.type, certificates: list( PCertificate.type ), withdrawals: map( PCredential.type, int ), interval: PPOSIXTimeRange.type, signatories: list( PPubKeyHash.type ), redeemers: map( PScriptPurpose.type, data ), datums: map( PDatumHash.type, data ), id: PTxId.type, votes: map( PVoter.type, map( PTxOutRef.type, PVote.type ) ), proposalProcedures: list( PProposalProcedure.type ), currentTreasury: PMaybe( int ).type, treasuryDonation: PMaybe( int ).type, }});\nValues implements all the properties defined on the TermList utility term.\nTermList\ninputs\nList of transaction inputs. Each input representing an unspent transaction output (UTXO) consumed by the current transaction.\ntype: list( PTxInInfo.type )\nlist( PTxInInfo.type )\nelements's type:\nPTxInInfo\nrefInputs\nReference inputs of the transaction. These UTXOs are referenced but not consumed by the transaction. This additional context/information maybe necessary for the contract logic but do not directly affect the transaction's output.\ntype: list( PTxInInfo.type )\nlist( PTxInInfo.type )\nelements's type:\nPTxInInfo\noutputs\nList of transaction outputs. Each output represents a new UTXO created by the transaction.\ntype: list( PTxOut.type )\nlist( PTxOut.type )\nelements's type: PTxOut\nPTxOut\nfee\nTransaction fee specified in lovelaces\ntype: TermInt\nTermInt\nmint\nIncludes all tokens minted/burned in the transaction.\ntype: PValue.type\nPValue.type\nBeing a value directly constructed by the node it always includes an entry for lovelaces\nlovelaces\nSince lovelaces can't be minted/burned the quantity will always be 0\ncertificates\nList of certificates associated with the transaction.\ntype: list( PCertificate.type )\nlist( PCertificate.type )\nelements's type: PCertificate\nPCertificate\nwithdrawals\nMap of withdrawals made during the transaction\ntype: map( PCredential.type, int )\nmap( PCredential.type, int )\nelements's types:\nPCredential\nTermInt\ninterval\nTime interval during which the transaction is valid.\ntype: PPOSIXTimeRange.type\nPPOSIXTimeRange.type\nsignatories\nA list of public key hashes of the parties that have signed the transaction to validate it.\ntype: list( PPubKeyHash.type )\nlist( PPubKeyHash.type )\nelements's type: PPubKeyHash\nPPubKeyHash\nredeemers\nMap of redeemers associated with specific script purposes\ntype: map( PScriptPurpose.type, data )\nmap( PScriptPurpose.type, data )\nelements's types:\nPScriptPurpose\ndata\ndatums\nMap of datums identified by their hashes\ntype: map( PDatumHash.type, data )\nmap( PDatumHash.type, data )\nelements's types:\nPDatumHash\ndata\nid\nThe unique identifier of the transaction, used to reference and track the specific transaction on the blockchain.\ntype: PTxId.type\nPTxId.type\nvotes\nMap of votes cast in the transaction\ntype: map( PVoter.type, map( PTxOutRef.type, PVote.type ) )\nmap( PVoter.type, map( PTxOutRef.type, PVote.type ) )\nelements's types:\nPVoter.type\nPTxOutRef.type\nPVote.type\nproposalProcedures\nList of proposal procedures included in the transaction\ntype: list( PProposalProcedure.type )\nelements's types:\nPProposalProcedure\ncurrentTreasury\n(Optional) Current treasury amount\ntype: PMaybe( int ).type\nPMaybe( int ).type\ntreasuryDonation\n(Optional) Treasury donation amount\ntype: PMaybe( int ).type\nPMaybe( int ).type\ninputs\nrefInputs\noutputs\nfee\nmint\ncertificates\nwithdrawals\ninterval\nsignatories\nredeemers\ndatums\nid\nvotes\nproposalProcedures\ncurrentTreasury\ntreasuryDonation"
  },
  {
    "prompt": "TermListPElemsType?",
    "completion": "TermList<PElemsType>\ntype definition:\ntype TermList<PElemsT extends PDataRepresentable> = Term<PList<PElemsT>> & { readonly head: UtilityTermOf<PElemsT> readonly tail: TermList<PElemsT> readonly length: TermInt readonly atTerm: TermFn<[PInt], PElemsT> readonly at: ( index: Term<PInt> ) => UtilityTermOf<PElemsT> readonly findTerm: TermFn<[PLam<PElemsT,PBool>], PMaybeT<PElemsT>> readonly find: ( predicate: Term<PLam<PElemsT,PBool>> ) => Term<PMaybeT<PElemsT>> readonly filterTerm: TermFn<[PLam<PElemsT,PBool>], PList<PElemsT>> readonly filter: ( predicate: Term<PLam<PElemsT,PBool>> ) => TermList<PElemsT> readonly preprendTerm: TermFn<[PElemsT], PList<PElemsT>> readonly preprend: ( elem: Term<PElemsT> ) => TermList<PElemsT> readonly mapTerm: <ResultT extends ConstantableTermType>( resultT: ResultT ) => TermFn<[PLam<PElemsT, ToPType<ResultT>>], PList<ToPType<ResultT>>> readonly map: <PResultElemT extends PType>( f: Term<PLam<PElemsT,PResultElemT>> ) => TermList<PResultElemT> readonly everyTerm: TermFn<[PLam<PElemsT, PBool>], PBool> readonly every: ( predicate: Term<PLam<PElemsT, PBool>> ) => TermBool readonly someTerm: TermFn<[PLam<PElemsT, PBool>], PBool> readonly some: ( predicate: Term<PLam<PElemsT, PBool>> ) => TermBool}\ntype TermList<PElemsT extends PDataRepresentable> = Term<PList<PElemsT>> & { readonly head: UtilityTermOf<PElemsT> readonly tail: TermList<PElemsT> readonly length: TermInt readonly atTerm: TermFn<[PInt], PElemsT> readonly at: ( index: Term<PInt> ) => UtilityTermOf<PElemsT> readonly findTerm: TermFn<[PLam<PElemsT,PBool>], PMaybeT<PElemsT>> readonly find: ( predicate: Term<PLam<PElemsT,PBool>> ) => Term<PMaybeT<PElemsT>> readonly filterTerm: TermFn<[PLam<PElemsT,PBool>], PList<PElemsT>> readonly filter: ( predicate: Term<PLam<PElemsT,PBool>> ) => TermList<PElemsT> readonly preprendTerm: TermFn<[PElemsT], PList<PElemsT>> readonly preprend: ( elem: Term<PElemsT> ) => TermList<PElemsT> readonly mapTerm: <ResultT extends ConstantableTermType>( resultT: ResultT ) => TermFn<[PLam<PElemsT, ToPType<ResultT>>], PList<ToPType<ResultT>>> readonly map: <PResultElemT extends PType>( f: Term<PLam<PElemsT,PResultElemT>> ) => TermList<PResultElemT> readonly everyTerm: TermFn<[PLam<PElemsT, PBool>], PBool> readonly every: ( predicate: Term<PLam<PElemsT, PBool>> ) => TermBool readonly someTerm: TermFn<[PLam<PElemsT, PBool>], PBool> readonly some: ( predicate: Term<PLam<PElemsT, PBool>> ) => TermBool}\nmost of the equivalent expressions and some of the terms that requre some other informations are plu-ts generics\nplu-ts\nUtilityTermOf\nTermList is a generic, and it works for every PType\nTermList\nPType\nHowever, given a generic PType we don't know what is its utility term or even if it has any\nPType\nUtilityTermOf handles all that; if PElemsT is something that can have an utility term it returns that utility term; otherwise returns the plain term.\nUtilityTermOf\nPElemsT\nexample\nUtilityTermOf PByteString === TermBS\nUtilityTermOf<PByteString>\nTermBS\nUtilityTermOf PDelayed PByteString === Term PDelayed PByteString\nUtilityTermOf<PDelayed<PByteString>>\nTerm<PDelayed<PByteString>>\nhead\nhead\nreturns: UtilityTermOf PElemsT\nUtilityTermOf<PElemsT>\nthrows if the list is empty ([])\n[]\nequivalent expression:\nphead( elemsT ).$( term )\nphead( elemsT ).$( term )\nreturns the first element of the list\ntail\ntail\nreturns: UtilityTermOf PElemsT\nUtilityTermOf<PElemsT>\nthrows if the list is empty ([])\n[]\nequivalent expression:\nptail( elemsT ).$( term )\nptail( elemsT ).$( term )\nreturns a new list with the same elements of the term except for the first one.\nlength\nlength\nreturns: TermInt\nTermInt\nequivalent expression:\nplength( elemsT ).$( term )\nplength( elemsT ).$( term )\nO(n)\nreturns the number of elements present in the list.\nat\nat\nparameter: index type: Term PInt\nindex\nTerm<PInt>\nreturns: UtilityTermOf PElemsT\nUtilityTermOf<PElemsT>\nthrows if index = length\nindex\nlength\nequivalent expression:\npindex( elemsT ).$( term ).$( index )\npindex( elemsT ).$( term ).$( index )\nreturns the element at position index.\nindex\nfind\nfind\nparameter: predicate type: Term PLam PElemsT,PBool\npredicate\nTerm<PLam<PElemsT,PBool>>\nreturns: Term PMaybeT PElemsT\nTerm<PMaybeT<PElemsT>>\nequivalent expression:\npfind( elemsT ).$( predicate ).$( term )\npfind( elemsT ).$( predicate ).$( term )\nreturns PMaybe( elemsT ).Just({ val: elem }) where elem is the first element of the list that satisfies the predicate; returns PMaybe( elemsT ).Nothing({}) if none of the elements satisfies the predicate.\nPMaybe( elemsT ).Just({ val: elem })\nelem\npredicate\nPMaybe( elemsT ).Nothing({})\npredicate\nfilter\nfilter\nparameter: predicate type: Term PLam PElemsT,PBool\npredicate\nTerm<PLam<PElemsT,PBool>>\nreturns: TermList PElemsT\nTermList<PElemsT>\nequivalent expression:\npfilter( elemsT ).$( predicate ).$( term )\npfilter( elemsT ).$( predicate ).$( term )\nreturns a new list containing only the elements that satisfy the predicate.\npredicate\nprepend\nprepend\nparameter: elem type: Term PElemsT\nelem\nTerm<PElemsT>\nreturns: TermList PElemsT\nTermList<PElemsT>\nequivalent expression:\npprepend( elemsT ).$( elem ).$( term )\npprepend( elemsT ).$( elem ).$( term )\nreturns a new list with the elem element added at the start of the list.\nelem\nmap\nmap\nparameter: f type: Term PLam PElemsT,PResultElemT\nf\nTerm<PLam<PElemsT,PResultElemT>>\nreturns: TermList PResultElemT\nTermList<PResultElemT>\nequivalent expression:\npmap( elemsT, resultT ).$( f ).$( term )\npmap( elemsT, resultT ).$( f ).$( term )\nreturns a new list containing the result of applying f to the element in the same position.\nf\nNOTE mapTerm requires the return type of f; this is not true for map because map can understand the type directly from the parameter f.\nmapTerm\nf\nmap\nmap\nf\nevery\nevery\nparameter: predicate type: Term PLam PElemsT, PBool\npredicate\nTerm<PLam<PElemsT, PBool>>\nreturns: TermBool\nTermBool\nequivalent expression:\npevery( elemsT ).$( predicate ).$( list )\npevery( elemsT ).$( predicate ).$( list )\napplies the predicate to each term of the list and returns pBool( false ) if any of them is pBool( false ); pBool( true ) otherwise;\npredicate\npBool( false )\npBool( false )\npBool( true )\nsome\nsome\nparameter: predicate type: Term PLam PElemsT, PBool\npredicate\nTerm<PLam<PElemsT, PBool>>\nreturns: TermBool\nTermBool\nequivalent expression:\npsome( elemsT ).$( predicate ).$( list )\npsome( elemsT ).$( predicate ).$( list )\napplies the predicate to each term of the list and returns pBool( true ) if any of them is pBool( true ); pBool( false ) otherwise;\npredicate\npBool( true )\npBool( true )\npBool( false )\nhead\ntail\nlength\nat\nfind\nfilter\nprepend\nmap\nevery\nsome"
  },
  {
    "prompt": "TxBuilder?",
    "completion": "TxBuilder\nplu-ts/offchain exposes the TxBuilder class.\nplu-ts/offchain\nTxBuilder\nIts purpose is to allow you to build transactions more easly.\nYou could infact build transactions by calling the Tx constructor.\nTx\nHowever that requires a profound understanding of the structure of a Cardano transaction.\nfor this reason we have the TxBuilder.\nTxBuilder\nYou can get your TxBuilder by passing the ProtocolParameters (that you'll need to query) needed for the network you are building transactions for.\nTxBuilder\nProtocolParameters\nconstructor definiton:\nconstructor( protocolParamters: Readonly<ProtocolParameters>, genesisInfos?: GenesisInfos)\nconstructor( protocolParamters: Readonly<ProtocolParameters>, genesisInfos?: GenesisInfos)\nexample:\ntype MyFavoriteServiceResponse = any// you'll need to adapt the protocol parameters// to the expected interfacefunction adaptServiceProtocolParams( response: MyFavoriteServiceResponse): ProtocolParameters{ /* do your magic */}const txBuilder = new TxBuilder( adaptServiceProtocolParams( await fetch(\"my-favorite-service.com/api/protocol-parameters\") ));\ntype MyFavoriteServiceResponse = any// you'll need to adapt the protocol parameters// to the expected interfacefunction adaptServiceProtocolParams( response: MyFavoriteServiceResponse): ProtocolParameters{ /* do your magic */}const txBuilder = new TxBuilder( adaptServiceProtocolParams( await fetch(\"my-favorite-service.com/api/protocol-parameters\") ));\nonce you have your tx builder you can use all the following methods.\nbuildSync\nrunWithProvider\nkeepRelevant\ncalcLinearFee\ngetMinimumOutputLovelaces\nsetGenesisInfos\nslotToPOSIX\nposixToSlot\noverrideTxRedeemers\nbuildSync\nrunWithProvider\nonce you have a TxBuilder instance there are 2 ways to build a transaction:\nTxBuilder\nbuildSync\nTxBuilderRunner\nPartial<IProvider>\nrunWithProvider\nThe buildSync method gives you full controll, you need to query the resolved utxos for the inputs, as well any other information required for transaction validation.\nbuildSync\nOnce you provide the data as specified in by ITxBuildArgs the TxBuilder instance will syncronously build and validate your transaction.\nITxBuildArgs\nTxBuilder\nIf you don't want to take care of querying the data, you can pass a Provider to the runWithProvider method, to get a TxBuilderRunner instance.\nProvider\nrunWithProvider\nTxBuilderRunner\nThe runner has many method that abstract the buildSync interface, so that you can describe your transaction an a much higher level, and if some that is missing it will be queried asynchronously using the Provider that was passed.\nbuildSync\nProvider\nbuildSync\nrunWithProvider"
  },
  {
    "prompt": "plet?",
    "completion": "plet\nUp until this part of the documentation we wrote plu-ts code that didn't need to re-use values, but in a real case scenario that is quite common.\nplu-ts\nOne might think that storing the result of a plu-ts function call can solve the issue, but it actually doesn't.\nplu-ts\nLet's take a look at the following code:\nconst pdoubleFactorial = plam( int, int ) ( n => { // DON'T COPY THIS CODE; THIS IS REALLY BAD const factorialResult = pfactorial.$( n ) return factorialResult.add( factorialResult ); });\nconst pdoubleFactorial = plam( int, int ) ( n => { // DON'T COPY THIS CODE; THIS IS REALLY BAD const factorialResult = pfactorial.$( n ) return factorialResult.add( factorialResult ); });\nAt first glance, the code above is not doing anything bad, right?\nWRONG!\nFrom the plu-ts point of view the function above is defined as:\nplu-ts\nconst pdoubleFactorial = plam( int, int ) ( n => pfactorial.$( n ).add( pfactorial.$( n ) ) );\nconst pdoubleFactorial = plam( int, int ) ( n => pfactorial.$( n ).add( pfactorial.$( n ) ) );\nwhich is calling pfactorial.$( n ) twice!\npfactorial.$( n )\nThe intention of the above code is to store the result of pfactorial.$( n ) in a variable and then re-use that result, but that is not what is going on here.\npfactorial.$( n )\nplet\nFortunately plu-ts exposes the plet function that does exactly that; we can rewrite the above code as:\nplu-ts\nplet\nconst pdoubleFactorial = plam( int, int ) ( n => { const factorialResult = plet( pfactorial.$( n ) ) return factorialResult.add( factorialResult ); });\nconst pdoubleFactorial = plam( int, int ) ( n => { const factorialResult = plet( pfactorial.$( n ) ) return factorialResult.add( factorialResult ); });\nThis way plu-ts can first execute the pfactorial.$( n ) function call and store the result in the factorialResult which was the intended behavior in the first place.\nplu-ts\npfactorial.$( n )\nfactorialResult\nplet\nWhen used as in the snippet above the compiler will take a look at how the value you stored in a variable is used and might decide to inline it if it decides that it is more efficient.\nThis will most of the time due to the value being used a single time.\nSo even if you are using the result of pfactorial.$( n ) a single time using plet won't store the result in a variable because there's no advantage.\npfactorial.$( n )\nplet\nBut still if you use it two or more time it will be stored in a variable instead so that it is computed only once.\nWhen in doubt use plet;\nplet\nThe compiler is smart enough to understand if it should be inlined or stored in a variable\nplet().in()\nYou can opt out the compiler taking control using the plet's in method.\nplet\nin\nThe plet( stuff ).in( myVar = {/*...*/}) construct forces the term to be stored in a variable even if used once.\nplet( stuff ).in( myVar => {/*...*/})\nThere are some cases where this might be the desired behavior;\nas an example using the in method makes clear the scope of the variable;\nin\nbut the most common use case is when you have a single reference in a piece of code that is recursive.\nconst fancyDoubleMult = phoist( pfn([ int, int ], int) ((a, b) => { const myVar = plet( pInt(a).add(a) ); // how you would implement multiplication using only additions return precursive( pfn([ lam( int, int ), int ], int) (( self, n ) => { return pif( int ).$( n.ltEq( 0 ) ) .then( 0 ) .else( // we only have a single reference here; // so this `myVar` might be inlined myVar.add( self.$( n.sub( 1 ) ) ) ); }) ).$( b ) }))\nconst fancyDoubleMult = phoist( pfn([ int, int ], int) ((a, b) => { const myVar = plet( pInt(a).add(a) ); // how you would implement multiplication using only additions return precursive( pfn([ lam( int, int ), int ], int) (( self, n ) => { return pif( int ).$( n.ltEq( 0 ) ) .then( 0 ) .else( // we only have a single reference here; // so this `myVar` might be inlined myVar.add( self.$( n.sub( 1 ) ) ) ); }) ).$( b ) }))\nEven though the compiler will try to do its best, if you want to be sure that you are not re executing some code for each recursive call you can use plet( stuff ).in( myVar = {/*...*/}), as follows:\nplet( stuff ).in( myVar => {/*...*/})\nconst fancyDoubleMult = phoist( pfn([ int, int ], int) ((a, b) => { // here we force `myVar` to be evaluated // and stored in a variable return plet( pInt(a).add(a) ).in( myVar => precursive( pfn([ lam( int, int ), int ], int) (( self, n ) => { return pif( int ).$( n.ltEq( 0 ) ) .then( 0 ) .else( // same expression but we know // we are not re-running `myVar`'s expression myVar.add( self.$( n.sub( 1 ) ) ) ); }) ).$( b ) ); }))\nconst fancyDoubleMult = phoist( pfn([ int, int ], int) ((a, b) => { // here we force `myVar` to be evaluated // and stored in a variable return plet( pInt(a).add(a) ).in( myVar => precursive( pfn([ lam( int, int ), int ], int) (( self, n ) => { return pif( int ).$( n.ltEq( 0 ) ) .then( 0 ) .else( // same expression but we know // we are not re-running `myVar`'s expression myVar.add( self.$( n.sub( 1 ) ) ) ); }) ).$( b ) ); }))\nplet\nWhen working with utility terms it's important not to forget that the methods are just partially applied functions so if you plan to use some of the methods more than once is a good idea to plet them.\nplet\nAs an example, when working with the TermList PElemsT utility term, intuition might lead you to just reuse the length property more than once in various places; but actually, each time you do something like list.length (where list is a TermList); you are just writing plength.$( list ) (as in the first case introduced here) which is an O(n) operation!\nTermList<PElemsT>\nlength\nlist.length\nlist\nTermList\nplength.$( list )\nO(n)\nWhat you really want to do in these cases is something like:\nplet( list.length ).in( myLength => { ...})\nplet( list.length ).in( myLength => { ...})\nThis is also true for terms that do require some arguments.\nSay you need to access different elements of the same list multiple times:\nconst addFirstTwos = lam( list( int ), int ) ( list => padd .$( list.at( 0 ) ) .$( list.at( 1 ) ) );\nconst addFirstTwos = lam( list( int ), int ) ( list => padd .$( list.at( 0 ) ) .$( list.at( 1 ) ) );\nWhat you are actually writing there is:\nconst addFirstTwos = lam( list( int ), int ) ( list => padd .$( pindex( int ).$( list ).$( 0 ) ) .$( pindex( int ).$( list ).$( 1 ) ) );\nconst addFirstTwos = lam( list( int ), int ) ( list => padd .$( pindex( int ).$( list ).$( 0 ) ) .$( pindex( int ).$( list ).$( 1 ) ) );\nIf you notice, you are re-writing pindexList( int ).$( list ) which is a very similar case of calling the pfactorial function we saw before twice.\npindexList( int ).$( list )\npfactorial\nInstead is definitely more efficient something like:\nconst addFirstTwos = lam( list( int ), int ) ( list => // store the function to access the elements of the list // in the `elemAt` variable plet( list.atTerm ).in( elemAt => padd .$( elemAt.$( 0 ) ) .$( elemAt.$( 1 ) ) ) );\nconst addFirstTwos = lam( list( int ), int ) ( list => // store the function to access the elements of the list // in the `elemAt` variable plet( list.atTerm ).in( elemAt => padd .$( elemAt.$( 0 ) ) .$( elemAt.$( 1 ) ) ) );\nplet\nYou definitely don't want to plet everything that is already in a variable; that includes:\nplet\nplet\npmatch\nextract\nextract\nplet\nplet\nplet().in()\nplet\nplet"
  },
  {
    "prompt": "pmatch?",
    "completion": "pmatch\nWhen we had our first look at the structs, we hinted at the possibility of custom control flows.\nThese are possible thanks to the pmatch construct.\npmatch\nTo understand why this is extremely useful, let's take our Toy struct we defined looking at pstruct.\nToy\npstruct\nconst Toy = pstruct({ Stick: {}, Ball: { size: int, isSoft: bool }, Mailman: { name: str, age: Age.type }})\nconst Toy = pstruct({ Stick: {}, Ball: { size: int, isSoft: bool }, Mailman: { name: str, age: Age.type }})\nAnd let's say we want to have a function that extracts the name of the mailman our dog plays with when we're out. It would look something like this:\nconst getMailmanName = plam( Toy.type, str )( toy => pmatch( toy ) .onMailman( mailman => mailman.name ) .onStick( _ => pStr(\"\") ) .onBall( _ => pStr(\"\") ))\nconst getMailmanName = plam( Toy.type, str )( toy => pmatch( toy ) .onMailman( mailman => mailman.name ) .onStick( _ => pStr(\"\") ) .onBall( _ => pStr(\"\") ))\npmatch is taking a struct Term and returns a Typescript object with all the names of possible constructors that struct has, based on its definition.\npmatch\nTerm\nIt then executes the branch based on the constructor used to get the struct instance.\nA pmatch branch gets as input the instance of the struct with all fields aviable trough dot notation.\npmatch\nThis way the defined function returns the name of the mailman if the Toy was actually constructed using the Mailman constructor; otherwise it returns an empty string.\nMailman\n_\npmatch will force you to cover the cases for all constructors; but many times we only want to do something if the struct was built using one specific constructor without regard for any other constructors.\npmatch\nIn fact we found ourselves in a very similar case in the example above: we want to do something only in the Mailman case but not in the others.\nMailman\nFor situations like these there is the underscore (_) wildcard, that allows us to rewrite our function as follows:\n_\nconst getMailmanName = plam( Toy.type, str )( toy => pmatch( toy ) .onMailman( mailman => mailman.name ) ._( _ => pStr(\"\") ))\nconst getMailmanName = plam( Toy.type, str )( toy => pmatch( toy ) .onMailman( mailman => mailman.name ) ._( _ => pStr(\"\") ))\nThis not only makes the code more readable but in the vast majority of the cases it also makes it more efficient!\nNow that we have a way to extract the name of the mailman from a Toy, we need to pass the actual toy to the function we just defined.\nUsing the pmatch function, our code would look like this:\npmatch\n// remember the definition of `Dog`const Dog = pstruct({ Dog: { name: str, age: Age.type, favouriteToy: Toy.type }});const getMailmanNameFromDog = plam( Dog.type, str )( dog => pmatch( dog ) .onDog( dogInstance => getMailmanName.$( dogInstance.favouriteToy ) ))\n// remember the definition of `Dog`const Dog = pstruct({ Dog: { name: str, age: Age.type, favouriteToy: Toy.type }});const getMailmanNameFromDog = plam( Dog.type, str )( dog => pmatch( dog ) .onDog( dogInstance => getMailmanName.$( dogInstance.favouriteToy ) ))\nThis works just fine but is a lot of code just to get a field of a constructor we know is unique.\nFortunately for us, if the struct definition has only one possible constructor, this struct term directly exposes the fields; so that we can threat it as a normal javascript object\nThis allows us to rewrite the function as\nconst getMailmanNameFromDog = plam( Dog.type, str )( dog => getMailmanName.$( dog.favouriteToy ))\nconst getMailmanNameFromDog = plam( Dog.type, str )( dog => getMailmanName.$( dog.favouriteToy ))\nwhich is a lot cleaner!\n_"
  },
  {
    "prompt": "Script?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Script\nT extends LitteralScriptType = LitteralScriptType\nLitteralScriptType\nLitteralScriptType\nToCbor\nnew Script T (scriptType, bytes): Script T\nT\nscriptType\nbytes\nScript\nT\nscriptType: T\nT\nbytes: Uint8Array | T extends NativeScript ? NativeScript : PlutusScriptJsonFormat PlutusScriptType\nUint8Array\nT\nNativeScript\nNativeScript\nPlutusScriptJsonFormat\nPlutusScriptType\nScript T\nScript\nT\nsrc/script/Script.ts:41\nreadonly bytes: Uint8Array\nreadonly\nUint8Array\nsrc/script/Script.ts:32\nreadonly cbor: T extends NativeScript ? never : CborString\nreadonly\nT\nNativeScript\nnever\nCborString\nformat expected by cardano-cli\ncardano-cli\nfor standard ledger format (as defined in CDDL) use toCbor method\ntoCbor\nsrc/script/Script.ts:38\nreadonly hash: Hash28\nreadonly\nHash28\nsrc/script/Script.ts:39\nreadonly type: T\nreadonly\nT\nsrc/script/Script.ts:31\nclone(): Script T\nScript\nT\nScript T\nScript\nT\nsrc/script/Script.ts:163\ntoCbor(): CborString\nCborString\nformat specified in the ledger CDDL\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/script/Script.ts:213\ntoCborObj(): CborObj\nCborObj\nformat specified in the ledger CDDL\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/script/Script.ts:220\ntoJson(): ScriptSignature | ScriptAll | ScriptAny | ScriptAtLeast | ScriptAfter | ScriptBefore | object\nScriptSignature\nScriptAll\nScriptAny\nScriptAtLeast\nScriptAfter\nScriptBefore\nobject\nScriptSignature | ScriptAll | ScriptAny | ScriptAtLeast | ScriptAfter | ScriptBefore | object\nScriptSignature\nScriptAll\nScriptAny\nScriptAtLeast\nScriptAfter\nScriptBefore\nobject\nsrc/script/Script.ts:171\nstatic fromCbor(cbor, defType): Script LitteralScriptType\nstatic\ncbor\ndefType\nScript\nLitteralScriptType\ncbor: CanBeCborString\nCanBeCborString\ndefType: ScriptType = ScriptType.PlutusV2\nScriptType\nScriptType.PlutusV2\nScript LitteralScriptType\nScript\nLitteralScriptType\nsrc/script/Script.ts:240\nstatic fromCborObj(cObj, defType): Script LitteralScriptType\nstatic\ncObj\ndefType\nScript\nLitteralScriptType\ncObj: CborObj\nCborObj\ndefType: ScriptType = ScriptType.PlutusV2\nScriptType\nScriptType.PlutusV2\nScript LitteralScriptType\nScript\nLitteralScriptType\nsrc/script/Script.ts:245\nstatic fromJson(json): Script LitteralScriptType\nstatic\njson\nScript\nLitteralScriptType\njson: any\nany\nScript LitteralScriptType\nScript\nLitteralScriptType\nsrc/script/Script.ts:195"
  },
  {
    "prompt": "Address?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Address\nshelley specification in cardano-ledger; page 113\nToData\nToCbor\nnew Address(network, paymentCreds, stakeCreds?, type?): Address\nnetwork\npaymentCreds\nstakeCreds\ntype\nAddress\nnetwork: NetworkT\nNetworkT\npaymentCreds: Credential CredentialType\nCredential\nCredentialType\nstakeCreds?: StakeCredentials StakeCredentialsType\nStakeCredentials\nStakeCredentialsType\ntype?: AddressType\nAddressType\nAddress\nAddress\nsrc/ledger/Address.ts:75\nreadonly network: NetworkT\nreadonly\nNetworkT\nsrc/ledger/Address.ts:42\nreadonly paymentCreds: Credential CredentialType\nreadonly\nCredential\nCredentialType\nsrc/ledger/Address.ts:43\nreadonly optional stakeCreds: StakeCredentials StakeCredentialsType\nreadonly\noptional\nStakeCredentials\nStakeCredentialsType\nsrc/ledger/Address.ts:44\nreadonly type: AddressType\nreadonly\nAddressType\nsrc/ledger/Address.ts:45\nget static fake(): Address\nget\nstatic\nAddress\nAddress\nAddress\nsrc/ledger/Address.ts:132\nclone(): Address\nAddress\nAddress\nAddress\nsrc/ledger/Address.ts:122\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nsrc/ledger/Address.ts:269\ntoBytes(): byte[]\nbyte\nbyte[]\nbyte\nsrc/ledger/Address.ts:153\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/ledger/Address.ts:337\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/ledger/Address.ts:324\ntoData(): Data\nData\nData\nData\nToData.toData\nToData.toData\nsrc/ledger/Address.ts:140\ntoJson(): `addr1${string}` | `addr_test1${string}`\n`addr1${string}` | `addr_test1${string}`\nsrc/ledger/Address.ts:384\ntoString(): `addr1${string}` | `addr_test1${string}`\nReturns a string representation of an object.\n`addr1${string}` | `addr_test1${string}`\nsrc/ledger/Address.ts:347\nstatic fromBuffer(buff): Address\nstatic\nbuff\nAddress\nbuff: string | Uint8Array\nstring\nUint8Array\nAddress\nAddress\nsrc/ledger/Address.ts:274\nstatic fromBytes(bs): Address\nstatic\nbs\nAddress\nbs: string | Uint8Array | byte[]\nstring\nUint8Array\nbyte\nAddress\nAddress\nsrc/ledger/Address.ts:192\nstatic fromCbor(cbor): Address\nstatic\ncbor\nAddress\ncbor: CanBeCborString\nCanBeCborString\nAddress\nAddress\nsrc/ledger/Address.ts:342\nstatic fromCborObj(buff): Address\nstatic\nbuff\nAddress\nbuff: CborObj\nCborObj\nAddress\nAddress\nsrc/ledger/Address.ts:329\nstatic fromEntropy(entropy, network): Address\nstatic\nentropy\nnetwork\nAddress\ngenerates an XPrv from entropy and calls Addres.fromXPrv\nXPrv\nAddres.fromXPrv\ngets the standard address for single address wallets\npayment key at path \"m/1852'/1815'/0'/0/0\" stake key at path \"m/1852'/1815'/0'/2/0\"\nentropy: string | Uint8Array\nstring\nUint8Array\nnetwork: NetworkT = \"mainnet\"\nNetworkT\n\"mainnet\"\nAddress\nAddress\nsrc/ledger/Address.ts:319\nstatic fromString(addr): Address\nstatic\naddr\nAddress\naddr: string\nstring\nAddress\nAddress\nsrc/ledger/Address.ts:355\nstatic fromXPrv(xprv, network): Address\nstatic\nxprv\nnetwork\nAddress\ngets the standard address for single address wallets\npayment key at path \"m/1852'/1815'/0'/0/0\" stake key at path \"m/1852'/1815'/0'/2/0\"\nxprv: XPrv\nXPrv\nnetwork: NetworkT = \"mainnet\"\nNetworkT\n\"mainnet\"\nAddress\nAddress\nsrc/ledger/Address.ts:289\nstatic mainnet(paymentCreds, stakeCreds?, type?): Address\nstatic\npaymentCreds\nstakeCreds\ntype\nAddress\npaymentCreds: Credential CredentialType\nCredential\nCredentialType\nstakeCreds?: StakeCredentials StakeCredentialsType\nStakeCredentials\nStakeCredentialsType\ntype?: AddressType\nAddressType\nAddress\nAddress\nsrc/ledger/Address.ts:47\nstatic testnet(paymentCreds, stakeCreds?, type?): Address\nstatic\npaymentCreds\nstakeCreds\ntype\nAddress\npaymentCreds: Credential CredentialType\nCredential\nCredentialType\nstakeCreds?: StakeCredentials StakeCredentialsType\nStakeCredentials\nStakeCredentialsType\ntype?: AddressType\nAddressType\nAddress\nAddress\nsrc/ledger/Address.ts:61"
  },
  {
    "prompt": "Simple values?",
    "completion": "For most of the types described there is a function to transform the Typescript version to the plu-ts equivalent.\nplu-ts\nHere we cover the simple ones, leaving functions and structs to be covered later.\nplu-ts\nplu-ts\nunit\npmakeUnit\npmakeUnit(): Term<PUnit>\nint\npInt\npInt(x: number \\ bigint): Term<PInt>\nbool\npBool\npBool(x: boolean): Term<PBool>\nbs\npByteString\npByteString(x: string \\ ByteString \\ Buffer): Term<PByteString>\nstr\npStr\npStr(x: string): Term<PStr>\ndata\npData\npData(x: Data): Term<PData>\nlist\npList\npList<T extends TermType>( t: T )( x: Term<ToPType<T>>[] )\npair\npPair\npPair<A extends TermType, B extends TermType>( fstT: A, sndT: B )( fst: Term<ToPType<A>>, snd: Term<ToPType<B>> )\ndelayed\npList\nSince PList is a generic type the pList function has a slightly more complex function signature:\nPList\npList\nfunction pList<ElemsT extends TermType, PElemsT extends ToPType<ElemsT = ToPType<ElemsT>>> ( elemsT: ElemsT ) : ( elems: Term<PElemsT>[] ) => Term<PList<PElemsT>>\nfunction pList<ElemsT extends TermType, PElemsT extends ToPType<ElemsT = ToPType<ElemsT>>> ( elemsT: ElemsT ) : ( elems: Term<PElemsT>[] ) => Term<PList<PElemsT>>\nIn the signature above, TermType is the Typescript types of plu-ts types (which are typescript values after all) and ToPType is a utility type used internally and you should not worry about it.\nTermType\nplu-ts\nToPType\nFrom the signature we can already understand that given a plu-ts type, pList returns a function ad-hoc for terms of that type; so if we want a function to get list of integers we just do:\nplu-ts\npList\nconst pListInt: ( elems: Term<PInt>[] ) => Term<PList<PInt>> = pList( int );\nconst pListInt: ( elems: Term<PInt>[] ) => Term<PList<PInt>> = pList( int );\nAnd with that we now have a function that transforms an array of terms into a list.\nconst intList = pListInt( [1,2,3,4].map( pInt ) );\nconst intList = pListInt( [1,2,3,4].map( pInt ) );\nYou might notice that in contrast to the other functions introduced, pListInt that we created works with terms instead of vanilla ts values; this is because pListInt acts as a macro as seen by plu-ts.\npListInt\npListInt\nplu-ts\npPair\nJust like PList, also PPair is a generic type, which causes pPair to have more complex function signature too:\nPList\nPPair\npPair\nfunction pPair< A extends TermType, B extends TermType, PA extends ToPType<A> = ToPType<A>, PA extends ToPType<B> = ToPType<B>,> ( fstT: A, sndT: B ) : ( fst: PappArg<PA>, snd: PappArg<PB> ) => Term<PPair<PA,PB>>\nfunction pPair< A extends TermType, B extends TermType, PA extends ToPType<A> = ToPType<A>, PA extends ToPType<B> = ToPType<B>,> ( fstT: A, sndT: B ) : ( fst: PappArg<PA>, snd: PappArg<PB> ) => Term<PPair<PA,PB>>\nand you would use it in a very similar way of pList:\npList\nconst myPair = pPair( bs, int )( \"caffee\", 2 )\nconst myPair = pPair( bs, int )( \"caffee\", 2 )\nNote how we are passing typescript value without transforming them to plu-ts ones;\nplu-ts\nThis is some magic done by 'plu-ts' so that if the type is known we don't have to explicitly construct it.\nWe'll see that this turns really useful while writing a smart contract\ndelayed\ndelayed doesn't really have a Typescript value, so it only makes sense in the plu-ts world.\ndelayed\nplu-ts\nYou can only obtain a delayed value from an exsisting one using pdelay\npdelay\nfunction pdelay<PT extends PType>( someTerm: Term<PT> ): Term<PDelayed<PT>>\nfunction pdelay<PT extends PType>( someTerm: Term<PT> ): Term<PDelayed<PT>>\npList\npPair\ndelayed"
  },
  {
    "prompt": "Functions?",
    "completion": "Functions can be transformed from the Typescript world to the plu-ts one just like any other value.\nLambdas and functions in general in plu-ts are often just constants seen from the typescript world, however we usually know that what we have is more than just a constant and that it can take arguments.\nWhen a plu-ts function takes more than one argument, like the pTwoIntegersList we built explaining pfn, it is possible to get new functions from the first by passing only some of the parameters.\nFortunately UPLC does have some basic functions that allow us to build more complex ones when needed."
  },
  {
    "prompt": "Structs?",
    "completion": "When writing programs we often need to access data that is more articulate than simple integers or booleans.\nSometimes it might be necessary to define custom types that are able to work with any other type; often acting as containers."
  },
  {
    "prompt": "Methods of Terms?",
    "completion": "Like in the case of papp that is meant to work with a plu-ts function as the first argument, there are functions that are meant to work with specific types.\npapp\nplu-ts\nThe functions can of course be used as normal but sometimes some arguments can be made implicit.\nAs an example, the built-in padd is meant to work with integers, so it would be great if instead of writing:\npadd\npadd.$( int1 ).$( int2 )\npadd.$( int1 ).$( int2 )\nwe could make the first argument implicit and just do:\nint1.add( int2 )\nint1.add( int2 )\nTurns out plu-ts implements some special terms that extend the normal Term functionalities, adding some methods to them. For most of the types there is a special Term type with extended functionalities:\nplu-ts\nTerm\nTerm\nTerm<PUnit>\nTerm<PInt>\nTermInt\nTerm<PBool>\nTermBool\nTerm<PByteString>\nTermBS\nTerm<PStr>\nTermStr\nTerm<PData>\nTerm<PList<PElemsType>>\nTermList<PElemsType>\nTerm<PPair<Fst,Snd>>\nTerm<PDelayed<PType>>\nTerm<PLam<In,Out>>\nTerm<PFn<Ins,Out>>\nTermFn<Ins,Out>\nTerm<Alias<PType>>\nPType\nTerm<PStruct<StructDef>>\nTermStruct<StructDef>\nWe call these \"utility terms\" and are covered more in depth in the standard library section; but is good having in mind that these exists as they make our life much easier while writing a program.\nEvery utility term exposes two variants for each property it has; one is a plain function and the other (the one that ends with \"...Term\") that is the plu-ts version of it.\nplu-ts\nLet's take a look at the TermInt definition:\nTermInt\ntype TermInt = Term<PInt> & { readonly addTerm: TermFn<[PInt], PInt> readonly add: ( other: Term<PInt> ) => TermInt readonly subTerm: TermFn<[PInt], PInt> readonly sub: ( other: Term<PInt> ) => TermInt readonly multTerm: TermFn<[PInt], PInt> readonly mult: ( other: Term<PInt> ) => TermInt // // ... lots of other methods // }\ntype TermInt = Term<PInt> & { readonly addTerm: TermFn<[PInt], PInt> readonly add: ( other: Term<PInt> ) => TermInt readonly subTerm: TermFn<[PInt], PInt> readonly sub: ( other: Term<PInt> ) => TermInt readonly multTerm: TermFn<[PInt], PInt> readonly mult: ( other: Term<PInt> ) => TermInt // // ... lots of other methods // }\nGenerally speaking you want to use the ts function version for two reasons:\nHowever, the fact that is defined as a function makes it unable to be passed as argument to plu-ts higher order functions (or a normal ts functions that expects Term PLam as argument).\nplu-ts\nTerm<PLam>\nIn that case you want to use the \"...Term\" alternative which is optimized exactly for that."
  },
  {
    "prompt": "if then else?",
    "completion": "As a solution to conditional code execution plu-ts exposes an if then else construct.\nplu-ts\nHowever, since everything in plu-ts is an expression, the if then else construct does not allow stuff that in typescript would have been written as\nplu-ts\nif( my_condition ){ doSomething();}\nif( my_condition ){ doSomething();}\nBecause we don't really know what to do if the condition is false.\nSo the if then else we have in plu-ts is more similar to the typescript ? : ternary operator, so at the end of the day, if then else is just a function.\nplu-ts\n? :\nLet's look at a simple if then else construct:\npif( int ).$( true ).then( 42 ).else( 69 )\npif( int ).$( true ).then( 42 ).else( 69 )\nThis plu-ts expression checks the condition (in our case pBool(true); remember that plu-ts is converting the typescript value for us)\nplu-ts\npBool(true)\nplu-ts\nAnd, if it is a Term PBool equivalent to true it returns pInt(42) otherwise it returns pInt(69).\nTerm<PBool>\ntrue\npInt(42)\npInt(69)\npif\nplu-ts\nSince the type of if then else is something like bool - a - a - a, we need to specify the type of a prior to the actual expression.\nbool -> a -> a -> a\na\nThis ensures type safety so that Typescript can warn you if one of the results is not of the type you expect it to be.\nDoing so Typescript can catch stuff like:\npif( int ).$( true ).then( 42 )// \"muahahah\" is converted to `pStr(\"muahahah\")`// which is obviously not of type `int`.else( \"muahahah\" )\npif( int ).$( true ).then( 42 )// \"muahahah\" is converted to `pStr(\"muahahah\")`// which is obviously not of type `int`.else( \"muahahah\" )\nplu-ts is a strict language as we saw while having a look at papp; that means that arguments are evaluated prior being passed to a function.\nplu-ts\npapp\nwhat happens if one of the argument returns an error?\nThe answer is what you expect to happen. Or, to be more precise, if the error rose in the branch selected by the boolean, the computation results in an error; if not it returns the result.\nThis is because even if by default functions are strict, pif is lazy; meaning that it evaluates only the argument it needs and not the others.\npif\nThis is done using pforce and pdelay so the compiled function is a bit larger than the one you'd expect.\npforce\npdelay\nif you don't need laziness you can use the pstrictIf function that emits slightly less code but evaluates both the arguments.\npstrictIf\nso something like\npstrictIf( int ).$( pBool( true ) ).$( pInt(42) ).$( pInt(69) )\npstrictIf( int ).$( pBool( true ) ).$( pInt(42) ).$( pInt(69) )\nis just fine but something like\n// this results in an error, even if the conditional is truepstrictIf( int ).$( pBool( true ) ).then( pInt(42) ).else( perror( int ) ) // KABOOM\n// this results in an error, even if the conditional is truepstrictIf( int ).$( pBool( true ) ).then( pInt(42) ).else( perror( int ) ) // KABOOM\ngenerally speaking you should always prefer the plain pif\npif\npif\nplu-ts"
  },
  {
    "prompt": "precursive?",
    "completion": "precursive\nThe other thing we are missing to have a proper language is some way to repeat the execution of some code.\nThe functional paradigm doesn't really like things like the loops we have in Typescript but that is not a big deal, because we can use recursive functions instead.\nWait a second!\nDon't we need to reference the same function we are defining in order to make it recursive?\nHow do we do that if we need what we are defining while defining it?\nTurns out someone else already came up with a solution for that so that we don't have to.\nThat solution is the Y combinator (actually we'll use the Z combinator but whatever).\nWe'll not go in the details on how it works, but if you are a curious one here's a great article that explains the Y combinator in javascript terms\nAll you need to know is that it allows functions to have themselves as parameters, and this solves everything!\nIn plu-ts there is a special typescript function that makes plu-ts functions recursive, and it's named, you guessed it, precursive.\nplu-ts\nplu-ts\nprecursive\nAll precursive requires to make a plu-ts function recursive is that we pass the function as the first parameter, and then we can do whatever we want with it.\nprecursive\nplu-ts\nSo let's try to define a plu-ts function that calculates the factorial of a positive number:\nplu-ts\nconst pfactorial = precursive( pfn([ // remember that the first argument is the function itself? // for this reason as first type we specify // what will be the final type of the function // because what we have here IS the function itself lam( int, int ), int ], int) (( self, n ) => pif( int ).$( n.ltEq( 1 ) ) .then( 1 ) .else( // here we are applying this same function // this is the equivalent of writing // `pfactorial.$( n.sub( 1 ) )` self.$( n.sub( 1 ) ) .mult( n ) ) ))\nconst pfactorial = precursive( pfn([ // remember that the first argument is the function itself? // for this reason as first type we specify // what will be the final type of the function // because what we have here IS the function itself lam( int, int ), int ], int) (( self, n ) => pif( int ).$( n.ltEq( 1 ) ) .then( 1 ) .else( // here we are applying this same function // this is the equivalent of writing // `pfactorial.$( n.sub( 1 ) )` self.$( n.sub( 1 ) ) .mult( n ) ) ))\nNow we can use pfactorial just like a normal function; this is because precursive takes care of passing the first argument, so that the actual type of pfactorial is just lam( int, int )\npfactorial\nprecursive\npfactorial\nlam( int, int )\nThe next step is to learn how to evaluate expressions so that we can be sure that pfactorial is working as we expect.\npfactorial"
  },
  {
    "prompt": "Term evaluation?",
    "completion": "Term\nplu-ts implements its own version of the CEK machine for the UPLC language. This allows any plu-ts term to be compiled to an UPLC Term and evaluated.\nplu-ts\nplu-ts\nin order to evaluate a term we neet to import the CEK machine implemented in plu-ts\nplu-ts\nimport { Machine } from \"@harmoniclbs/plu-ts\"\nimport { Machine } from \"@harmoniclbs/plu-ts\"\nMachine is a class, because we can instantiate our own machines based on different protocol parameters.\nMachine\nhowever it also works as is using some default parameters.\nif all we need is just to evaluate a term, then that works just fine.\nMachine.evalSimple\nThe function that evaluates Terms is Machine.evalSimple, and that's literally all you need to evaluate a term.\nTerm\nMachine.evalSimple\nMachine.evalSimple will return an UPLCTerm because UPLCTerms is what the machine is working with.\nMachine.evalSimple\nUPLCTerm\nUPLCTerm\nA UPLCTerm can be a lot of things, but if everything goes right and you expect a concrete value you'll only encounter UPLCConst instances, or some Lambda if you instead expect some functions.\nUPLCTerm\nUPLCConst\nLambda\nIf instead the plu-ts term you passed as argument fails the computation you will get back an instance of ErrorUPLC.\nplu-ts\nErrorUPLC\nTo test it we'll use the pfactorial we defined while introducing recursion\npfactorial\nimport { Machine } from \"@harmoniclbs/plu-ts\"import { pfactorial } from \"./pfactorial\";console.log( Machine.evalSimple( pfactorial.$( 0 ) )); // UPLCConst { _type: [0], _value: 1n }console.log( Machine.evalSimple( pfactorial.$( 3 ) )); // UPLCConst { _type: [0], _value: 6n }console.log( Machine.evalSimple( pfactorial.$( 5 ) )); // UPLCConst { _type: [0], _value: 120n }console.log( Machine.evalSimple( pfactorial.$( 20 ) )); // UPLCConst { _type: [0], _value: 2432902008176640000nn }\nimport { Machine } from \"@harmoniclbs/plu-ts\"import { pfactorial } from \"./pfactorial\";console.log( Machine.evalSimple( pfactorial.$( 0 ) )); // UPLCConst { _type: [0], _value: 1n }console.log( Machine.evalSimple( pfactorial.$( 3 ) )); // UPLCConst { _type: [0], _value: 6n }console.log( Machine.evalSimple( pfactorial.$( 5 ) )); // UPLCConst { _type: [0], _value: 120n }console.log( Machine.evalSimple( pfactorial.$( 20 ) )); // UPLCConst { _type: [0], _value: 2432902008176640000nn }\nMachine.evalSimple is especially useful if you need to test your plu-ts code; regardless of the testing framework of your choice you will be always able to run Machine.evalSimple.\nMachine.evalSimple\nplu-ts\nMachine.evalSimple\nMachine.evalSimple"
  },
  {
    "prompt": "phoist?",
    "completion": "phoist\nAnother great tool for optimizations is phoist and all hoisted terms.\nphoist\n( source: MDN Docs/Hoisting )\nHoisting refers to the process whereby the interpreter appears to move the declaration of functions, variables or classes to the top of their scope, prior to execution of the code.\nYou can think of hoisted terms as terms that have been pletted but in the global scope.\nplet\nSo once you use a hoisted term once, each time you re-use it you are adding almost nothing to the script size.\nYou can create a hoisted term by using the phoist function. This allows you to reuse the term you hoisted as many times as you want.\nphoist\nThis makes phoist a great tool if you need to develop a library for plu-ts; because is likely your functions will be used a lot.\nphoist\nplu-ts\nLet's say we wanted to create a library for math functions. We definitely want to have a way to calculate factorials; we already defined pfactorial while introducing recursion, however that definition is not great if we need to re-use it a lot because the term is always inlined.\npfactorial\nBut now we know how to fix it:\nconst pfactorial = phoist( precursive( pfn([ lam( int, int ), int ], int) (( self, n ) => pif( int ).$( n.ltEq( 1 ) ) .then( 1 ) .else( self.$( n.sub( 1 ) ) .mult( n ) ) ) ))\nconst pfactorial = phoist( precursive( pfn([ lam( int, int ), int ], int) (( self, n ) => pif( int ).$( n.ltEq( 1 ) ) .then( 1 ) .else( self.$( n.sub( 1 ) ) .mult( n ) ) ) ))\nIf you compare this definition with the previous one you'll see that nothing has changed except for the phoist, that's it; now we can use pfactorial as many times we want.\nphoist\npfactorial\nphoist\nNo\nphoist only accepts closed terms (aka. Terms that do not contain external variables); if you pass a term that is not closed to phoist it throws a BasePlutsError error.\nphoist\nphoist\nBasePlutsError\nSo things like:\nconst fancyTerm = plam( int, int ) ( n => phoist( n.mult( 2 ) ); // error. )\nconst fancyTerm = plam( int, int ) ( n => phoist( n.mult( 2 ) ); // error. )\nwill throw at compilation time because the variable n comes from outside the phoist function. Hence the term is open (not closed).\nn\nphoist\nphoist"
  },
  {
    "prompt": "pforce and pdelay?",
    "completion": "pforce\npdelay\nplet and phoist are the two main tools to use when focusing on optimizations;\nplet\nphoist\nthis is because they significantly reduce both script size and cost of execution.\npforce and pdelay do slightly increase the size of a script but when used properly they can save you quite a bit on execution costs.\npforce\npdelay\nAs we know, plu-ts is strictly evaluated, meaning that arguments are evaluated before being passed to a function.\nplu-ts\nWe can opt out of this behavior using pdelay which wraps a term of any type in a delayed type so a term of type int becomes delayed( int ) if passed to pdelay. A delayed type can be unwrapped only using pforce, that finally executes the term.\npdelay\ndelayed\nint\ndelayed( int )\npdelay\ndelayed\npforce\nThere are two main reasons for why we would want to do this:\nOne example of the use of pforce and pdelay is the pif function.\npforce\npdelay\npif\nIn fact, the base if then else function is pstrictIf, however when we use an if then else statement we only need one of the two arguments to be actually evaluated.\npstrictIf\nSo when we call pif, it is just as if we were doing something like:\npif\npforce( pstrictIf( delayed( returnType ) ) .$( myCondtion ) .$( pdelay( caseTrue ) ) .$( pdelay( caseFalse ) ))\npforce( pstrictIf( delayed( returnType ) ) .$( myCondtion ) .$( pdelay( caseTrue ) ) .$( pdelay( caseFalse ) ))\nSo that we only evaluate what we need.\nNot only that, but if one of the two branches throws an error but we don't need it, everything goes through smoothly:\npforce( pstrictIf( delayed( int ) ) .$( true ) .$( pdelay( pInt( 42 ) ) ) .$( pdelay( perror( int ) ) ))\npforce( pstrictIf( delayed( int ) ) .$( true ) .$( pdelay( pInt( 42 ) ) ) .$( pdelay( perror( int ) ) ))\nHere, everything is ok.\nIf instead we just used the plain pstrictIf\npstrictIf\npstrictIf( int ) .$( pBool( true ) ) .$( pInt( 42 ) ) .$( perror( int ) ) // KABOOM !!!\npstrictIf( int ) .$( pBool( true ) ) .$( pInt( 42 ) ) .$( perror( int ) ) // KABOOM !!!\nThis results in an error, because the error is evaluated before being passed as argument."
  },
  {
    "prompt": "TermInt?",
    "completion": "TermInt\ntype definition:\ntype TermInt = Term<PInt& { readonly addTerm: TermFn<[PInt], PInt> readonly add: ( other: Term<PInt) =TermInt readonly subTerm: TermFn<[PInt], PInt> readonly sub: ( other: Term<PInt) =TermInt readonly multTerm: TermFn<[PInt], PInt> readonly mult: ( other: Term<PInt) =TermInt readonly divTerm: TermFn<[PInt], PInt> readonly div: ( other: Term<PInt) =TermInt readonly quotTerm: TermFn<[PInt], PInt> readonly quot: ( other: Term<PInt) =TermInt readonly remainderTerm: TermFn<[PInt], PInt> readonly remainder: ( other: Term<PInt) =TermInt readonly modTerm: TermFn<[PInt], PInt> readonly mod: ( other: Term<PInt) =TermInt readonly eqTerm: TermFn<[PInt], PBool> readonly eq: ( other: Term<PInt) =TermBool readonly ltTerm: TermFn<[PInt], PBool> readonly lt: ( other: Term<PInt) =TermBool readonly ltEqTerm: TermFn<[PInt], PBool> readonly ltEq: ( other: Term<PInt) =TermBool readonly gtTerm: TermFn<[PInt], PBool> readonly gt: ( other: Term<PInt) =TermBool readonly gtEqTerm: TermFn<[PInt], PBool> readonly gtEq: ( other: Term<PInt) =TermBool };\ntype TermInt = Term<PInt& { readonly addTerm: TermFn<[PInt], PInt> readonly add: ( other: Term<PInt) =TermInt readonly subTerm: TermFn<[PInt], PInt> readonly sub: ( other: Term<PInt) =TermInt readonly multTerm: TermFn<[PInt], PInt> readonly mult: ( other: Term<PInt) =TermInt readonly divTerm: TermFn<[PInt], PInt> readonly div: ( other: Term<PInt) =TermInt readonly quotTerm: TermFn<[PInt], PInt> readonly quot: ( other: Term<PInt) =TermInt readonly remainderTerm: TermFn<[PInt], PInt> readonly remainder: ( other: Term<PInt) =TermInt readonly modTerm: TermFn<[PInt], PInt> readonly mod: ( other: Term<PInt) =TermInt readonly eqTerm: TermFn<[PInt], PBool> readonly eq: ( other: Term<PInt) =TermBool readonly ltTerm: TermFn<[PInt], PBool> readonly lt: ( other: Term<PInt) =TermBool readonly ltEqTerm: TermFn<[PInt], PBool> readonly ltEq: ( other: Term<PInt) =TermBool readonly gtTerm: TermFn<[PInt], PBool> readonly gt: ( other: Term<PInt) =TermBool readonly gtEqTerm: TermFn<[PInt], PBool> readonly gtEq: ( other: Term<PInt) =TermBool };\nparameter: other type: Term PInt\nother\nTerm<PInt>\nreturns TermInt\nTermInt\nequivalent expression:\npadd.$( term ).$( other )\npadd.$( term ).$( other )\nadds other to the term is defined on and returns the result\nother\nparameter: other type: Term PInt\nother\nTerm<PInt>\nreturns TermInt\nTermInt\nequivalent expression:\npsub.$( term ).$( other )\npsub.$( term ).$( other )\nsubtracts other to the term is defined on and returns the result\nother\nparameter: other type: Term PInt\nother\nTerm<PInt>\nreturns TermInt\nTermInt\nequivalent expression:\npmult.$( term ).$( other )\npmult.$( term ).$( other )\nmultiplies other to the term is defined on and returns the result\nother\nparameter: other type: Term PInt\nother\nTerm<PInt>\nreturns TermInt\nTermInt\nequivalent expression:\npdiv.$( term ).$( other )\npdiv.$( term ).$( other )\nperforms integer division using the term is defined on and other as divisor; returns the result rounded towards negative infinity.\nother\npInt( -20 ).div( -3 ) // == -7\npInt( -20 ).div( -3 ) // == -7\nparameter: other type: Term PInt\nother\nTerm<PInt>\nreturns TermInt\nTermInt\nequivalent expression:\npquot.$( term ).$( other )\npquot.$( term ).$( other )\nperforms integer division using the term is defined on and other as divisor; returns the quotient rounded towards zero:\nother\npInt( -20 ).quot( 3 ) // == -6\npInt( -20 ).quot( 3 ) // == -6\nparameter: other type: Term PInt\nother\nTerm<PInt>\nreturns TermInt\nTermInt\nequivalent expression:\nprem.$( term ).$( other )\nprem.$( term ).$( other )\nperforms integer division using the term is defined on and other as divisor; returns the remainder:\nother\npInt( -20 ).remainder( 3 ) // == -2\npInt( -20 ).remainder( 3 ) // == -2\nparameter: other type: Term PInt\nother\nTerm<PInt>\nreturns TermInt\nTermInt\nequivalent expression:\npmod.$( term ).$( other )\npmod.$( term ).$( other )\nreturns the term the method is defined on, in modulo other.\nother\npInt( -20 ).mod( 3 ) // == 1\npInt( -20 ).mod( 3 ) // == 1\nparameter: other type: Term PInt\nother\nTerm<PInt>\nreturns: TermBool\nTermBool\nequivalent expression:\npeqInt.$( term ).$( other )\npeqInt.$( term ).$( other )\ninteger equality\nparameter: other type: Term PInt\nother\nTerm<PInt>\nreturns: TermBool\nTermBool\nequivalent expression:\nplessInt.$( term ).$( other )\nplessInt.$( term ).$( other )\nreturns pBool( true ) if term is strictly less than other; pBool( false ) otherwise\npBool( true )\nterm\nother\npBool( false )\nparameter: other type: Term PInt\nother\nTerm<PInt>\nreturns: TermBool\nTermBool\nequivalent expression:\nplessEqInt.$( term ).$( other )\nplessEqInt.$( term ).$( other )\nreturns pBool( true ) if term is less or equal to other; pBool( false ) otherwise\npBool( true )\nterm\nother\npBool( false )\nparameter: other type: Term PInt\nother\nTerm<PInt>\nreturns: TermBool\nTermBool\nequivalent expression:\npgreaterInt.$( term ).$( other )\npgreaterInt.$( term ).$( other )\nreturns pBool( true ) if term is strictly greater than other; pBool( false ) otherwise\npBool( true )\nterm\nother\npBool( false )\nparameter: other type: Term PInt\nother\nTerm<PInt>\nreturns: TermBool\nTermBool\nequivalent expression:\npgreaterEqInt.$( term ).$( other )\npgreaterEqInt.$( term ).$( other )\nreturns pBool( true ) if term is greater or equal to other; pBool( false ) otherwise\npBool( true )\nterm\nother\npBool( false )"
  },
  {
    "prompt": "TermBool?",
    "completion": "TermBool\ntype definition:\ntype TermBool = Term<PBool> & { readonly orTerm: TermFn<[PBool], PBool> readonly or: ( other: Term<PBool> ) => TermBool readonly andTerm: TermFn<[PBool], PBool> readonly and: ( other: Term<PBool> ) => TermBool}\ntype TermBool = Term<PBool> & { readonly orTerm: TermFn<[PBool], PBool> readonly or: ( other: Term<PBool> ) => TermBool readonly andTerm: TermFn<[PBool], PBool> readonly and: ( other: Term<PBool> ) => TermBool}\nparameter: other type: Term PBool\nother\nTerm<PBool>\nreturns TermBool\nTermBool\nequivalent expression:\npor.$( term ).$( other )\npor.$( term ).$( other )\nOR (||) boolean expression\n||\nparameter: other type: Term PBool\nother\nTerm<PBool>\nreturns TermBool\nTermBool\nequivalent expression:\npand.$( term ).$( other )\npand.$( term ).$( other )\nAND (&&) boolean expression\n&&"
  },
  {
    "prompt": "TermBS?",
    "completion": "TermBS\ntype definition:\ntype TermBS = Term<PByteString> & { readonly length: TermInt readonly utf8Decoded: TermStr readonly concatTerm: TermFn<[PByteString], PByteString> readonly concat: ( other: Term<PByteString>) => TermBS readonly prependTerm: TermFn<[PInt], PByteString> readonly prepend: ( byte: Term<PInt> ) => TermBS readonly subByteStringTerm: TermFn<[PInt, PInt], PByteString> readonly subByteString: ( fromInclusive: Term<PInt>, ofLength: Term<PInt> ) => TermBS readonly sliceTerm: TermFn<[PInt, PInt], PByteString> readonly slice: ( fromInclusive: Term<PInt>, toExclusive: Term<PInt> ) => TermBS readonly atTerm: TermFn<[PInt], PInt> readonly at: ( index: Term<PInt> ) => TermInt readonly eqTerm: TermFn<[PByteString], PBool> readonly eq: ( other: Term<PByteString> ) => TermBool readonly ltTerm: TermFn<[PByteString], PBool> readonly lt: ( other: Term<PByteString> ) => TermBool readonly ltEqTerm: TermFn<[PByteString], PBool> readonly ltEq: ( other: Term<PByteString> ) => TermBool readonly gtTerm: TermFn<[PByteString], PBool> readonly gt: ( other: Term<PByteString> ) => TermBool readonly gtEqTerm: TermFn<[PByteString], PBool> readonly gtEq: ( other: Term<PByteString> ) => TermBool}\ntype TermBS = Term<PByteString> & { readonly length: TermInt readonly utf8Decoded: TermStr readonly concatTerm: TermFn<[PByteString], PByteString> readonly concat: ( other: Term<PByteString>) => TermBS readonly prependTerm: TermFn<[PInt], PByteString> readonly prepend: ( byte: Term<PInt> ) => TermBS readonly subByteStringTerm: TermFn<[PInt, PInt], PByteString> readonly subByteString: ( fromInclusive: Term<PInt>, ofLength: Term<PInt> ) => TermBS readonly sliceTerm: TermFn<[PInt, PInt], PByteString> readonly slice: ( fromInclusive: Term<PInt>, toExclusive: Term<PInt> ) => TermBS readonly atTerm: TermFn<[PInt], PInt> readonly at: ( index: Term<PInt> ) => TermInt readonly eqTerm: TermFn<[PByteString], PBool> readonly eq: ( other: Term<PByteString> ) => TermBool readonly ltTerm: TermFn<[PByteString], PBool> readonly lt: ( other: Term<PByteString> ) => TermBool readonly ltEqTerm: TermFn<[PByteString], PBool> readonly ltEq: ( other: Term<PByteString> ) => TermBool readonly gtTerm: TermFn<[PByteString], PBool> readonly gt: ( other: Term<PByteString> ) => TermBool readonly gtEqTerm: TermFn<[PByteString], PBool> readonly gtEq: ( other: Term<PByteString> ) => TermBool}\nlength\nlength\nreturns TermInt\nTermInt\nequivalent expression:\nplengthBs.$( term )\nplengthBs.$( term )\nutf8Decoded\nutf8Decoded\nreturns TermStr\nTermStr\nequivalent expression:\npdecodeUtf8.$( term )\npdecodeUtf8.$( term )\nconcat\nconcat\nparameter: other type: Term PByteString\nother\nTerm<PByteString>\nreturns: TermBS\nTermBS\nequivalent expression:\npappendBs.$( term ).$( other )\npappendBs.$( term ).$( other )\nconcatenates the bytestring on which the method is defined on with the one passed as argument and returns a new bytestring as result of the operation\nprepend\nprepend\nparameter: byte type: Term PInt\nbyte\nTerm<PInt>\nreturns: TermBS\nTermBS\nequivalent expression:\npconsBs.$( byte ).$( term )\npconsBs.$( byte ).$( term )\nexpects the byte argument to be an integer in the range 0 = byte = 255\nbyte\n0 <= byte <= 255\nadds a single byte at the start of the term the method is defined on and returns a new bytestring as result.\nsubByteString\nsubByteString\nparameter: fromInclusive type: Term PInt\nfromInclusive\nTerm<PInt>\nparameter: ofLength type: Term PInt\nofLength\nTerm<PInt>\nreturns: TermBS\nTermBS\nequivalent expression:\npsliceBs.$( fromInclusive ).$( ofLength ).$( term )\npsliceBs.$( fromInclusive ).$( ofLength ).$( term )\ntakes fromInclusive as index of the first byte to include in the result and the expected length as ofLength as second parameter.\nfromInclusive\nofLength\nreturns ofLength bytes starting from the one at index fromInclusive.\nofLength\nfromInclusive\nsomewhat more efficient than slice as it maps directly to the builtin psliceBs function.\nslice\npsliceBs\nslice\nslice\nparameter: fromInclusive type: Term PInt\nfromInclusive\nTerm<PInt>\nparameter: toExclusive type: Term PInt\ntoExclusive\nTerm<PInt>\nreturns: TermBS\nTermBS\nequivalent expression:\npsliceBs.$( fromInclusive ).$( psub.$( toExclusive ).$( fromInclusive ) ).$( term )\npsliceBs.$( fromInclusive ).$( psub.$( toExclusive ).$( fromInclusive ) ).$( term )\ntakes fromInclusive as index of the first byte to include in the result and toExclusive as the index of the first byte to exclude\nfromInclusive\ntoExclusive\nreturns the bytes specified in the range\nat\nat\nparameter: index type: Term PInt\nindex\nTerm<PInt>\nreturns: TermInt\nTermInt\nequivalent expression:\npindexBs.$( term ).$( index )\npindexBs.$( term ).$( index )\nreturns an integer in range 0 = byte = 255 representing the byte at position index\n0 <= byte <= 255\nindex\neq\neq\nparameter: other type: Term PByteString\nother\nTerm<PByteString>\nreturns: TermBool\nTermBool\nequivalent expression:\npeqBs.$( term ).$( other )\npeqBs.$( term ).$( other )\nbytestring equality\nlt\nlt\nparameter: other type: Term PByteString\nother\nTerm<PByteString>\nreturns: TermBool\nTermBool\nequivalent expression:\nplessBs.$( term ).$( other )\nplessBs.$( term ).$( other )\nreturns pBool( true ) if term is strictly less than other; pBool( false ) otherwise\npBool( true )\nterm\nother\npBool( false )\nbytestrings are ordered lexicographically\nmeaning that two strings are compared byte by byte\nif the the byte of the first bytestring is less than the byte of the second; the first is considered less;\nif it the two bytes are equal it checks the next byte\nif the second is less than the first; the second is considered less;\nltEq\nltEq\nparameter: other type: Term PByteString\nother\nTerm<PByteString>\nreturns: TermBool\nTermBool\nequivalent expression:\nplessEqBs.$( term ).$( other )\nplessEqBs.$( term ).$( other )\nreturns pBool( true ) if term is less or equal than other; pBool( false ) otherwise\npBool( true )\nterm\nother\npBool( false )\ngt\ngt\nparameter: other type: Term PByteString\nother\nTerm<PByteString>\nreturns: TermBool\nTermBool\nequivalent expression:\npgreaterBS.$( term ).$( other )\npgreaterBS.$( term ).$( other )\nreturns pBool( true ) if term is strictly greater than other; pBool( false ) otherwise\npBool( true )\nterm\nother\npBool( false )\ngtEq\ngtEq\nparameter: other type: Term PByteString\nother\nTerm<PByteString>\nreturns: TermBool\nTermBool\nequivalent expression:\npgreaterEqBS.$( term ).$( other )\npgreaterEqBS.$( term ).$( other )\nreturns pBool( true ) if term is greater or equal than other; pBool( false ) otherwise\npBool( true )\nterm\nother\npBool( false )\nlength\nutf8Decoded\nconcat\nprepend\nsubByteString\nslice\nat\neq\nlt\nltEq\ngt\ngtEq"
  },
  {
    "prompt": "TermStr?",
    "completion": "TermStr\ntype definition:\ntype TermStr = Term<PString> & { readonly utf8Encoded: TermBS readonly concatTerm: TermFn<[ PString ], PString> readonly concat: ( other: Term<PString> ) => TermStr readonly eqTerm: TermFn<[ PString ], PBool > readonly eq: ( other: Term<PString> ) => TermBool}\ntype TermStr = Term<PString> & { readonly utf8Encoded: TermBS readonly concatTerm: TermFn<[ PString ], PString> readonly concat: ( other: Term<PString> ) => TermStr readonly eqTerm: TermFn<[ PString ], PBool > readonly eq: ( other: Term<PString> ) => TermBool}\nutf8Encoded\nutf8Encoded\nreturns TermStr\nTermStr\nequivalent expression:\npencodeUtf8.$( term )\npencodeUtf8.$( term )\nconcat\nconcat\nparameter: other type: Term PString\nother\nTerm<PString>\nreturns: TermStr\nTermStr\nequivalent expression:\npappendStr.$( term ).$( other )\npappendStr.$( term ).$( other )\nreturns the result of concatenating the term on which the method is defined on and the other argument,\nother\neq\neq\nparameter: other type: Term PString\nother\nTerm<PString>\nreturns: TermBool\nTermBool\nequivalent expression:\npeqStr.$( term ).$( other )\npeqStr.$( term ).$( other )\nstring equality\nutf8Encoded\nconcat\neq"
  },
  {
    "prompt": "TermPairPFstT,PSndT?",
    "completion": "TermPair<PFstT,PSndT>\ntype definition:\ntype TermPair<PFst extends PType, PSnd extends PType> = Term<PPair<PFst,PSnd>> & { readonly fst: UtilityTermOf<PFst> readonly snd: UtilityTermOf<PSnd> }\ntype TermPair<PFst extends PType, PSnd extends PType> = Term<PPair<PFst,PSnd>> & { readonly fst: UtilityTermOf<PFst> readonly snd: UtilityTermOf<PSnd> }\nfst\nhead\nreturns: UtilityTermOf PFstT\nUtilityTermOf<PFstT>\nequivalent expression:\npfstPair( fstT, sndT ).$( term )\npfstPair( fstT, sndT ).$( term )\nreturns the first element of the pair\nsnd\nsnd\nreturns: UtilityTermOf PSndT\nUtilityTermOf<PSndT>\nequivalent expression:\npsndPair( fstT, sndT ).$( term )\npsndPair( fstT, sndT ).$( term )\nreturns the second element of the pair\nfst\nsnd"
  },
  {
    "prompt": "TermFnPIns,POut?",
    "completion": "TermFn<PIns[],POut>\nThe type definition of TermFn is more complex than what it actually does; but that is only because it automatically handles functions with an unspecified (potentially infinite) number of parameters.\nTermFn\nAll it does tough is just adding the \"$\" method that replaces the papp call.\n$\npapp\nTo give an idea here how the case of a function from a single input to a single output looks like,\nwe'll call this type TermLam even if there's no type called so in plu-ts\nTermLam\nplu-ts\ntype TermLam<PIn extends PType, POut extends PType> = Term<PLam<PIn,POut>> & { $: ( input: Term<PIn> ) => Term<POut> }\ntype TermLam<PIn extends PType, POut extends PType> = Term<PLam<PIn,POut>> & { $: ( input: Term<PIn> ) => Term<POut> }"
  },
  {
    "prompt": "TermStructStructDef?",
    "completion": "TermStruct<StructDef>\nTermStruct is an other type that is unnecessarily complicated.\nTermStruct\nThis time because it has to mess around with the struct definition; but even so the type definition should not be that hard to understand if we know what is doing\ntype StructInstance<SCtorDef extends StructCtorDef> = { readonly [Field in keyof SCtorDef]: UtilityTermOf<ToPType<SCtorDef[Field]>>}type TermStruct<SDef extends StructDefinition> = Term<PStruct<SDef>> & { readonly eqTerm: TermFn<[PStruct<SDef>], PBool> readonly eq: ( other: Term<PStruct<SDef>> ) => TermBool} & IsSingelKey<SDef> extends true ? StructInstance<SDef[keyof SCtorDef]> : {};\ntype StructInstance<SCtorDef extends StructCtorDef> = { readonly [Field in keyof SCtorDef]: UtilityTermOf<ToPType<SCtorDef[Field]>>}type TermStruct<SDef extends StructDefinition> = Term<PStruct<SDef>> & { readonly eqTerm: TermFn<[PStruct<SDef>], PBool> readonly eq: ( other: Term<PStruct<SDef>> ) => TermBool} & IsSingelKey<SDef> extends true ? StructInstance<SDef[keyof SCtorDef]> : {};\nEven with these simplifications it might seem a bit complex but really all is telling us is that it adds the struct properties (trough Structinstance) only if the struct can only have one single constructor; and adds nothing if it has more.\nStructinstance\nIn fact we already encountered this method while introducing pmatch; we just didn't know that it was an utility term.\npmatch\nIt then adds the eq method regardless of the struct definition.\neq\neq\neq\nparameter: other type: Term PStruct SDef\nother\nTerm<PStruct<SDef>>\nreturns: TermBool\nTermBool\nequivalent expression:\npeqData.$( term as any ).$( other as any )\npeqData.$( term as any ).$( other as any )\nData equality\neq"
  },
  {
    "prompt": "types?",
    "completion": "9 items\n2 items\n3 items"
  },
  {
    "prompt": "utilities?",
    "completion": "Once we have our contract we need to transform it in something that the cardano node understands.\nThis method is deprecated as of Plutus V3\nThis method is deprecated as of Plutus V3"
  },
  {
    "prompt": "buildSync?",
    "completion": "ITxBuildArgs\ninterface ITxBuildArgs { inputs: [ ITxBuildInput, ...ITxBuildInput[] ], // TxBuildInput[] with length >= 1 changeAddress?: Address | AddressStr, change?: ChangeInfos; outputs?: ITxBuildOutput[], readonlyRefInputs?: UTxO[], requiredSigners?: PubKeyHash[], collaterals?: UTxO[], collateralReturn?: ITxBuildOutput, mints?: ITxBuildMint[], invalidBefore?: CanBeUInteger, invalidAfter?: CanBeUInteger, certificates?: ITxBuildCert[], withdrawals?: ITxBuildWithdrawal[], metadata?: TxMetadata, protocolUpdateProposal?: ProtocolUpdateProposal}\ninterface ITxBuildArgs { inputs: [ ITxBuildInput, ...ITxBuildInput[] ], // TxBuildInput[] with length >= 1 changeAddress?: Address | AddressStr, change?: ChangeInfos; outputs?: ITxBuildOutput[], readonlyRefInputs?: UTxO[], requiredSigners?: PubKeyHash[], collaterals?: UTxO[], collateralReturn?: ITxBuildOutput, mints?: ITxBuildMint[], invalidBefore?: CanBeUInteger, invalidAfter?: CanBeUInteger, certificates?: ITxBuildCert[], withdrawals?: ITxBuildWithdrawal[], metadata?: TxMetadata, protocolUpdateProposal?: ProtocolUpdateProposal}\nITxBuildArgs is the interface that is used by txBuilder.buildSync to understand how to build a Tx.\nITxBuildArgs\ntxBuilder.buildSync\nTx\nThe reuired arguments are inputs and either a change output or only a changeAddress needed for automatic fee calculation.\ninputs\nchange\nchangeAddress\nall the remaining fields are optional.\noutputs\nthe outputs is optional too\noutputs\nif no outputs are specified all the input value is sent back to change.address (or changeAddress if no change is specified);\noutputs\nchange.address\nchangeAddress\nchange\ninputs\ntype: ITxBuildInput[]\nITxBuildInput[]\na single input is described using ITxBuildInput\nITxBuildInput\ninterface ITxBuildInput { utxo: UTxO, referenceScriptV2?: { refUtxo: UTxO, datum: CanBeData | \"inline\", redeemer: CanBeData, } inputScript?: { script: Script, datum: CanBeData | \"inline\", redeemer: CanBeData }}\ninterface ITxBuildInput { utxo: UTxO, referenceScriptV2?: { refUtxo: UTxO, datum: CanBeData | \"inline\", redeemer: CanBeData, } inputScript?: { script: Script, datum: CanBeData | \"inline\", redeemer: CanBeData }}\nutxo\nrequired field, expects an instance of UTxO\nUTxO\nchangeAddress\nan instance of Address or a bech32 encoded address (starting with \"addr1\" or \"addr_test1\" if in testnet);\nAddress\n\"addr1\"\n\"addr_test1\"\nwill add an output to the specified address (in the last position in tx outputs ordering).\nchange\nlike changeAddress but with more control over the output\nchangeAddress\nit also allows to set a datum and a refScript for the output\ndatum\nrefScript\nof course no value can be specified as it is calculated by the TxBuilder\nTxBuilder\noutputs\nan output is described using ITxBuildOutput\nITxBuildOutput\ninterface ITxBuildOutput { address: Address, value: Value, datum?: Hash32 | CanBeData refScript?: Script}\ninterface ITxBuildOutput { address: Address, value: Value, datum?: Hash32 | CanBeData refScript?: Script}\nit requires an Address and a Value;\nAddress\nValue\noptionally a datum which can be either an Hash32, anything Data-like. or undefined\ndatum\nHash32\nData\nundefined\nif undefined no datum is attached. if instance of Hash32 the hash is attached in Plutus V1 style if anything Data-like an inline datum is attached (CIP-0032)\nundefined\nHash32\nData\nand the optional refScript\nrefScript\nif undefined no script is attached. if instance of Script, the script is attached to the resulting UTxO (CIP-0033)\nundefined\nScript\nUTxO\nreadonlyRefInputs\nUTxO[]\nUTxO[]\nany addtional reference inputs CIP-0031\nrequiredSigners\nPubKeyHash[]\nPubKeyHash[]\nset of signers required by the transaction.\nthis field is the one esposed in the ScriptContext of a smart contract\nScriptContext\ncollaterals\nUTxO[]\nUTxO[]\ncollateral inputs needed for smart contract validation.\ncollateralReturn\nITxBuildOutput[]\nITxBuildOutput[]\noutputs specifying the return value from collaterals\ncollaterals\nmints\ninterface ITxBuildMint { value: Value script: { inline: Script policyId: Hash32 redeemer: CanBeData } | { ref: UTxO policyId: Hash32 redeemer: CanBeData }}\ninterface ITxBuildMint { value: Value script: { inline: Script policyId: Hash32 redeemer: CanBeData } | { ref: UTxO policyId: Hash32 redeemer: CanBeData }}\narray of tokens to be minted or burned and respective minting policies.\nvalue MUST have a single entry\nvalue\ninvalidBefore\ntype CanBeUInteger = number | bigint\ntype CanBeUInteger = number | bigint\nthe slot number after wich the transaction can be submited.\ninvalidAfter\ntype CanBeUInteger = number | bigint\ntype CanBeUInteger = number | bigint\nthe slot number after wich the transaction can is rejected.\ncertificates\ninterface ITxBuildCert { cert: AnyCertificate script?: { inline: Script redeemer: CanBeData } | { ref: UTxO redeemer: CanBeData }}\ninterface ITxBuildCert { cert: AnyCertificate script?: { inline: Script redeemer: CanBeData } | { ref: UTxO redeemer: CanBeData }}\narray of certificates to include in the transaction and respective (optional) stake validator scripts\ncertificates\ninterface interface ITxBuildWithdrawal { withdrawal: { rewardAccount: Hash28 | StakeAddress, amount: Coin }, script?: { inline: Script redeemer: CanBeData } | { ref: UTxO redeemer: CanBeData }}\ninterface interface ITxBuildWithdrawal { withdrawal: { rewardAccount: Hash28 | StakeAddress, amount: Coin }, script?: { inline: Script redeemer: CanBeData } | { ref: UTxO redeemer: CanBeData }}\narray of withdrawals to include in the transaction and respective (optional) stake validator scripts\nmetadata\ntype ITxMetadata = { [metadatum_label: number | string]: TxMetadatum }class TxMetadata{ constructor(metadata: ITxMetadata) { // ... }}\ntype ITxMetadata = { [metadatum_label: number | string]: TxMetadatum }class TxMetadata{ constructor(metadata: ITxMetadata) { // ... }}\nany metadata to include in the transaction\nprotocolUpdateProposal\ntype ProtocolParametersUpdateMap = { genesisHash: GenesisHash changes: Partial<ProtocolParamters>}[]type ProtocolUpdateProposal = [ ProtocolParametersUpdateMap, Epoch ];\ntype ProtocolParametersUpdateMap = { genesisHash: GenesisHash changes: Partial<ProtocolParamters>}[]type ProtocolUpdateProposal = [ ProtocolParametersUpdateMap, Epoch ];\nprotocol update proposal to include in the transaciton.\nITxBuildArgs\ninputs\nchangeAddress\nchange\noutputs\nreadonlyRefInputs\nrequiredSigners\ncollaterals\ncollateralReturn\nmints\ninvalidBefore\ninvalidAfter\ncertificates\ncertificates\nmetadata\nprotocolUpdateProposal"
  },
  {
    "prompt": "runWithProvider?",
    "completion": "runWithProvider\nrunWithProvider( provider: Partial<ITxRunnerProvider> ): TxBuilderRunner\nrunWithProvider( provider: Partial<ITxRunnerProvider> ): TxBuilderRunner\ngiven a Partial ITxRunnerProvider returns a TxBuilderRunner\nPartial\nITxRunnerProvider\nTxBuilderRunner\nPartial implies that none of the methods specified in ITxRunnerProvider are really required.\nPartial\nITxRunnerProvider\na TxBuilderRunner instance will do its best to minimize calls to the provider; that means that if all the data needed is already present (as in the case of the buildSync method) the provider is not needed.\nTxBuilderRunner\nbuildSync\nso an empty object ({}) is a valid provider.\n{}\nThe advantage of using runWithProvider with an empty provider over using directly buildSync is an even higher level interface to build transaction, which might turn useful for complex transactions.\nrunWithProvider\nbuildSync\nThe disadvantages are that the TxBuilderRunner methods might throw an error if some data that needs to be resolved (e.g. datum hashes or utxo references) is not present;\nTxBuilderRunner\nso you will have to make sure you resolve your utxos and datums."
  },
  {
    "prompt": "keepRelevant?",
    "completion": "keepRelevant\nkeepRelevant( requestedOutputSet: Value | ValueUnits, initialUTxOSet: ITxBuildInput[], minimumLovelaceRequired: number | bigint = 5_000_000,): ITxBuildInput[]\nkeepRelevant( requestedOutputSet: Value | ValueUnits, initialUTxOSet: ITxBuildInput[], minimumLovelaceRequired: number | bigint = 5_000_000,): ITxBuildInput[]\nrequestedOutputSet\nValue\ninitialUTxOSet\nITxBuildInput\nminimumLovelaceRequired\nnumber\nbigint\ncoin selection algorithm."
  },
  {
    "prompt": "calcLinearFee?",
    "completion": "calcLinearFee\ncalcLinearFee( tx: Tx ): bigint\ncalcLinearFee( tx: Tx ): bigint\ntx\nTx\ngiven a transaction, calculates the minFee based on the size and the protocol parameters\nthe fee calculated by this method does not include the execution costs of eventual plutus scripts"
  },
  {
    "prompt": "getMinimumOutputLovelaces?",
    "completion": "getMinimumOutputLovelaces\ngetMinimumOutputLovelaces( tx_out: TxOut ): bigint\ngetMinimumOutputLovelaces( tx_out: TxOut ): bigint\ntx_out\nTxOut\ngiven a transaction output, calculates the minUtxo based on the size and the protocol parameters."
  },
  {
    "prompt": "setGenesisInfos?",
    "completion": "setGenesisInfos\nsetGenesisInfos!: ( geneisInfos: GenesisInfos ) => void;\nsetGenesisInfos!: ( geneisInfos: GenesisInfos ) => void;\ngeneisInfos\nGenesisInfos\nSets the genesisInfos property.\ngenesisInfos"
  },
  {
    "prompt": "slotToPOSIX?",
    "completion": "slotToPOSIX\nslotToPOSIX( slot: number | bigint ): number\nslotToPOSIX( slot: number | bigint ): number\nslot\nnumber\nbigint\ngiven a slot number returns the equivalent POSIX time based on the GenesisInfos\nGenesisInfos\nif no genesis infos are set the method throws an Error;\nError\nyou can set the genesis infos using the setGenesisInfos method.\nsetGenesisInfos"
  },
  {
    "prompt": "posixToSlot?",
    "completion": "posixToSlot\nposixToSlot( POSIX: `number` | `bigint` ): number\nposixToSlot( POSIX: `number` | `bigint` ): number\nPOSIX\nnumber\nbigint\ngiven a POSIX time returns the equivalent slot number based on the GenesisInfos\nGenesisInfos\nif no genesis infos are set the method throws an Error;\nError\nyou can set the genesis infos using the setGenesisInfos method.\nsetGenesisInfos"
  },
  {
    "prompt": "overrideTxRedeemers?",
    "completion": "overrideTxRedeemers\noverrideTxRedeemers( tx: Tx, newRedeemers: TxRedeemer[] ): Tx\noverrideTxRedeemers( tx: Tx, newRedeemers: TxRedeemer[] ): Tx\ntx\nTx\nnewRedeemers\nTxRedeemer\nReplaces the redeemers and clears vkeyWitnesses in the witness set and re-computes the scriptDataHash in the body\nscriptDataHash\nThis might be needed in some rare cases where the plutus script calculation is offset by some units.\nThe input transaction is readonly and is not modified.\nA NEW TRANSACTION IS CREATED with vkey witness set empty (the new transaction is unsigned)\nto summarize, the new transaction differs in:\ntx.body.scriptDataHash\ntx.witnesses.redeemers\ntx.witnesses.vkeyWitnesses\nempty vkeyWitnesses implies any signature present in the input transaction is discarded\nthis is because the transaction body changed, so the signature would be invalid.\nif you use this method make sure to request the user to sign the transaciton ONLY AFTER modifying redeemers"
  },
  {
    "prompt": "TxBuilderRunner?",
    "completion": "TxBuilderRunner\nclass TxBuilderRunner{ constructor( txBuilder: TxBuilder, provider: Partial<ITxRunnerProvider> )}\nclass TxBuilderRunner{ constructor( txBuilder: TxBuilder, provider: Partial<ITxRunnerProvider> )}\nThe TxBuilderRunner is an abstraction over the TxBuilder.\nTxBuilderRunner\nTxBuilder\nTo get TxBuilderRunner you will infact need a TxBuilder and some Partial ITxRunnerProvider .\nTxBuilderRunner\nTxBuilder\nPartial\nITxRunnerProvider\nFor this reason, while there is nothing wrong in creating a TxBuilderRunner directly calling the constructor; it is suggested to use the runWithProvider method on a TxBuilder instance to create one instead.\nTxBuilderRunner\nrunWithProvider\nTxBuilder\nThe ITxRunnerProvider is Partial because a TxBuilderRunner instance will do its best to minimize calls to the provider, so if used properly, it is not needed.\nITxRunnerProvider\nPartial\nTxBuilderRunner\nFor a more detialed explanation on how the provider works please see the runWithProvider documentation.\nrunWithProvider\nbuild\nreset\naddRequiredSigner\naddRequiredSignerKey\nattachValidator\nattachMetadata\nattachMetadataJson\nattachMetadataJsonWithConversion\nsetChangeAddress\nsetCollateral\nsetCollateralAmount\naddInputs\naddInput\npayTo\ndelegateTo\nderegisterStake\nmintAssets\nwithdraw\nregisterPool\nretirePool\nregisterStake\nregisterStakeAddress\nreferenceUtxos\nvalidFrom\nvalidFromSlot\ninvalidBeforeSlot\nvalidTo\nvalidToSlot\ninvalidAfterSlot"
  },
  {
    "prompt": "IProvider?",
    "completion": "ITxRunnerProvider\nOnly a subset of a IProvider methods might be needed by a TxBuilderRunner;\nIProvider\nTxBuilderRunner\nso here is the ITxRunnerProvider interface:\nITxRunnerProvider\ninterface ITxRunnerProvider extends IGetGenesisInfos, IResolveUTxOs, IResolveDatumHashes, Partial<IGetChangeAddress>{}\ninterface ITxRunnerProvider extends IGetGenesisInfos, IResolveUTxOs, IResolveDatumHashes, Partial<IGetChangeAddress>{}\nITxRunnerProvider\ngetGenesisInfos\nresolveUtxos\nresolveDatumHashes\noptionally:\ngetChangeAddress\nIProvider\ndefinition:\ninterface IProvider extends IGetGenesisInfos, IGetProtocolParameters, IResolveUTxOs, IResolveDatumHashes, ISubmitTx, ISignTx, Partial<IGetChangeAddress>{}\ninterface IProvider extends IGetGenesisInfos, IGetProtocolParameters, IResolveUTxOs, IResolveDatumHashes, ISubmitTx, ISignTx, Partial<IGetChangeAddress>{}\nIGetGenesisInfos\ninterface IGetGenesisInfos { getGenesisInfos: () => Promise<GenesisInfos>}\ninterface IGetGenesisInfos { getGenesisInfos: () => Promise<GenesisInfos>}\nIGetProtocolParameters\ninterface IGetProtocolParameters { getProtocolParameters: () => Promise<ProtocolParameters>}\ninterface IGetProtocolParameters { getProtocolParameters: () => Promise<ProtocolParameters>}\nIResolveUTxOs\ninterface IResolveUTxOs { resolveUtxos: ( utxos: CanResolveToUTxO[] ) => Promise<UTxO[]>,}\ninterface IResolveUTxOs { resolveUtxos: ( utxos: CanResolveToUTxO[] ) => Promise<UTxO[]>,}\nIResolveDatumHashes\ninterface IResolveDatumHashes { resolveDatumHashes: ( hashes: Hash32[] ) => Promise<{ hash: string, datum: CanBeData }[]>}\ninterface IResolveDatumHashes { resolveDatumHashes: ( hashes: Hash32[] ) => Promise<{ hash: string, datum: CanBeData }[]>}\nISubmitTx\ninterface ISubmitTx { submitTx: ( txCBOR: string ) => Promise<string> }\ninterface ISubmitTx { submitTx: ( txCBOR: string ) => Promise<string> }\nISignTx\ninterface ISignTx { signTx: ( txCBOR: string ) => Promise<string> }\ninterface ISignTx { signTx: ( txCBOR: string ) => Promise<string> }\nIGetChangeAddress\ninterface IGetChangeAddress { getChangeAddress: () => Promise<AddressStr | Address>}\ninterface IGetChangeAddress { getChangeAddress: () => Promise<AddressStr | Address>}\ngetGenesisInfos\nreturns: Promise GenesisInfos\nPromise\nGenesisInfos\nused to query genesis infos if none are already present.\ngenesis infos are only needed in case invalidBefore or invalidAfter are used.\ninvalidBefore\ninvalidAfter\nnot needed otherwise.\ngetProtocolParameters\nreturns: Promise ProtocolParameters\nPromise\nProtocolParameters\nutility method of a provider to query protocol parameters.\nNOT REQUIRED by ITxRunnerProvider;\nITxRunnerProvider\nresolveUtxos\nargument: CanResolveToUTxO[]\nCanResolveToUTxO\nreturns: Promise UTxO[]\nPromise\nUTxO\ngiven an array of utxo references to resolve expects an array of UTxOs back.\nUTxO\nA TxBuilderRunner instance won't require this method if the utxos needed:\nTxBuilderRunner\nUTxO\nIUTxO\nresolveDatumHashes\nargument: Hash32[]; hashes of the datums to be resolved\nHash32\nreturns: Promise { hash: string, datum: CanBeData }[]\nPromise\nstring\nCanBeData\ngiven an array of datum hashes queries the respective datums.\nonly needed if no datum for a given hash is known.\nA TxBuilderRunner instance won't require this method if all the datums are provided as Data\nTxBuilderRunner\nData\ngetChangeAddress\nprovides a default changeAddress if none is specified.\nchangeAddress\nITxRunnerProvider\nITxRunnerProvider\nIProvider\nIGetGenesisInfos\nIGetProtocolParameters\nIResolveUTxOs\nIResolveDatumHashes\nISubmitTx\nISignTx\nIGetChangeAddress\ngetGenesisInfos\ngetProtocolParameters\nresolveUtxos\nresolveDatumHashes\ngetChangeAddress"
  },
  {
    "prompt": "build?",
    "completion": "build\nreadonly build:() => Promise<Tx>\nreadonly build:() => Promise<Tx>\nif any unresolved data was passed it is resolved via the provider passed;\nif the method needed are not present on the provider throws an Error;\nError\nfinalizes the TxBuilderRunner instance, so that it can be re-used for other transactions, and returns a Tx instance\nTxBuilderRunner\nTx"
  },
  {
    "prompt": "reset?",
    "completion": "reset\nreadonly reset: () => TxBuilderRunner\nreadonly reset: () => TxBuilderRunner\nclears the TxBuilderRunner instance, so that it can be re-used for other transactions, making sure no other action where specified\nTxBuilderRunner\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "addRequiredSigner?",
    "completion": "addRequiredSigner\nreadonly addRequiredSigner!: ( signer: Address | StakeAddress | AddressStr | StakeAddressBech32) => TxBuilderRunner\nreadonly addRequiredSigner!: ( signer: Address | StakeAddress | AddressStr | StakeAddressBech32) => TxBuilderRunner\nsigner\nAddress\nStakeAddress\nAddressStr\nStakeAddressBech32\nadds the all credentials of the address to the requiredSigners field of a Tx instance.\nrequiredSigners\nTx\nonly the signers included in that field are passed to a contract's ScriptContext.\nScriptContext\nthat includes payment credentials and, if present, stake credentials.\nif you have an address with both payment and stake credentials, but wish only to include one of them, consider using the addRequiredSignerKey method.\naddRequiredSignerKey\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "addRequiredSignerKey?",
    "completion": "addRequiredSignerKey\nreadonly addRequiredSignerKey: ( signerKey: Hash28 ) => TxBuilderRunner\nreadonly addRequiredSignerKey: ( signerKey: Hash28 ) => TxBuilderRunner\nsigner\nHash28\nadds the given key hash to the requiredSigners field of a Tx instance.\nrequiredSigners\nTx\nonly the signers included in that field are passed to a contract's ScriptContext.\nScriptContext\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "attachValidator?",
    "completion": "attachValidator\nreadonly attachValidator!: ( validator: Script<PlutusScriptType> ) => TxBuilderRunner\nreadonly attachValidator!: ( validator: Script<PlutusScriptType> ) => TxBuilderRunner\nvalidator\nScript\nincludes the script in the witnesses field of the resulting Tx\nwitnesses\nTx\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "attachMetadata?",
    "completion": "attachMetadata\nreadonly attachMetadata!: ( label: number | bigint, metadata: TxMetadatum) => TxBuilderRunner\nreadonly attachMetadata!: ( label: number | bigint, metadata: TxMetadatum) => TxBuilderRunner\nlabel\nnumber\nbigint\nmetadata\nTxMetadatum\nadds a metadata entry for the given label, or overrides if the same label was already present.\nlabel\nlabel\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "attachMetadataJson?",
    "completion": "attachMetadataJson\nreadonly attachMetadataJson!: label: numebr | bigint, metadataJson: any) => TxBuilderRunner\nreadonly attachMetadataJson!: label: numebr | bigint, metadataJson: any) => TxBuilderRunner\nlabel\nnumber\nbigint\nmetadataJson\nany\nlike attachMetadata, adds a metadata entry for the given label, or overrides if the same label was already present.\nattachMetadata\nlabel\nlabel\nmetadataJson is a jsavascript value converted as follows\nmetadataJson\nobject\nTxMetadatumMap\narray\nTxMetadatumList\nstring\nTxMetadatumText\nattachMetadataJsonWithConversion\nTxMetadatumBytes\nattachMetadata\nnumber\nTxMetadatumInt\nbigint\nTxMetadatumInt\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "attachMetadataJsonWithConversion?",
    "completion": "attachMetadataJson\nreadonly attachMetadataJson!: ( label: number | bigint, metadataJson: any) => TxBuilderRunner\nreadonly attachMetadataJson!: ( label: number | bigint, metadataJson: any) => TxBuilderRunner\nlabel\nnumber\nbigint\nmetadataJson\nany\nlike attachMetadata, adds a metadata entry for the given label, or overrides if the same label was already present.\nattachMetadata\nlabel\nlabel\nmetadataJson is a jsavascript value converted as follows\nmetadataJson\nobject\nTxMetadatumMap\narray\nTxMetadatumList\nstring\nTxMetadatumText\nattachMetadataJsonWithConversion\nTxMetadatumBytes\nattachMetadata\nnumber\nTxMetadatumInt\nbigint\nTxMetadatumInt\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "setChangeAddress?",
    "completion": "setChangeAddress\nreadonly setChangeAddress!: ( changeAddr: Address | AddressStr ) => TxBuilderRunner\nreadonly setChangeAddress!: ( changeAddr: Address | AddressStr ) => TxBuilderRunner\nchangeAddr\nAddress\nAddressStr\nexplicitly sets the change address;\nif missing, an attempt to call the ITxRunnerProvider getChangeAddress method is done\nITxRunnerProvider\ngetChangeAddress\nif still missing the first input's address with PubKeyHash payment credentials (not script) will be used\nPubKeyHash\nif all the above fail, a call to the build method will throw an Error.\nbuild\nError\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "setCollateral?",
    "completion": "setCollateral\nreadonly setCollateral!: ( collateral: CanResolveToUTxO, collateralOutput?: ITxOut ) => TxBuilderRunner\nreadonly setCollateral!: ( collateral: CanResolveToUTxO, collateralOutput?: ITxOut ) => TxBuilderRunner\ncollateral\nCanResolveToUTxO\ncollateralOutput\nITxOut\nTxOut\nSets the collateral input, and optionally output, for a transaction.\nIf this method is not used, but the transaction needs collateral due to the presence of a plutus script, the TxBuilderRunner instance will try to use one of the normal inputs as collateral, see setCollateralAmount for more infos.\nTxBuilderRunner\nsetCollateralAmount\ncollateral can either be a resolved UTxO or an unresolved ITxOutRef\ncollateral\nUTxO\nITxOutRef\nin case it is an unresolved ITxOutRef a call to the ITxRunnerProvider resolveUtxos method is done in the build method; if resolveUtxos is missing on the provider the build method will throw an Error.\nITxOutRef\nITxRunnerProvider\nresolveUtxos\nbuild\nresolveUtxos\nbuild\nError\nan additional collateralOutput may be specified.\ncollateralOutput\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "addInputs?",
    "completion": "addInputs\nreadonly addInputs!: ( utxos: CanResolveToUTxO[] ) => TxBuilderRunner\nreadonly addInputs!: ( utxos: CanResolveToUTxO[] ) => TxBuilderRunner\nutxos\nCanResolveToUTxO\nadds the given utxos to the transaction inputs; the elements of the array that don't satisfy the IUTxO interface will be resolved using the provider resolveUtxos method.\nutxos\nIUTxO\nresolveUtxos\nthis method does not allow to specify plutus realated arguments.\nfor inputs that need redeemers, scripts and datums use addInput.\naddInput\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "addInput?",
    "completion": "addInput\nreadonly addInput!: ( utxo: CanResolveToUTxO, redeemer?: CanBeData, script_or_ref?: CanResolveToUTxO | Script, datum?: CanBeData | \"inline\") => TxBuilderRunner\nreadonly addInput!: ( utxo: CanResolveToUTxO, redeemer?: CanBeData, script_or_ref?: CanResolveToUTxO | Script, datum?: CanBeData | \"inline\") => TxBuilderRunner\nutxutxoos\nCanResolveToUTxO\nredeemer\nCanBeData\nundefined\nscript_or_ref\nCanResolveToUTxO\nScript\nundefined\ndatum\nCanBeData\n\"inline\"\nundefined\nadds the given utxo to the transaction inputs; ifutxo doesn't satisfy the IUTxO interface it will be resolved using the provider resolveUtxos method.\nutxo\nutxo\nIUTxO\nresolveUtxos\nredeemer and script_or_ref must be specified together; if datum is missing defaults to \"inline\".\nredeemer\nscript_or_ref\ndatum\n\"inline\"\nif script_or_ref is a Script it will be included in the witnesses field of the resulting Tx;\nscript_or_ref\nScript\nwitnesses\nTx\nif script_or_ref satisfies the IUTxO interface it will be used as reference input to provide the attached reference script (build fails if missing)\nscript_or_ref\nIUTxO\nbuild\nif script_or_ref satisfies the ITxOutRef interface or the TxOutRefStr type alias it will be resolved using the provider resolveUtxos method and it will be used as reference input to provide the attached reference script (build fails if missing)\nscript_or_ref\nITxOutRef\nTxOutRefStr\nresolveUtxos\nbuild\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "payTo?",
    "completion": "payTo\nreadonly payTo: ( address: Address | AddressStr, amount: number | bigint | Value, datum?: CanBeData, refScript?: Script) => TxBuilderRunner\nreadonly payTo: ( address: Address | AddressStr, amount: number | bigint | Value, datum?: CanBeData, refScript?: Script) => TxBuilderRunner\naddress\nAddress\nAddressStr\namount\nnumber\nbigint\nValue\ndatum\nCanBeData\nrefScript\nScript\nadds a transaction output.\nif amount is number or bigint it is intended to be lovelaces only.\namount\nnumber\nbigint\nif datum is present is always added as inline datum.\ndatum\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "delegateTo?",
    "completion": "delegateTo\nreadonly delegateTo!:( delegator: CanBeStakeCreds, poolId: CanBePoolKeyHash, redeemer?: CanBeData, script_or_ref?: Script | CanResolveToUTxO) => TxBuilderRunner\nreadonly delegateTo!:( delegator: CanBeStakeCreds, poolId: CanBePoolKeyHash, redeemer?: CanBeData, script_or_ref?: Script | CanResolveToUTxO) => TxBuilderRunner\ndelegator\nCanBeStakeCreds\npoolId\nCanBePoolKeyHash\nredeemer\nCanBeData\nundefined\nscript_or_ref\nScript\nCanResolveToUTxO\nundefined\nadds a delegation certificate,\nredeemer and script_or_ref must be specified together; they are required if delegator is a script.\nredeemer\nscript_or_ref\ndelegator\nif script_or_ref is CanResolveToUTxO it will be used as reference script;\nscript_or_ref\nCanResolveToUTxO\nif script_or_ref is Script it will be used as script witness;\nscript_or_ref\nScript\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "deregisterStake?",
    "completion": "deregisterStake\nreadonly deregisterStake!:( delegator: CanBeStakeCreds, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner\nreadonly deregisterStake!:( delegator: CanBeStakeCreds, redeemer?: CanBeData, script_or_ref?: Script<PlutusScriptType> | CanResolveToUTxO) => TxBuilderRunner\ndelegator\nCanBeStakeCreds\nredeemer\nCanBeData\nundefined\nscript_or_ref\nScript\nCanResolveToUTxO\nundefined\nadds a de-registration certificate,\nredeemer and script_or_ref must be specified together; they are required if delegator is a script.\nredeemer\nscript_or_ref\ndelegator\nif script_or_ref is CanResolveToUTxO it will be used as reference script;\nscript_or_ref\nCanResolveToUTxO\nif script_or_ref is Script it will be used as script witness;\nscript_or_ref\nScript\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "mintAsstes?",
    "completion": "mintAsstes\nreadonly mintAssets: ( assets: IValuePolicyEntry, script_or_ref: Script | CanResolveToUTxO, redeemer?: CanBeData,) => TxBuilderRunner\nreadonly mintAssets: ( assets: IValuePolicyEntry, script_or_ref: Script | CanResolveToUTxO, redeemer?: CanBeData,) => TxBuilderRunner\nassets\nIValuePolicyEntry\nscript_or_ref\nScript\nCanResolveToUTxO\nundefined\nredeemer\nCanBeData\nundefined\nredeemer may be omitted if script_or_ref is a native script.\nredeemer\nscript_or_ref\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "referenceUtxos?",
    "completion": "referenceUtxos\nreadonly referenceUtxos!:( utxos: CanResolveToUTxO[] ) => TxBuilderRunner\nreadonly referenceUtxos!:( utxos: CanResolveToUTxO[] ) => TxBuilderRunner\nadds the utxos to the refInputs field of the resulting Tx\nutxos\nrefInputs\nTx\nthe elements of the array that don't satisfy the IUTxO interface will be resolved using the provider resolveUtxos method.\nIUTxO\nresolveUtxos\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "validFrom?",
    "completion": "validFrom\nreadonly validFrom!: ( POSIX: bigint | number ) => TxBuilderRunner\nreadonly validFrom!: ( POSIX: bigint | number ) => TxBuilderRunner\nPOSIX\nbigint\nnumber\nSets the validity interval start of the transaction to the POISX time with millisecond precision specified (the result of Date.now() or Date.prototype.valueOf() in javascript)\nDate.now()\nDate.prototype.valueOf()\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "validFromSlot?",
    "completion": "validFromSlot\nreadonly validFromSlot!: ( slot: bigint | number ) => TxBuilderRunner\nreadonly validFromSlot!: ( slot: bigint | number ) => TxBuilderRunner\nslot\nbigint\nnumber\nSets the validity interval start of the transaction to the specified slot,\nuse validFrom for POSIX time instead.\nvalidFrom\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "invalidBeforeSlot?",
    "completion": "invalidBeforeSlot\nreadonly invalidBeforeSlot!: ( slot: bigint | number ) => TxBuilderRunner\nreadonly invalidBeforeSlot!: ( slot: bigint | number ) => TxBuilderRunner\nslot\nbigint\nnumber\nalias for validFromSlot\nvalidFromSlot\nSets the validity interval start of the transaction to the specified slot,\nuse validFrom for POSIX time instead.\nvalidFrom\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "validTo?",
    "completion": "validTo\nreadonly validTo!: ( POSIX: bigint | number ) => TxBuilderRunner\nreadonly validTo!: ( POSIX: bigint | number ) => TxBuilderRunner\nPOSIX\nbigint\nnumber\nSets the validity interval end of the transaction to the POISX time with millisecond precision specified (the result of Date.now() or Date.prototype.valueOf() in javascript)\nDate.now()\nDate.prototype.valueOf()\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "validToSlot?",
    "completion": "validToSlot\nreadonly validToSlot!: ( slot: bigint | number ) => TxBuilderRunner\nreadonly validToSlot!: ( slot: bigint | number ) => TxBuilderRunner\nslot\nbigint\nnumber\nSets the validity interval end of the transaction to the specified slot,\nuse validTo for POSIX time instead.\nvalidTo\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "invalidAfterSlot?",
    "completion": "invalidAfterSlot\nreadonly invalidAfterSlot!: ( slot: bigint | number ) => TxBuilderRunner\nreadonly invalidAfterSlot!: ( slot: bigint | number ) => TxBuilderRunner\nslot\nbigint\nnumber\nalias for validToSlot\nvalidToSlot\nSets the validity interval end of the transaction to the specified slot,\nuse validTo for POSIX time instead.\nvalidTo\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "withdraw?",
    "completion": "withdraw\nreadonly withdraw!: ( stakeAddress: CanBeStakeCreds, amount: number | bigint, redeemer?: CanBeData, script_or_ref?: Script | CanResolveToUTxO) => TxBuilderRunner\nreadonly withdraw!: ( stakeAddress: CanBeStakeCreds, amount: number | bigint, redeemer?: CanBeData, script_or_ref?: Script | CanResolveToUTxO) => TxBuilderRunner\nstakeAddress\nCanBeStakeCreds\namount\nnumber\nbigint\nredeemer\nCanBeData\nscript_or_ref\nScript\nCanResolveToUTxO\nwithdraws stake rewards from a given reward account.\nreturns a reference to the same TxBuilderRunner.\nTxBuilderRunner"
  },
  {
    "prompt": "README?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\nCollection of functions and classes defining the Cardano ledger data structures.\nnpm install @harmoniclabs/cardano-ledger-ts\nnpm install @harmoniclabs/cardano-ledger-ts"
  },
  {
    "prompt": "CertificateType?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertificateType\nAuthCommitteeHot: 14\n14\nsrc/ledger/certs/CertificateType.ts:21\nGenesisKeyDelegation: 5\n5\nsince conway\nsrc/ledger/certs/CertificateType.ts:9\nMoveInstantRewards: 6\n6\nsince conway\nsrc/ledger/certs/CertificateType.ts:11\nPoolRegistration: 3\n3\nsrc/ledger/certs/CertificateType.ts:6\nPoolRetirement: 4\n4\nsrc/ledger/certs/CertificateType.ts:7\nRegistrationDeposit: 7\n7\nsrc/ledger/certs/CertificateType.ts:13\nRegistrationDrep: 16\n16\nsrc/ledger/certs/CertificateType.ts:23\nResignCommitteeCold: 15\n15\nsrc/ledger/certs/CertificateType.ts:22\nStakeDeRegistration: 1\n1\nsrc/ledger/certs/CertificateType.ts:4\nStakeDelegation: 2\n2\nsrc/ledger/certs/CertificateType.ts:5\nStakeRegistration: 0\n0\nsrc/ledger/certs/CertificateType.ts:3\nStakeRegistrationDeleg: 11\n11\nsrc/ledger/certs/CertificateType.ts:17\nStakeVoteDeleg: 10\n10\nsrc/ledger/certs/CertificateType.ts:16\nStakeVoteRegistrationDeleg: 13\n13\nsrc/ledger/certs/CertificateType.ts:19\nUnRegistrationDeposit: 8\n8\nsrc/ledger/certs/CertificateType.ts:14\nUnRegistrationDrep: 17\n17\nsrc/ledger/certs/CertificateType.ts:24\nUpdateDrep: 18\n18\nsrc/ledger/certs/CertificateType.ts:25\nVoteDeleg: 9\n9\nsrc/ledger/certs/CertificateType.ts:15\nVoteRegistrationDeleg: 12\n12\nsrc/ledger/certs/CertificateType.ts:18"
  },
  {
    "prompt": "ITxOutRefToStr?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITxOutRefToStr\nITxOutRefToStr(iRef): TxOutRefStr\niRef\nTxOutRefStr\niRef: ITxOutRef\nITxOutRef\nTxOutRefStr\nTxOutRefStr\nsrc/tx/body/output/TxOutRef.ts:52"
  },
  {
    "prompt": "globals?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs"
  },
  {
    "prompt": "Cip30LikeSignTx?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Cip30LikeSignTx\nsignTx: (txCbor, partial?) = string | Promise string\ntxCbor\npartial\nstring\nPromise\nstring\ntxCbor: string\nstring\nreceives the current transaction (this) cbor\nthis\npartial?: boolean\nboolean\n(standard parameter) wheather to throw or not if the wallet can not sign the entire transaction (true always passed)\ntrue\nstring | Promise string\nstring\nPromise\nstring\nthe cbor of the TxWitnessSet (!!! NOT the cbor of the signe transaction !!!)\nTxWitnessSet\nsrc/tx/Tx.ts:28"
  },
  {
    "prompt": "AddressStr?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / AddressStr\nAddressStr: `${\"addr1\" | \"addr_test1\"}${string}`\nsrc/ledger/Address.ts:15"
  },
  {
    "prompt": "defaultProtocolParameters?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / defaultProtocolParameters\nconst defaultProtocolParameters: ProtocolParameters\nconst\nProtocolParameters\nsrc/ledger/protocol/ProtocolParameters.ts:494"
  },
  {
    "prompt": "DataB?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / DataB\nnew DataB(B): DataB\nB\nDataB\nB: string | ByteString | Uint8Array\nstring\nByteString\nUint8Array\nDataB\nDataB\nDataB.ts:11\nprivate _bytes: ByteString\nprivate\nByteString\nDataB.ts:5\nget bytes(): ByteString\nget\nByteString\nByteString\nByteString\nDataB.ts:6\nclone(): DataB\nDataB\nDataB\nDataB\nDataB.ts:18\ntoJson(): Object\nObject\nObject\nObject\nbytes: string\nstring\nDataB.ts:24\ntoString(): string\nstring\nstring\nstring\nDataB.ts:29"
  },
  {
    "prompt": "cborTagToConstrNumber?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / cborTagToConstrNumber\ncborTagToConstrNumber(tag): bigint\ntag\nbigint\nthe case tag === 102 should be handled outside the funciton\ntag === 102\nreturns a negative number in case of unrecognized alternative\ntag: bigint\nbigint\nbigint\nbigint\nDataConstr.ts:89"
  },
  {
    "prompt": "ToData?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / ToData\ntoData: (version?) = Data\nversion\nData\nversion?: \"v1\" | \"v2\"\n\"v1\"\n\"v2\"\nData\nData\ntoData/interface.ts:4"
  },
  {
    "prompt": "Data?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / Data\nData: DataConstr | DataMap any, any | DataList | DataI | DataB\nDataConstr\nDataMap\nany\nany\nDataList\nDataI\nDataB\nData.ts:8"
  },
  {
    "prompt": "CanBeData?",
    "completion": "CanBeData\ntype CanBeData = Data | ToUPLC | string;\ntype CanBeData = Data | ToUPLC | string;\neither:\nData\nToUPLC\nstring\ndataFromCbor"
  },
  {
    "prompt": "CanBePoolKeyHash?",
    "completion": "CanBePoolKeyHash\ntype CanBePoolKeyHash = Hash28 | `pool1${string}` | `pool_test1${string}` | string /* hex */ | Uint8Array;\ntype CanBePoolKeyHash = Hash28 | `pool1${string}` | `pool_test1${string}` | string /* hex */ | Uint8Array;\neither:\nHash28\n`pool1${string}` | `pool_test1${string}`\nstring\nUint8Array"
  },
  {
    "prompt": "CanBeStakeCreds?",
    "completion": "CanBeStakeCreds\ntype CanBeStakeCreds = StakeAddress | StakeAddressBech32 | StakeCredentials | Script;\ntype CanBeStakeCreds = StakeAddress | StakeAddressBech32 | StakeCredentials | Script;\neither:\nStakeAddress\nStakeAddressBech32\nStakeCredentials\nScript"
  },
  {
    "prompt": "CanResolveToUTxO?",
    "completion": "CanResolveToUTxO\ntype CanResolveToUTxO = IUTxO | ITxOutRef | TxOutRefStr;\ntype CanResolveToUTxO = IUTxO | ITxOutRef | TxOutRefStr;\neither:\nIUTxO\nUTxO\nITxOutRef\nTxOutRef\nTxOutRefStr"
  },
  {
    "prompt": "Generic Structs?",
    "completion": "Sometimes it might be necessary to define custom types that are able to work with any other type; often acting as containers.\nA great example are lists; which can work with elements of any type; and for this reason we have list( int ), list( bs ), etc...\nlist( int )\nlist( bs )\nBut lists are built into the language; how do we define our own containers?\nIn the same way we define generic types!\nAs we know structs can have multiple constructors and the same is true for generic ones; so let's try to define a type that can hold either one or two instances of the same type:\nconst POneOrTwo = ( ty ) => pstruct({ One: { value: ty }, Two: { fst: ty, snd: ty }});\nconst POneOrTwo = ( ty ) => pstruct({ One: { value: ty }, Two: { fst: ty, snd: ty }});\npgenericStruct returns a function (and not a class like pstruct does) that takes as input as many TermTypes as in the definition (arguments of the function passed to `pgenericStruct')\npgenericStruct\npstruct\nTermType\nand only then returns a class; which represents the actual struct type.\nconst OneOrTwoInts = POneOrTwo( int ),const OneOrTwoBS = POneOrTwo( bs );const OneOrTwoOneOrTwoInts = POneOrTwo( POneOrTwo( int ).type );\nconst OneOrTwoInts = POneOrTwo( int ),const OneOrTwoBS = POneOrTwo( bs );const OneOrTwoOneOrTwoInts = POneOrTwo( POneOrTwo( int ).type );\nEach time we need to deal with something that is generic Typescript needs a little help understanding what is the type of the argument.\nWe can make Typescript happy by making the function that returns a struct generic in typescript;\nSo the correct version of the snipped above would be:\nconst POneOrTwo = <TyArg extends TermType>( ty: TyArg ) => pstruct({ One: { value: ty }, Two: { fst: ty, snd: ty } });\nconst POneOrTwo = <TyArg extends TermType>( ty: TyArg ) => pstruct({ One: { value: ty }, Two: { fst: ty, snd: ty } });"
  },
  {
    "prompt": "Partial function application?",
    "completion": "When a plu-ts function takes more than one argument, like the pTwoIntegersList we built explaining pfn, it is possible to get new functions from the first by passing only some of the parameters.\nplu-ts\npTwoIntegersList\npfn\nSince the type of pTwoIntegersList was something like int - int - list( int ), pTwoIntegersList expects 2 arguments; however if we pass only 1 the result will be a valid Term of type int - list( int ); which is another plu-ts function!\npTwoIntegersList\nint -> int -> list( int )\npTwoIntegersList\nint -> list( int )\nplu-ts\n// this is a Term from PInt to PList<PInt>!const pListWith42First = pTwoIntegersList.$( 42 );\n// this is a Term from PInt to PList<PInt>!const pListWith42First = pTwoIntegersList.$( 42 );\nIn particular, the new function we get behaves just like the first but with the arguments already passed that are fixed and can't be changed.\n// equivalent to pTwoIntegersList.$( 42 ).$( 69 )const niceList = pListWith42First.$( 69 );\n// equivalent to pTwoIntegersList.$( 42 ).$( 69 )const niceList = pListWith42First.$( 69 );\nThis not only reduces the number of new functions you need to create but is also more efficient than wrapping the first function inside of a new lambda.\n// bad practice;const pInefficientListWith42First = plam( int, list( int ) ) ( int2 => pTwoIntegersList.$( 42 ).$( int2 ) );\n// bad practice;const pInefficientListWith42First = plam( int, list( int ) ) ( int2 => pTwoIntegersList.$( 42 ).$( int2 ) );\nEven if the compiler is smart enough to optimize some trivial cases, it is still best practice to avoid doing this."
  },
  {
    "prompt": "builtins?",
    "completion": "Fortunately UPLC does have some basic functions that allow us to build more complex ones when needed.\nWe already encountered peqInt while introducing plam exactly because we needed a way to interact with our terms.\npeqInt\nplam\nThe Plutonomicon open source repository has some great docs explaining the behavior of each builtin available."
  },
  {
    "prompt": "V1?",
    "completion": "3 items\n3 items\n1 items\n2 items\n3 items\n3 items\n1 items\n4 items\n3 items"
  },
  {
    "prompt": "V2?",
    "completion": "3 items\n5 items"
  },
  {
    "prompt": "V3?",
    "completion": "7 items\n6 items\n2 items"
  },
  {
    "prompt": "Governance?",
    "completion": "Introduced in V3 version\nIntroduced in V3 version\nIntroduced in V3 version\nIntroduced in V3 version\nIntroduced in V3 version\nIntroduced in V3 version\nIntroduced in V3 version"
  },
  {
    "prompt": "ScriptContext?",
    "completion": "The modifications in PScriptContext from V2 version are highlighted.\nThe modifications in PScriptPurpose from V1 version are highlighted.\nModified from PDCert in V1 version\nIntroduced in V3 version\nIntroduced in V3 version\nThe modifications in PTxInfo from V2 version are highlighted."
  },
  {
    "prompt": "PScriptPurpose?",
    "completion": "PScriptPurpose\nThe modifications in PScriptPurpose from V1 version are highlighted.\nPScriptPurpose\nIt tells us what specific role or purpose the script is used for based on the constructor. Definition:\nexport const PScriptPurpose = pstruct({ Minting: { currencySym: PCurrencySymbol.type }, Spending: { utxoRef: PTxOutRef.type }, Rewarding: { stakeCredential: PCredential.type }, Certifying: { index: int, cert: PCertificate.type }, Voting: { voter: PVoter.type }, Proposing: { index: int, proposal: PProposalProcedure.type }});\nexport const PScriptPurpose = pstruct({ Minting: { currencySym: PCurrencySymbol.type }, Spending: { utxoRef: PTxOutRef.type }, Rewarding: { stakeCredential: PCredential.type }, Certifying: { index: int, cert: PCertificate.type }, Voting: { voter: PVoter.type }, Proposing: { index: int, proposal: PProposalProcedure.type }});\nMinting\nPurpose for minting new assets\ncurrencySym\nThe currency symbol associated with the asset being minted\ntype: PCurrencySymbol.type\nPCurrencySymbol.type\nSpending\nPurpose for spending a specific UTXO\nutxoRef\nA reference to the UTXO that is being spent\ntype: PTxOutRef.type\nPTxOutRef.type\nRewarding\nPurpose for rewarding a stakeholder\nstakeCredential\nCredential of the stakeholder receiving the reward.\ntype: PCredential.type\nPCredential.type\nCertifying\nPurpose for certifying actions or events\nindex\nIndex of certification event\ntype: TermInt\nTermInt\ncert\nCertificate associated with the event\ntype: PCertificate.type\nPCertificate.type\nVoting\nPurpose for casting a vote in a governance process\nvoter\ntype: PVoter.type\nPVoter.type\nProposing\nPurpose for proposing new procedures or actions\nindex\nIndex of proposal\ntype: TermInt\nTermInt\nproposal\nProposal being submitted for consideration\ntype: PProposalProcedure.type\nPProposalProcedure.type\nMinting\ncurrencySym\nSpending\nutxoRef\nRewarding\nstakeCredential\nCertifying\nindex\ncert\nVoting\nvoter\nProposing\nindex\nproposal"
  },
  {
    "prompt": "PCertificate?",
    "completion": "PCertificate\nModified from PDCert in V1 version\nPDCert\nIt represents any possible certificate that can be included in a transaction.\nDefinition:\nexport const PCertificate = pstruct({ StakeRegistration: { stakeKey: PCredential.type, deposit: PMaybeInt.type }, StakeDeRegistration: { stakeKey: PCredential.type, refound: PMaybeInt.type }, Delegation: { delegator: PCredential.type, delegatee: PDelegatee.type }, RegistrationAndDelegation: { delegator: PCredential.type, delegatee: PDelegatee.type, lovelacesDeposit: int }, DRepRegistration: { drep: PCredential.type, lovelacesDeposit: int }, DRepUpdate: { drep: PCredential.type }, DRepDeRegistration: { drep: PCredential.type, refound: int }, PoolRegistration: { poolId: PPubKeyHash.type, poolVFR: PPubKeyHash.type, }, PoolRetire: { poolId: PPubKeyHash.type, epoch: int, }, CommitteeHotAuthorization: { cold: PCredential.type, hot: PCredential.type }, CommitteeResignation: { cold: PCredential.type }});\nexport const PCertificate = pstruct({ StakeRegistration: { stakeKey: PCredential.type, deposit: PMaybeInt.type }, StakeDeRegistration: { stakeKey: PCredential.type, refound: PMaybeInt.type }, Delegation: { delegator: PCredential.type, delegatee: PDelegatee.type }, RegistrationAndDelegation: { delegator: PCredential.type, delegatee: PDelegatee.type, lovelacesDeposit: int }, DRepRegistration: { drep: PCredential.type, lovelacesDeposit: int }, DRepUpdate: { drep: PCredential.type }, DRepDeRegistration: { drep: PCredential.type, refound: int }, PoolRegistration: { poolId: PPubKeyHash.type, poolVFR: PPubKeyHash.type, }, PoolRetire: { poolId: PPubKeyHash.type, epoch: int, }, CommitteeHotAuthorization: { cold: PCredential.type, hot: PCredential.type }, CommitteeResignation: { cold: PCredential.type }});\nStakeRegistration\nStake credential registration certificate\nstakeKey\ntype: PCredential.type\nPCredential.type\ndeposit\ntype: PMaybeInt.type ( TermInt )\nPMaybeInt.type\nTermInt\nStakeDeRegistration\nStake credential de-registration certificate\nstakeKey\ntype: PCredential.type\nPCredential.type\nrefound\ntype: PMaybeInt.type ( TermInt )\nPMaybeInt.type\nTermInt\nDelegation\nDelegation of the founds controlled by the specified PCredential to the specified poolId\nPCredential\ndelegator\ntype: PCredential.type\nPCredential.type\ndelegatee\ntype: PDelegatee.type\nPDelegatee.type\nRegistrationAndDelegation\nCombined registration and delegation certificate.\ndelegator\ntype: PCredential.type\nPCredential.type\ndelegatee\ntype: PDelegatee.type\nPDelegatee.type\nDRepRegistration\nDelegated representative (DRep) registration certificate.\ndrep\ntype: PCredential.type\nPCredential.type\nlovelacesDeposit\ntype: TermInt\nTermInt\nDRepUpdate\nUpdate certificate for an existing DRep.\ndrep\ntype: PCredential.type\nPCredential.type\nDRepDeregistration\nDRep de-registration certificate.\ndrep\ntype: PCredential.type\nPCredential.type\nrefound\ntype: TermInt\nTermInt\nPoolRegistration\nPool registration certificate\npoolId\ntype: PPubKeyHash.type\nPPubKeyHash.type\npoolVFR\ntype: PPubKeyHash.type\nPPubKeyHash.type\nPoolRetire\nPool de-registration certificate\npoolId\ntype: PPubKeyHash.type\nPPubKeyHash.type\nepoch\ntype: TermInt\nTermInt\nCommitteeHotAuthorization\nAuthorization certificate for committee hot keys\ncold\ntype: PCredential.type\nPCredential.type\nhot\ntype: PCredential.type\nPCredential.type\nCommitteeResignation\nResignation certificate for committee members.\ncold\ntype: PCredential.type\nPCredential.type\nStakeRegistration\nstakeKey\ndeposit\nStakeDeRegistration\nstakeKey\nrefound\nDelegation\ndelegator\ndelegatee\nRegistrationAndDelegation\ndelegator\ndelegatee\nDRepRegistration\ndrep\nlovelacesDeposit\nDRepUpdate\ndrep\nDRepDeregistration\ndrep\nrefound\nPoolRegistration\npoolId\npoolVFR\nPoolRetire\npoolId\nepoch\nCommitteeHotAuthorization\ncold\nhot\nCommitteeResignation\ncold"
  },
  {
    "prompt": "PDelegatee?",
    "completion": "PDelegatee\nIntroduced in V3 version\nDefines various forms of delegation in context of staking and voting\nDefinition:\nexport const PDelegatee = pstruct({ DelegStake: { poolId: PPubKeyHash.type }, DelegVote: { drep: PDrep.type }, DelegStakeVote: { poolId: PPubKeyHash.type, drep: PDrep.type }});\nexport const PDelegatee = pstruct({ DelegStake: { poolId: PPubKeyHash.type }, DelegVote: { drep: PDrep.type }, DelegStakeVote: { poolId: PPubKeyHash.type, drep: PDrep.type }});\nDelegStake\nCertificate for delegating stake to a specified pool\npoolId\ntype: PPubKeyHash.type\nPPubKeyHash.type\nDelegVote\nCertificate for delegating voting power to a specified DRep\ndrep\ntype: PDrep.type\nPDrep.type\nDelegStakeVote\nCertificate for delegating both stake and voting power\npoolId\ntype: PPubKeyHash.type\nPPubKeyHash.type\ndrep\ntype: PDrep.type\nPDrep.type\nDelegStake\npoolId\nDelegVote\ndrep\nDelegStakeVote\npoolId\ndrep"
  },
  {
    "prompt": "PScriptInfo?",
    "completion": "PScriptInfo\nIntroduced in V3 version\nDefine various contexts in which a script operates\nDefinition:\nexport const PScriptInfo = pstruct({ Minting: { currencySym: PCurrencySymbol.type }, Spending: { utxoRef: PTxOutRef.type, datum: PMaybe( data ).type }, Rewarding: { stakeCredential: PCredential.type }, Certifying: { index: int, cert: PCertificate.type }, Voting: { voter: PVoter.type }, Proposing: { index: int, proposal: PProposalProcedure.type }});\nexport const PScriptInfo = pstruct({ Minting: { currencySym: PCurrencySymbol.type }, Spending: { utxoRef: PTxOutRef.type, datum: PMaybe( data ).type }, Rewarding: { stakeCredential: PCredential.type }, Certifying: { index: int, cert: PCertificate.type }, Voting: { voter: PVoter.type }, Proposing: { index: int, proposal: PProposalProcedure.type }});\nMinting\nContext for minting a new asset\ncurrencySym\ntype: PCurrencySymbol.type\nPCurrencySymbol.type\nSpending\nContext for spending a UTXO\nutxoRef\ntype: PTxOutRef.type\nPTxOutRef.type\ndatum\ntype: PMaybe( data ).type\nPMaybe( data ).type\nRewarding\nContext for rewarding a participant\nstakeCredential\ntype: PCredential.type\nPCredential.type\nCertifying\nContext for certifying actions or events\nindex\ntype: TermInt\nTermInt\ncert\ntype: PCertificate.type\nPCertificate.type\nVoting\nContext for casting a vote\nvoter\ntype: PVoter.type\nPVoter.type\nProposing\nContext for proposing a new procedure or action\nindex\ntype: TermInt\nTermInt\nproposal\ntype: PProposalProcedure.type\nPProposalProcedure.type\nMinting\ncurrencySym\nSpending\nutxoRef\ndatum\nRewarding\nstakeCredential\nCertifying\nindex\ncert\nVoting\nvoter\nProposing\nindex\nproposal"
  },
  {
    "prompt": "Tx?",
    "completion": "Modified from V2 version.\nModified entirely from V1 version."
  },
  {
    "prompt": "PTxInInfo?",
    "completion": "PTxInInfo\nModified from V2 version.\nIt represents a transaction input.\ndefinition:\nexport const PTxInInfo = pstruct({ PTxInInfo: { utxoRef: PTxOutRef.type, resolved: PTxOut.type }});\nexport const PTxInInfo = pstruct({ PTxInInfo: { utxoRef: PTxOutRef.type, resolved: PTxOut.type }});\nutxoRef\ntype: PTxOutRef.type\nPTxOutRef.type\nresolved\ntype: PTxOut.type\nPTxOut.type\nutxoRef\nresolved"
  },
  {
    "prompt": "PTxOut?",
    "completion": "PTxOut\nModified entirely from V1 version. The changes are highlighted.\nType that represents a transaction output.\nDefinition:\nimport { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { PMaybe } from \"../../../lib/std/PMaybe/PMaybe\";import { V1 } from \"../../V1\";import { POutputDatum } from \"./POutputDatum\";export const PTxOut = pstruct({ PTxOut: { address: V1.PAddress.type, value: V1.PValue.type, datum: POutputDatum.type, refScrpt: PMaybe( V1.PScriptHash.type ).type }});\nimport { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { PMaybe } from \"../../../lib/std/PMaybe/PMaybe\";import { V1 } from \"../../V1\";import { POutputDatum } from \"./POutputDatum\";export const PTxOut = pstruct({ PTxOut: { address: V1.PAddress.type, value: V1.PValue.type, datum: POutputDatum.type, refScrpt: PMaybe( V1.PScriptHash.type ).type }});\naddress\nDestination address (recipient) to which the value is sent\ntype: V1.PAddress.type\nV1.PAddress.type\nvalue\nAmount of value being transferred in the transaction output. This includes the currency and the amount.\ntype: V1.PValue.type\nV1.PValue.type\ndatum\nDefines the datum attached to the transaction output.\ntype: POutputDatum.type\nPOutputDatum.type\n(Optional) Reference to script hash, if applicable. This allows a transaction to refer to an existing on-chain script without having to include the full script in the transaction.\ntype: PMaybe( V1.PScriptHash.type ).type\nPMaybe( V1.PScriptHash.type ).type\naddress\nvalue\ndatum"
  },
  {
    "prompt": "PValue?",
    "completion": "PValue\nIt represents a ledger Value.\nDefinition:\nexport const PAssetsEntry = palias( pair( PTokenName.type, int ))export const PValueEntry = palias( pair( PCurrencySymbol.type, list( PAssetsEntry.type ) ))export const PValue = palias( list( PValueEntry.type ))\nexport const PAssetsEntry = palias( pair( PTokenName.type, int ))export const PValueEntry = palias( pair( PCurrencySymbol.type, list( PAssetsEntry.type ) ))export const PValue = palias( list( PValueEntry.type ))\nThe value implements all the properties defined on the TermList utility term.\nTermList\nSee also:\nPCurrencySymbol\nPTokenName\nTermInt"
  },
  {
    "prompt": "PCredential?",
    "completion": "PCredential\nCredentials (payment or staking); either a public key hash (in the case of a user) or a validator hash (for on-chain scripts)\nDefinition:\nexport const PCredential = pstruct({ PPubKeyCredential: { pkh: PPubKeyHash.type }, PScriptCredential: { valHash: PValidatorHash.type },});\nexport const PCredential = pstruct({ PPubKeyCredential: { pkh: PPubKeyHash.type }, PScriptCredential: { valHash: PValidatorHash.type },});\nPPubKeyCredential\nuser governed credentials\npkh\ntype: PPubKeyHash\nPPubKeyHash\nPScriptCredential\non-chain script governed credentials\nvalHash\ntype: PValidatorHash\nPValidatorHash\nPPubKeyCredential\npkh\nPScriptCredential\nvalHash"
  },
  {
    "prompt": "PPOSIXTimeRange?",
    "completion": "PPOSIXTimeRange\nUsed to describe the time interval in which a transaction is considered valid\nDefinition:\nimport { PInterval } from \"../Interval/PInterval\";export const PPOSIXTimeRange = PInterval;\nimport { PInterval } from \"../Interval/PInterval\";export const PPOSIXTimeRange = PInterval;\ntype: PInterval"
  },
  {
    "prompt": "PPubKeyHash?",
    "completion": "PPubKeyHash\nA bytestring of length 28 representing the hash of a public key.\nDefinition:\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PPubKeyHash = palias( bs );\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PPubKeyHash = palias( bs );\naliased type: TermBS\nTermBS"
  },
  {
    "prompt": "PDatumHash?",
    "completion": "PDatumHash\nRepresents a hash of a datum (piece of data associated with a transaction output), allowing the script to reference and verify the datum efficiently\nDefinition:\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PDatumHash = palias( bs );\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PDatumHash = palias( bs );\naliased type: TermBS\nTermBS"
  },
  {
    "prompt": "PTxId?",
    "completion": "PTxId\nType that represents the unique identifier of a transaction.\nDefinition:\nimport { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { bs } from \"../../../type_system/types\";export const PTxId = pstruct({ PTxId: { txId: bs }});\nimport { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { bs } from \"../../../type_system/types\";export const PTxId = pstruct({ PTxId: { txId: bs }});\ntype: TermBS\nTermBS"
  },
  {
    "prompt": "PChangedParams?",
    "completion": "PChangedParams\nIntroduced in V3 version\nThis structure represents the details of a voter within a voting mechanism, including their credentials and associated entities.\nDefinition:\nexport const PVoter = pstruct({ Committee: { hotCredentials: PCredential.type }, DRep: { credentials: PCredential.type }, StakePool: { poolHash: PPubKeyHash.type }});\nexport const PVoter = pstruct({ Committee: { hotCredentials: PCredential.type }, DRep: { credentials: PCredential.type }, StakePool: { poolHash: PPubKeyHash.type }});\nCommittee\nhotCredentials\nCredentials associated with the committee\ntype: PCredential.type\nPCredential.type\nDRep\ncredentials\nCredentials of the delegated representative (DRep). It uses PCredential to define the identity of DRep involved in the voting process.\nPCredential\ntype: PCredential.type\nPCredential.type\nStakePool\npoolHash\nHash of the stake pool associated with the voter\ntype: PPubKeyHash.type\nPPubKeyHash.type\nCommittee\nhotCredentials\nDRep\ncredentials\nStakePool\npoolHash"
  },
  {
    "prompt": "PTxOutRef?",
    "completion": "PTxOutRef\nType that represents a reference to a UTXO.\nDefinition:\nexport const PTxOutRef = pstruct({ PTxOutRef: { id: PTxId.type, index: int }});\nexport const PTxOutRef = pstruct({ PTxOutRef: { id: PTxId.type, index: int }});\nid\nUnique transaction ID\ntype: PTxId.type\nPTxId.type\nindex\nIndex of the specific output within this transaction\ntype: TermInt\nTermInt\nid\nindex"
  },
  {
    "prompt": "PVote?",
    "completion": "PVote\nIntroduced in V3 version\nThis structure represents a voting mechanism with three possible outcomes: No, Yes, and Abstain It can be used to capture and process user votes within a decentralized application (dApp).\nDefinition:\nexport const PVote = pstruct({ No: {}, Yes: {}, Abstain: {}});\nexport const PVote = pstruct({ No: {}, Yes: {}, Abstain: {}});\nNo\nRepresents a vote against a proposal. This property can be used to signify disapproval or opposition.\nYes\nRepresents a vote in favor of a proposal. This property signifies support or approval.\nAbstain\nRepresents a neutral stance where the voter chooses not to vote either for or against the proposal.\nNo\nYes\nAbstain"
  },
  {
    "prompt": "PProposalProcedure?",
    "completion": "PProposalProcedure\nIntroduced in V3 version\nRepresents the procedure for submitting a governance proposal in the Cardano blockchain. It includes the deposit amount required, the credentials for returning the deposit, and the associated governance action\nDefinition:\nexport const PProposalProcedure = pstruct({ PProposalProcedure: { /** lovelaces */ deposit: int, returnCredentials: PCredential.type, governanceAction: PGovernanceAction.type }});\nexport const PProposalProcedure = pstruct({ PProposalProcedure: { /** lovelaces */ deposit: int, returnCredentials: PCredential.type, governanceAction: PGovernanceAction.type }});\ndeposit\nThe deposit amount (in lovelaces) required to submit the proposal\ntype: TermInt\nTermInt\nreturnCredentials\nThe staking or payment credential used to return the deposit after the proposal process is complete\ntype: PCredential.type\nPCredential.type\ngovernanceAction\nThe specific governance action being proposed\ntype: PGovernanceAction.type\nPGovernanceAction.type\ndeposit\nreturnCredentials\ngovernanceAction"
  },
  {
    "prompt": "ProtocolParameters?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ProtocolParameters\ncollateralPercentage: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:43\ncommitteeTermLimit: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:49\ncostModels: CostModels\nCostModels\nsrc/ledger/protocol/ProtocolParameters.ts:32\ndrepActivityPeriod: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:53\ndrepDeposit: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:52\ndrepVotingThresholds: PParamsDrepVotingThresholds\nPParamsDrepVotingThresholds\nsrc/ledger/protocol/ProtocolParameters.ts:47\nexecutionUnitPrices: [CborPositiveRational, CborPositiveRational] | object\nCborPositiveRational\nCborPositiveRational\nobject\nsrc/ledger/protocol/ProtocolParameters.ts:33\ngovernanceActionDeposit: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:51\ngovernanceActionValidityPeriod: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:50\nmaxBlockBodySize: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:18\nmaxBlockExecutionUnits: ExBudget | ExBudgetJson\nExBudget\nExBudgetJson\nsrc/ledger/protocol/ProtocolParameters.ts:41\nmaxBlockHeaderSize: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:20\nmaxCollateralInputs: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:44\nmaxTxExecutionUnits: ExBudget | ExBudgetJson\nExBudget\nExBudgetJson\nsrc/ledger/protocol/ProtocolParameters.ts:40\nmaxTxSize: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:19\nmaxValueSize: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:42\nminCommitteSize: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:48\nminPoolCost: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:30\nminfeeRefScriptCostPerByte: Rational\nRational\nsrc/ledger/protocol/ProtocolParameters.ts:54\nmonetaryExpansion: Rational\nRational\nsrc/ledger/protocol/ProtocolParameters.ts:26\npoolPledgeInfluence: Rational\nRational\nsrc/ledger/protocol/ProtocolParameters.ts:25\npoolRetireMaxEpoch: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:23\npoolVotingThresholds: PParamsPoolVotingThresholds\nPParamsPoolVotingThresholds\nsrc/ledger/protocol/ProtocolParameters.ts:46\noptional protocolVersion: IProtocolVerision\noptional\nIProtocolVerision\nprotocolVersion removed in conway\nsrc/ledger/protocol/ProtocolParameters.ts:29\nstakeAddressDeposit: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:21\nstakePoolDeposit: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:22\nstakePoolTargetNum: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:24\ntreasuryCut: Rational\nRational\nsrc/ledger/protocol/ProtocolParameters.ts:27\ntxFeeFixed: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:17\ntxFeePerByte: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:16\nutxoCostPerByte: CanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:31"
  },
  {
    "prompt": "Anchor?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Anchor\nIAnchor\nnew Anchor(__namedParameters): Anchor\n__namedParameters\nAnchor\n__namedParameters: IAnchor\nIAnchor\nAnchor\nAnchor\nsrc/governance/Anchor.ts:26\nreadonly anchorDataHash: Hash32\nreadonly\nHash32\nIAnchor.anchorDataHash\nIAnchor\nanchorDataHash\nsrc/governance/Anchor.ts:24\nreadonly url: string\nreadonly\nstring\nIAnchor.url\nIAnchor\nurl\nsrc/governance/Anchor.ts:23\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/governance/Anchor.ts:36\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nsrc/governance/Anchor.ts:40\ntoJson(): object\nobject\nobject\nobject\nanchorDataHash: string\nstring\nurl: string\nstring\nsrc/governance/Anchor.ts:62\nstatic fromCborObj(cbor): Anchor\nstatic\ncbor\nAnchor\ncbor: CborObj\nCborObj\nAnchor\nAnchor\nsrc/governance/Anchor.ts:48"
  },
  {
    "prompt": "AuxiliaryData?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / AuxiliaryData\nIAuxiliaryData\nToCbor\nToJson\nnew AuxiliaryData(auxData): AuxiliaryData\nauxData\nAuxiliaryData\nauxData: IAuxiliaryData\nIAuxiliaryData\nAuxiliaryData\nAuxiliaryData\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:36\nreadonly hash: AuxiliaryDataHash\nreadonly\nAuxiliaryDataHash\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:34\nreadonly optional metadata: TxMetadata\nreadonly\noptional\nTxMetadata\nIAuxiliaryData.metadata\nIAuxiliaryData\nmetadata\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:29\nreadonly optional nativeScripts: Script NativeScript []\nreadonly\noptional\nScript\nNativeScript\nIAuxiliaryData.nativeScripts\nIAuxiliaryData\nnativeScripts\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:30\nreadonly optional plutusV1Scripts: Script PlutusV1 []\nreadonly\noptional\nScript\nPlutusV1\nIAuxiliaryData.plutusV1Scripts\nIAuxiliaryData\nplutusV1Scripts\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:31\nreadonly optional plutusV2Scripts: Script PlutusV2 []\nreadonly\noptional\nScript\nPlutusV2\nIAuxiliaryData.plutusV2Scripts\nIAuxiliaryData\nplutusV2Scripts\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:32\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:167\ntoCborObj(): CborTag\nCborTag\nCborTag\nCborTag\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:171\ntoJson(): object\nobject\nobject\nobject\nmetadata: any\nany\nnativeScripts: undefined | (ScriptSignature | ScriptAll | ScriptAny | ScriptAtLeast | ScriptAfter | ScriptBefore | object)[]\nundefined\nScriptSignature\nScriptAll\nScriptAny\nScriptAtLeast\nScriptAfter\nScriptBefore\nobject\nplutusV1Scripts: undefined | (ScriptSignature | ScriptAll | ScriptAny | ScriptAtLeast | ScriptAfter | ScriptBefore | object)[]\nundefined\nScriptSignature\nScriptAll\nScriptAny\nScriptAtLeast\nScriptAfter\nScriptBefore\nobject\nplutusV2Scripts: undefined | (ScriptSignature | ScriptAll | ScriptAny | ScriptAtLeast | ScriptAfter | ScriptBefore | object)[]\nundefined\nScriptSignature\nScriptAll\nScriptAny\nScriptAtLeast\nScriptAfter\nScriptBefore\nobject\nToJson.toJson\nToJson.toJson\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:287\nstatic fromCbor(cStr): AuxiliaryData\nstatic\ncStr\nAuxiliaryData\ncStr: CanBeCborString\nCanBeCborString\nAuxiliaryData\nAuxiliaryData\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:200\nstatic fromCborObj(cObj): AuxiliaryData\nstatic\ncObj\nAuxiliaryData\ncObj: CborObj\nCborObj\nAuxiliaryData\nAuxiliaryData\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:204"
  },
  {
    "prompt": "AuxiliaryDataHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / AuxiliaryDataHash\nHash32\nnew AuxiliaryDataHash(bs, className): AuxiliaryDataHash\nbs\nclassName\nAuxiliaryDataHash\nbs: string | Uint8Array | Hash32\nstring\nUint8Array\nHash32\nclassName: string = \"Hash32\"\nstring\n\"Hash32\"\nAuxiliaryDataHash\nAuxiliaryDataHash\nHash32.constructor\nHash32\nconstructor\nsrc/hashes/Hash32/Hash32.ts:25\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash32._bytes\nHash32\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash32._str\nHash32\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash32.asBytes\nHash32\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash32.asString\nHash32\nasString\nsrc/hashes/Hash.ts:125\nclone(): AuxiliaryDataHash\nAuxiliaryDataHash\nAuxiliaryDataHash\nAuxiliaryDataHash\nHash32.clone\nHash32\nclone\nsrc/hashes/Hash32/AuxiliaryDataHash.ts:5\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash32.toBuffer\nHash32\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash32.toBytes\nHash32\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash32.toCbor\nHash32\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash32.toCborObj\nHash32\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash32.toData\nHash32\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash32.toString\nHash32\ntoString\nsrc/hashes/Hash.ts:130\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash32.fromAscii\nHash32\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Hash32\nstatic\ncStr\nHash32\ncStr: CanBeCborString\nCanBeCborString\nHash32\nHash32\nHash32.fromCbor\nHash32\nfromCbor\nsrc/hashes/Hash32/Hash32.ts:35\nstatic fromCborObj(cObj): Hash32\nstatic\ncObj\nHash32\ncObj: CborObj\nCborObj\nHash32\nHash32\nHash32.fromCborObj\nHash32\nfromCborObj\nsrc/hashes/Hash32/Hash32.ts:39\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash32.isStrictInstance\nHash32\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash32.isValidHexValue\nHash32\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash32.toAscii\nHash32\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "BootstrapWitness?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / BootstrapWitness\nToCbor\nCloneable\nBootstrapWitness\nToJson\nnew BootstrapWitness(pubKey, signature, chainCode, attributes): BootstrapWitness\npubKey\nsignature\nchainCode\nattributes\nBootstrapWitness\npubKey: Hash32\nHash32\nsignature: Signature\nSignature\nchainCode: Hash32\nHash32\nattributes: Uint8Array\nUint8Array\nBootstrapWitness\nBootstrapWitness\nsrc/tx/TxWitnessSet/BootstrapWitness.ts:20\nreadonly attributes: Uint8Array\nreadonly\nUint8Array\nsrc/tx/TxWitnessSet/BootstrapWitness.ts:18\nreadonly chainCode: Hash32\nreadonly\nHash32\nsrc/tx/TxWitnessSet/BootstrapWitness.ts:17\nreadonly pubKey: VKey\nreadonly\nVKey\nsrc/tx/TxWitnessSet/BootstrapWitness.ts:15\nreadonly signature: Signature\nreadonly\nSignature\nsrc/tx/TxWitnessSet/BootstrapWitness.ts:16\nclone(): BootstrapWitness\nBootstrapWitness\nBootstrapWitness\nBootstrapWitness\nCloneable.clone\nCloneable.clone\nsrc/tx/TxWitnessSet/BootstrapWitness.ts:63\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/TxWitnessSet/BootstrapWitness.ts:73\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/TxWitnessSet/BootstrapWitness.ts:77\ntoJson(): object\nobject\nobject\nobject\nattributes: string\nstring\nchainCode: string\nstring\npubKey: string\nstring\nsignature: string\nstring\nToJson.toJson\nToJson.toJson\nsrc/tx/TxWitnessSet/BootstrapWitness.ts:107\nstatic fromCbor(cStr): BootstrapWitness\nstatic\ncStr\nBootstrapWitness\ncStr: CanBeCborString\nCanBeCborString\nBootstrapWitness\nBootstrapWitness\nsrc/tx/TxWitnessSet/BootstrapWitness.ts:87\nstatic fromCborObj(cObj): BootstrapWitness\nstatic\ncObj\nBootstrapWitness\ncObj: CborObj\nCborObj\nBootstrapWitness\nBootstrapWitness\nsrc/tx/TxWitnessSet/BootstrapWitness.ts:91"
  },
  {
    "prompt": "CertAuthCommitteeHot?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertAuthCommitteeHot\nICert\nICertAuthCommitteeHot\nToCbor\nToJson\nnew CertAuthCommitteeHot(__namedParameters): CertAuthCommitteeHot\n__namedParameters\nCertAuthCommitteeHot\n__namedParameters: ICertAuthCommitteeHot\nICertAuthCommitteeHot\nCertAuthCommitteeHot\nCertAuthCommitteeHot\nsrc/ledger/certs/CertAuthCommitteeHot.ts:23\nreadonly certType: AuthCommitteeHot\nreadonly\nAuthCommitteeHot\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertAuthCommitteeHot.ts:19\nreadonly coldCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertAuthCommitteeHot.coldCredential\nICertAuthCommitteeHot\ncoldCredential\nsrc/ledger/certs/CertAuthCommitteeHot.ts:20\nreadonly hotCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertAuthCommitteeHot.hotCredential\nICertAuthCommitteeHot\nhotCredential\nsrc/ledger/certs/CertAuthCommitteeHot.ts:21\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertAuthCommitteeHot.ts:52\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/ledger/certs/CertAuthCommitteeHot.ts:57\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/ledger/certs/CertAuthCommitteeHot.ts:61\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertAuthCommitteeHot.ts:34\ntoJson(): object\nobject\nobject\nobject\ncertType: \"AuthCommitteeHot\"\n\"AuthCommitteeHot\"\ncoldCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nhotCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nToJson.toJson\nToJson.toJson\nsrc/ledger/certs/CertAuthCommitteeHot.ts:86\nstatic fromCborObj(cbor): CertAuthCommitteeHot\nstatic\ncbor\nCertAuthCommitteeHot\ncbor: CborObj\nCborObj\nCertAuthCommitteeHot\nCertAuthCommitteeHot\nsrc/ledger/certs/CertAuthCommitteeHot.ts:70"
  },
  {
    "prompt": "CertGenesisKeyDelegation?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertGenesisKeyDelegation\nICert\nICertGenesisKeyDelegation\nnew CertGenesisKeyDelegation(__namedParameters): CertGenesisKeyDelegation\n__namedParameters\nCertGenesisKeyDelegation\n__namedParameters: ICertGenesisKeyDelegation\nICertGenesisKeyDelegation\nCertGenesisKeyDelegation\nCertGenesisKeyDelegation\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:25\nreadonly certType: GenesisKeyDelegation\nreadonly\nGenesisKeyDelegation\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:20\nreadonly genesisDelegateHash: Hash28\nreadonly\nHash28\nICertGenesisKeyDelegation.genesisDelegateHash\nICertGenesisKeyDelegation\ngenesisDelegateHash\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:22\nreadonly genesisHash: Hash28\nreadonly\nHash28\nICertGenesisKeyDelegation.genesisHash\nICertGenesisKeyDelegation\ngenesisHash\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:21\nreadonly vrfKeyHash: Hash32\nreadonly\nHash32\nICertGenesisKeyDelegation.vrfKeyHash\nICertGenesisKeyDelegation\nvrfKeyHash\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:23\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:50\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:55\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:59\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:38\ntoJson(): object\nobject\nobject\nobject\ncertType: \"GenesisKeyDelegation\"\n\"GenesisKeyDelegation\"\ngenesisDelegateHash: string\nstring\ngenesisHash: string\nstring\nvrfKeyHash: string\nstring\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:86\nstatic fromCborObj(cbor): CertGenesisKeyDelegation\nstatic\ncbor\nCertGenesisKeyDelegation\ncbor: CborObj\nCborObj\nCertGenesisKeyDelegation\nCertGenesisKeyDelegation\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:69"
  },
  {
    "prompt": "CertPoolRegistration?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertPoolRegistration\nICert\nICertPoolRegistration\nnew CertPoolRegistration(__namedParameters): CertPoolRegistration\n__namedParameters\nCertPoolRegistration\n__namedParameters: ICertPoolRegistration\nICertPoolRegistration\nCertPoolRegistration\nCertPoolRegistration\nsrc/ledger/certs/CertPoolRegistration.ts:21\nreadonly certType: PoolRegistration\nreadonly\nPoolRegistration\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertPoolRegistration.ts:18\nreadonly poolParams: PoolParams\nreadonly\nPoolParams\nICertPoolRegistration.poolParams\nICertPoolRegistration\npoolParams\nsrc/ledger/certs/CertPoolRegistration.ts:19\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertPoolRegistration.ts:55\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertPoolRegistration.ts:63\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertPoolRegistration.ts:67\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertPoolRegistration.ts:31\ntoJson(): object\nobject\nobject\nobject\ncertType: \"PoolRegistration\"\n\"PoolRegistration\"\npoolParams: object\nobject\ncost: string\nstring\nmargin: number\nnumber\nmetadata: undefined | object\nundefined\nobject\noperator: string\nstring\nowners: string[]\nstring\npledge: string\nstring\nrelays: (object | object | object)[]\nobject\nobject\nobject\nrewardAccount: StakeAddress StakeAddressType\nStakeAddress\nStakeAddressType\nvrfKeyHash: string\nstring\nsrc/ledger/certs/CertPoolRegistration.ts:90\nstatic fromCborObj(cbor): CertPoolRegistration\nstatic\ncbor\nCertPoolRegistration\ncbor: CborObj\nCborObj\nCertPoolRegistration\nCertPoolRegistration\nsrc/ledger/certs/CertPoolRegistration.ts:75"
  },
  {
    "prompt": "CertPoolRetirement?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertPoolRetirement\nICert\nICertPoolRetirement\nnew CertPoolRetirement(__namedParameters): CertPoolRetirement\n__namedParameters\nCertPoolRetirement\n__namedParameters: ICertPoolRetirement\nICertPoolRetirement\nCertPoolRetirement\nCertPoolRetirement\nsrc/ledger/certs/CertPoolRetirement.ts:24\nreadonly certType: PoolRetirement\nreadonly\nPoolRetirement\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertPoolRetirement.ts:20\nreadonly epoch: CanBeUInteger\nreadonly\nCanBeUInteger\nICertPoolRetirement.epoch\nICertPoolRetirement\nepoch\nsrc/ledger/certs/CertPoolRetirement.ts:22\nreadonly poolHash: Hash28\nreadonly\nHash28\nICertPoolRetirement.poolHash\nICertPoolRetirement\npoolHash\nsrc/ledger/certs/CertPoolRetirement.ts:21\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertPoolRetirement.ts:56\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertPoolRetirement.ts:61\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertPoolRetirement.ts:65\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertPoolRetirement.ts:35\ntoJson(): object\nobject\nobject\nobject\ncertType: \"PoolRetirement\"\n\"PoolRetirement\"\nepoch: string\nstring\npoolHash: string\nstring\nsrc/ledger/certs/CertPoolRetirement.ts:92\nstatic fromCborObj(cbor): CertPoolRetirement\nstatic\ncbor\nCertPoolRetirement\ncbor: CborObj\nCborObj\nCertPoolRetirement\nCertPoolRetirement\nsrc/ledger/certs/CertPoolRetirement.ts:74"
  },
  {
    "prompt": "CertRegistrationDeposit?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertRegistrationDeposit\nICert\nICertRegistrationDeposit\nnew CertRegistrationDeposit(__namedParameters): CertRegistrationDeposit\n__namedParameters\nCertRegistrationDeposit\n__namedParameters: ICertRegistrationDeposit\nICertRegistrationDeposit\nCertRegistrationDeposit\nCertRegistrationDeposit\nsrc/ledger/certs/CertRegistrationDeposit.ts:25\nreadonly certType: RegistrationDeposit\nreadonly\nRegistrationDeposit\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertRegistrationDeposit.ts:21\nreadonly deposit: bigint\nreadonly\nbigint\nICertRegistrationDeposit.deposit\nICertRegistrationDeposit\ndeposit\nsrc/ledger/certs/CertRegistrationDeposit.ts:23\nreadonly stakeCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertRegistrationDeposit.stakeCredential\nICertRegistrationDeposit\nstakeCredential\nsrc/ledger/certs/CertRegistrationDeposit.ts:22\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertRegistrationDeposit.ts:62\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertRegistrationDeposit.ts:67\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertRegistrationDeposit.ts:71\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertRegistrationDeposit.ts:36\ntoJson(): object\nobject\nobject\nobject\ncertType: \"RegistrationDeposit\"\n\"RegistrationDeposit\"\ndeposit: string\nstring\nstakeCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertRegistrationDeposit.ts:98\nstatic fromCborObj(cbor): CertRegistrationDeposit\nstatic\ncbor\nCertRegistrationDeposit\ncbor: CborObj\nCborObj\nCertRegistrationDeposit\nCertRegistrationDeposit\nsrc/ledger/certs/CertRegistrationDeposit.ts:80"
  },
  {
    "prompt": "CertRegistrationDrep?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertRegistrationDrep\nICert\nICertRegistrationDrep\nnew CertRegistrationDrep(__namedParameters): CertRegistrationDrep\n__namedParameters\nCertRegistrationDrep\n__namedParameters: ICertRegistrationDrep\nICertRegistrationDrep\nCertRegistrationDrep\nCertRegistrationDrep\nsrc/ledger/certs/CertRegistrationDrep.ts:27\nreadonly anchor: undefined | Anchor\nreadonly\nundefined\nAnchor\nICertRegistrationDrep.anchor\nICertRegistrationDrep\nanchor\nsrc/ledger/certs/CertRegistrationDrep.ts:25\nreadonly certType: RegistrationDrep\nreadonly\nRegistrationDrep\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertRegistrationDrep.ts:22\nreadonly coin: bigint\nreadonly\nbigint\nICertRegistrationDrep.coin\nICertRegistrationDrep\ncoin\nsrc/ledger/certs/CertRegistrationDrep.ts:24\nreadonly drepCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertRegistrationDrep.drepCredential\nICertRegistrationDrep\ndrepCredential\nsrc/ledger/certs/CertRegistrationDrep.ts:23\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertRegistrationDrep.ts:56\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertRegistrationDrep.ts:61\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertRegistrationDrep.ts:65\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertRegistrationDrep.ts:39\ntoJson(): object\nobject\nobject\nobject\nanchor: null | object\nnull\nobject\ncertType: \"RegistrationDrep\"\n\"RegistrationDrep\"\ncoin: string\nstring\nstakeCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertRegistrationDrep.ts:94\nstatic fromCborObj(cbor): CertRegistrationDrep\nstatic\ncbor\nCertRegistrationDrep\ncbor: CborObj\nCborObj\nCertRegistrationDrep\nCertRegistrationDrep\nsrc/ledger/certs/CertRegistrationDrep.ts:75"
  },
  {
    "prompt": "CertResignCommitteeCold?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertResignCommitteeCold\nICert\nICertResignCommitteeCold\nnew CertResignCommitteeCold(__namedParameters): CertResignCommitteeCold\n__namedParameters\nCertResignCommitteeCold\n__namedParameters: ICertResignCommitteeCold\nICertResignCommitteeCold\nCertResignCommitteeCold\nCertResignCommitteeCold\nsrc/ledger/certs/CertResignCommitteeCold.ts:23\nreadonly anchor: undefined | Anchor\nreadonly\nundefined\nAnchor\nICertResignCommitteeCold.anchor\nICertResignCommitteeCold\nanchor\nsrc/ledger/certs/CertResignCommitteeCold.ts:21\nreadonly certType: ResignCommitteeCold\nreadonly\nResignCommitteeCold\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertResignCommitteeCold.ts:19\nreadonly coldCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertResignCommitteeCold.coldCredential\nICertResignCommitteeCold\ncoldCredential\nsrc/ledger/certs/CertResignCommitteeCold.ts:20\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertResignCommitteeCold.ts:50\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertResignCommitteeCold.ts:55\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertResignCommitteeCold.ts:59\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertResignCommitteeCold.ts:34\ntoJson(): object\nobject\nobject\nobject\nanchor: null | object\nnull\nobject\ncertType: \"ResignCommitteeCold\"\n\"ResignCommitteeCold\"\ncoldCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertResignCommitteeCold.ts:84\nstatic fromCborObj(cbor): CertResignCommitteeCold\nstatic\ncbor\nCertResignCommitteeCold\ncbor: CborObj\nCborObj\nCertResignCommitteeCold\nCertResignCommitteeCold\nsrc/ledger/certs/CertResignCommitteeCold.ts:68"
  },
  {
    "prompt": "CertStakeDeRegistration?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertStakeDeRegistration\nICert\nICertStakeDeRegistration\nnew CertStakeDeRegistration(__namedParameters): CertStakeDeRegistration\n__namedParameters\nCertStakeDeRegistration\n__namedParameters: ICertStakeDeRegistration\nICertStakeDeRegistration\nCertStakeDeRegistration\nCertStakeDeRegistration\nsrc/ledger/certs/CertStakeDeRegistration.ts:21\nreadonly certType: StakeDeRegistration\nreadonly\nStakeDeRegistration\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertStakeDeRegistration.ts:18\nreadonly stakeCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertStakeDeRegistration.stakeCredential\nICertStakeDeRegistration\nstakeCredential\nsrc/ledger/certs/CertStakeDeRegistration.ts:19\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertStakeDeRegistration.ts:55\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertStakeDeRegistration.ts:60\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertStakeDeRegistration.ts:64\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertStakeDeRegistration.ts:31\ntoJson(): object\nobject\nobject\nobject\ncertType: \"StakeDeRegistration\"\n\"StakeDeRegistration\"\nstakeCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertStakeDeRegistration.ts:87\nstatic fromCborObj(cbor): CertStakeDeRegistration\nstatic\ncbor\nCertStakeDeRegistration\ncbor: CborObj\nCborObj\nCertStakeDeRegistration\nCertStakeDeRegistration\nsrc/ledger/certs/CertStakeDeRegistration.ts:72"
  },
  {
    "prompt": "CertStakeDelegation?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertStakeDelegation\nICert\nICertStakeDelegation\nnew CertStakeDelegation(__namedParameters): CertStakeDelegation\n__namedParameters\nCertStakeDelegation\n__namedParameters: ICertStakeDelegation\nICertStakeDelegation\nCertStakeDelegation\nCertStakeDelegation\nsrc/ledger/certs/CertStakeDelegation.ts:23\nreadonly certType: StakeDelegation\nreadonly\nStakeDelegation\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertStakeDelegation.ts:19\nreadonly poolKeyHash: Hash28\nreadonly\nHash28\nICertStakeDelegation.poolKeyHash\nICertStakeDelegation\npoolKeyHash\nsrc/ledger/certs/CertStakeDelegation.ts:21\nreadonly stakeCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertStakeDelegation.stakeCredential\nICertStakeDelegation\nstakeCredential\nsrc/ledger/certs/CertStakeDelegation.ts:20\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertStakeDelegation.ts:65\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertStakeDelegation.ts:70\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertStakeDelegation.ts:74\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertStakeDelegation.ts:34\ntoJson(): object\nobject\nobject\nobject\ncertType: \"StakeDelegation\"\n\"StakeDelegation\"\npoolKeyHash: string\nstring\nstakeCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertStakeDelegation.ts:99\nstatic fromCborObj(cbor): CertStakeDelegation\nstatic\ncbor\nCertStakeDelegation\ncbor: CborObj\nCborObj\nCertStakeDelegation\nCertStakeDelegation\nsrc/ledger/certs/CertStakeDelegation.ts:83"
  },
  {
    "prompt": "CertStakeRegistration?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertStakeRegistration\nICert\nICertStakeRegistration\nnew CertStakeRegistration(__namedParameters): CertStakeRegistration\n__namedParameters\nCertStakeRegistration\n__namedParameters: ICertStakeRegistration\nICertStakeRegistration\nCertStakeRegistration\nCertStakeRegistration\nsrc/ledger/certs/CertStakeRegistration.ts:21\nreadonly certType: StakeRegistration\nreadonly\nStakeRegistration\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertStakeRegistration.ts:18\nreadonly stakeCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertStakeRegistration.stakeCredential\nICertStakeRegistration\nstakeCredential\nsrc/ledger/certs/CertStakeRegistration.ts:19\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertStakeRegistration.ts:55\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertStakeRegistration.ts:60\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertStakeRegistration.ts:64\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertStakeRegistration.ts:31\ntoJson(): object\nobject\nobject\nobject\ncertType: \"StakeRegistration\"\n\"StakeRegistration\"\nstakeCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertStakeRegistration.ts:87\nstatic fromCborObj(cbor): CertStakeRegistration\nstatic\ncbor\nCertStakeRegistration\ncbor: CborObj\nCborObj\nCertStakeRegistration\nCertStakeRegistration\nsrc/ledger/certs/CertStakeRegistration.ts:72"
  },
  {
    "prompt": "CertStakeRegistrationDeleg?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertStakeRegistrationDeleg\nICert\nICertStakeRegistrationDeleg\nnew CertStakeRegistrationDeleg(__namedParameters): CertStakeRegistrationDeleg\n__namedParameters\nCertStakeRegistrationDeleg\n__namedParameters: ICertStakeRegistrationDeleg\nICertStakeRegistrationDeleg\nCertStakeRegistrationDeleg\nCertStakeRegistrationDeleg\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:28\nreadonly certType: StakeRegistrationDeleg\nreadonly\nStakeRegistrationDeleg\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:23\nreadonly coin: bigint\nreadonly\nbigint\nICertStakeRegistrationDeleg.coin\nICertStakeRegistrationDeleg\ncoin\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:26\nreadonly poolKeyHash: Hash28\nreadonly\nHash28\nICertStakeRegistrationDeleg.poolKeyHash\nICertStakeRegistrationDeleg\npoolKeyHash\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:25\nreadonly stakeCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertStakeRegistrationDeleg.stakeCredential\nICertStakeRegistrationDeleg\nstakeCredential\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:24\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:58\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:63\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:67\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:40\ntoJson(): object\nobject\nobject\nobject\ncertType: \"StakeRegistrationDeleg\"\n\"StakeRegistrationDeleg\"\ncoin: string\nstring\npoolKeyHash: string\nstring\nstakeCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:77\nstatic fromCbor(cbor): CertStakeRegistrationDeleg\nstatic\ncbor\nCertStakeRegistrationDeleg\ncbor: CanBeCborString\nCanBeCborString\nCertStakeRegistrationDeleg\nCertStakeRegistrationDeleg\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:87\nstatic fromCborObj(cbor): CertStakeRegistrationDeleg\nstatic\ncbor\nCertStakeRegistrationDeleg\ncbor: CborObj\nCborObj\nCertStakeRegistrationDeleg\nCertStakeRegistrationDeleg\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:91"
  },
  {
    "prompt": "CertStakeVoteDeleg?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertStakeVoteDeleg\nICert\nICertStakeVoteDeleg\nnew CertStakeVoteDeleg(__namedParameters): CertStakeVoteDeleg\n__namedParameters\nCertStakeVoteDeleg\n__namedParameters: ICertStakeVoteDeleg\nICertStakeVoteDeleg\nCertStakeVoteDeleg\nCertStakeVoteDeleg\nsrc/ledger/certs/CertStakeVoteDeleg.ts:26\nreadonly certType: StakeVoteDeleg\nreadonly\nStakeVoteDeleg\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertStakeVoteDeleg.ts:21\nreadonly drep: DRep\nreadonly\nDRep\nICertStakeVoteDeleg.drep\nICertStakeVoteDeleg\ndrep\nsrc/ledger/certs/CertStakeVoteDeleg.ts:24\nreadonly poolKeyHash: Hash28\nreadonly\nHash28\nICertStakeVoteDeleg.poolKeyHash\nICertStakeVoteDeleg\npoolKeyHash\nsrc/ledger/certs/CertStakeVoteDeleg.ts:23\nreadonly stakeCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertStakeVoteDeleg.stakeCredential\nICertStakeVoteDeleg\nstakeCredential\nsrc/ledger/certs/CertStakeVoteDeleg.ts:22\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertStakeVoteDeleg.ts:69\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertStakeVoteDeleg.ts:74\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertStakeVoteDeleg.ts:78\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertStakeVoteDeleg.ts:38\ntoJson(): object\nobject\nobject\nobject\ncertType: \"StakeVoteDeleg\"\n\"StakeVoteDeleg\"\ndrep: object\nobject\ndrepType: string\nstring\npoolKeyHash: string\nstring\nstakeCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertStakeVoteDeleg.ts:105\nstatic fromCborObj(cbor): CertStakeVoteDeleg\nstatic\ncbor\nCertStakeVoteDeleg\ncbor: CborObj\nCborObj\nCertStakeVoteDeleg\nCertStakeVoteDeleg\nsrc/ledger/certs/CertStakeVoteDeleg.ts:88"
  },
  {
    "prompt": "CertStakeVoteRegistrationDeleg?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertStakeVoteRegistrationDeleg\nICert\nICertStakeVoteRegistrationDeleg\nnew CertStakeVoteRegistrationDeleg(__namedParameters): CertStakeVoteRegistrationDeleg\n__namedParameters\nCertStakeVoteRegistrationDeleg\n__namedParameters: ICertStakeVoteRegistrationDeleg\nICertStakeVoteRegistrationDeleg\nCertStakeVoteRegistrationDeleg\nCertStakeVoteRegistrationDeleg\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:31\nreadonly certType: StakeVoteRegistrationDeleg\nreadonly\nStakeVoteRegistrationDeleg\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:25\nreadonly coin: bigint\nreadonly\nbigint\nICertStakeVoteRegistrationDeleg.coin\nICertStakeVoteRegistrationDeleg\ncoin\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:29\nreadonly drep: DRep\nreadonly\nDRep\nICertStakeVoteRegistrationDeleg.drep\nICertStakeVoteRegistrationDeleg\ndrep\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:28\nreadonly poolKeyHash: Hash28\nreadonly\nHash28\nICertStakeVoteRegistrationDeleg.poolKeyHash\nICertStakeVoteRegistrationDeleg\npoolKeyHash\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:27\nreadonly stakeCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertStakeVoteRegistrationDeleg.stakeCredential\nICertStakeVoteRegistrationDeleg\nstakeCredential\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:26\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:86\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:91\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:95\ntoData(version?): DataList\nversion\nDataList\nversion?: ToDataVersion\nToDataVersion\nDataList\nDataList\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:44\ntoJson(): object\nobject\nobject\nobject\ncertType: \"StakeVoteRegistrationDeleg\"\n\"StakeVoteRegistrationDeleg\"\ncoin: string\nstring\ndrep: object\nobject\ndrepType: string\nstring\npoolKeyHash: string\nstring\nstakeCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:126\nstatic fromCborObj(cbor): CertStakeVoteRegistrationDeleg\nstatic\ncbor\nCertStakeVoteRegistrationDeleg\ncbor: CborObj\nCborObj\nCertStakeVoteRegistrationDeleg\nCertStakeVoteRegistrationDeleg\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:106"
  },
  {
    "prompt": "CertUnRegistrationDeposit?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertUnRegistrationDeposit\nICert\nICertUnRegistrationDeposit\nnew CertUnRegistrationDeposit(__namedParameters): CertUnRegistrationDeposit\n__namedParameters\nCertUnRegistrationDeposit\n__namedParameters: ICertUnRegistrationDeposit\nICertUnRegistrationDeposit\nCertUnRegistrationDeposit\nCertUnRegistrationDeposit\nsrc/ledger/certs/CertUnRegistrationDeposit.ts:25\nreadonly certType: UnRegistrationDeposit\nreadonly\nUnRegistrationDeposit\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertUnRegistrationDeposit.ts:21\nreadonly deposit: bigint\nreadonly\nbigint\nICertUnRegistrationDeposit.deposit\nICertUnRegistrationDeposit\ndeposit\nsrc/ledger/certs/CertUnRegistrationDeposit.ts:23\nreadonly stakeCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertUnRegistrationDeposit.stakeCredential\nICertUnRegistrationDeposit\nstakeCredential\nsrc/ledger/certs/CertUnRegistrationDeposit.ts:22\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertUnRegistrationDeposit.ts:60\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertUnRegistrationDeposit.ts:65\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertUnRegistrationDeposit.ts:69\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertUnRegistrationDeposit.ts:36\ntoJson(): object\nobject\nobject\nobject\ncertType: \"UnRegistrationDeposit\"\n\"UnRegistrationDeposit\"\ndeposit: string\nstring\nstakeCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertUnRegistrationDeposit.ts:96\nstatic fromCborObj(cbor): CertUnRegistrationDeposit\nstatic\ncbor\nCertUnRegistrationDeposit\ncbor: CborObj\nCborObj\nCertUnRegistrationDeposit\nCertUnRegistrationDeposit\nsrc/ledger/certs/CertUnRegistrationDeposit.ts:78"
  },
  {
    "prompt": "CertUnRegistrationDrep?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertUnRegistrationDrep\nICert\nICertUnRegistrationDrep\nnew CertUnRegistrationDrep(__namedParameters): CertUnRegistrationDrep\n__namedParameters\nCertUnRegistrationDrep\n__namedParameters: ICertUnRegistrationDrep\nICertUnRegistrationDrep\nCertUnRegistrationDrep\nCertUnRegistrationDrep\nsrc/ledger/certs/CertUnRegistrationDrep.ts:26\nreadonly certType: UnRegistrationDrep\nreadonly\nUnRegistrationDrep\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertUnRegistrationDrep.ts:21\nreadonly coin: bigint\nreadonly\nbigint\nrefound\nICertUnRegistrationDrep.coin\nICertUnRegistrationDrep\ncoin\nsrc/ledger/certs/CertUnRegistrationDrep.ts:24\nreadonly drepCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertUnRegistrationDrep.drepCredential\nICertUnRegistrationDrep\ndrepCredential\nsrc/ledger/certs/CertUnRegistrationDrep.ts:22\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertUnRegistrationDrep.ts:54\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertUnRegistrationDrep.ts:59\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertUnRegistrationDrep.ts:63\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertUnRegistrationDrep.ts:37\ntoJson(): object\nobject\nobject\nobject\ncertType: \"UnRegistrationDrep\"\n\"UnRegistrationDrep\"\ncoin: string\nstring\ndrepCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertUnRegistrationDrep.ts:90\nstatic fromCborObj(cbor): CertUnRegistrationDrep\nstatic\ncbor\nCertUnRegistrationDrep\ncbor: CborObj\nCborObj\nCertUnRegistrationDrep\nCertUnRegistrationDrep\nsrc/ledger/certs/CertUnRegistrationDrep.ts:72"
  },
  {
    "prompt": "CertUpdateDrep?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertUpdateDrep\nICert\nICertUpdateDrep\nnew CertUpdateDrep(__namedParameters): CertUpdateDrep\n__namedParameters\nCertUpdateDrep\n__namedParameters: ICertUpdateDrep\nICertUpdateDrep\nCertUpdateDrep\nCertUpdateDrep\nsrc/ledger/certs/CertUpdateDrep.ts:23\nreadonly anchor: undefined | Anchor\nreadonly\nundefined\nAnchor\nICertUpdateDrep.anchor\nICertUpdateDrep\nanchor\nsrc/ledger/certs/CertUpdateDrep.ts:21\nreadonly certType: UpdateDrep\nreadonly\nUpdateDrep\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertUpdateDrep.ts:19\nreadonly drepCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertUpdateDrep.drepCredential\nICertUpdateDrep\ndrepCredential\nsrc/ledger/certs/CertUpdateDrep.ts:20\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertUpdateDrep.ts:50\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertUpdateDrep.ts:55\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertUpdateDrep.ts:59\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertUpdateDrep.ts:34\ntoJson(): object\nobject\nobject\nobject\nanchor: null | object\nnull\nobject\ncertType: \"UpdateDrep\"\n\"UpdateDrep\"\ndrepCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertUpdateDrep.ts:84\nstatic fromCborObj(cbor): CertUpdateDrep\nstatic\ncbor\nCertUpdateDrep\ncbor: CborObj\nCborObj\nCertUpdateDrep\nCertUpdateDrep\nsrc/ledger/certs/CertUpdateDrep.ts:68"
  },
  {
    "prompt": "CertVoteDeleg?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertVoteDeleg\nICert\nICertVoteDeleg\nnew CertVoteDeleg(__namedParameters): CertVoteDeleg\n__namedParameters\nCertVoteDeleg\n__namedParameters: ICertVoteDeleg\nICertVoteDeleg\nCertVoteDeleg\nCertVoteDeleg\nsrc/ledger/certs/CertVoteDeleg.ts:24\nreadonly certType: VoteDeleg\nreadonly\nVoteDeleg\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertVoteDeleg.ts:20\nreadonly drep: DRep\nreadonly\nDRep\nICertVoteDeleg.drep\nICertVoteDeleg\ndrep\nsrc/ledger/certs/CertVoteDeleg.ts:22\nreadonly stakeCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertVoteDeleg.stakeCredential\nICertVoteDeleg\nstakeCredential\nsrc/ledger/certs/CertVoteDeleg.ts:21\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertVoteDeleg.ts:53\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertVoteDeleg.ts:58\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertVoteDeleg.ts:62\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertVoteDeleg.ts:35\ntoJson(): object\nobject\nobject\nobject\ncertType: \"VoteDeleg\"\n\"VoteDeleg\"\ndrep: object\nobject\ndrepType: string\nstring\nstakeCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertVoteDeleg.ts:87\nstatic fromCborObj(cbor): CertVoteDeleg\nstatic\ncbor\nCertVoteDeleg\ncbor: CborObj\nCborObj\nCertVoteDeleg\nCertVoteDeleg\nsrc/ledger/certs/CertVoteDeleg.ts:71"
  },
  {
    "prompt": "CertVoteRegistrationDeleg?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertVoteRegistrationDeleg\nICert\nICertVoteRegistrationDeleg\nnew CertVoteRegistrationDeleg(__namedParameters): CertVoteRegistrationDeleg\n__namedParameters\nCertVoteRegistrationDeleg\n__namedParameters: ICertVoteRegistrationDeleg\nICertVoteRegistrationDeleg\nCertVoteRegistrationDeleg\nCertVoteRegistrationDeleg\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:28\nreadonly certType: VoteRegistrationDeleg\nreadonly\nVoteRegistrationDeleg\nICert.certType\nICert\ncertType\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:23\nreadonly coin: bigint\nreadonly\nbigint\nICertVoteRegistrationDeleg.coin\nICertVoteRegistrationDeleg\ncoin\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:26\nreadonly drep: DRep\nreadonly\nDRep\nICertVoteRegistrationDeleg.drep\nICertVoteRegistrationDeleg\ndrep\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:25\nreadonly stakeCredential: Credential CredentialType\nreadonly\nCredential\nCredentialType\nICertVoteRegistrationDeleg.stakeCredential\nICertVoteRegistrationDeleg\nstakeCredential\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:24\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:58\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:63\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:67\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:40\ntoJson(): object\nobject\nobject\nobject\ncertType: \"VoteRegistrationDeleg\"\n\"VoteRegistrationDeleg\"\ncoin: string\nstring\ndrep: object\nobject\ndrepType: string\nstring\nstakeCredential: object\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:96\nstatic fromCborObj(cbor): CertVoteRegistrationDeleg\nstatic\ncbor\nCertVoteRegistrationDeleg\ncbor: CborObj\nCborObj\nCertVoteRegistrationDeleg\nCertVoteRegistrationDeleg\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:77"
  },
  {
    "prompt": "Constitution?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Constitution\nIConstitution\nToCbor\nnew Constitution(__namedParameters): Constitution\n__namedParameters\nConstitution\n__namedParameters: IConstitution\nIConstitution\nConstitution\nConstitution\nsrc/governance/Constitution.ts:30\nreadonly anchor: Anchor\nreadonly\nAnchor\nIConstitution.anchor\nIConstitution\nanchor\nsrc/governance/Constitution.ts:27\nreadonly scriptHash: undefined | Hash28\nreadonly\nundefined\nHash28\nIConstitution.scriptHash\nIConstitution\nscriptHash\nsrc/governance/Constitution.ts:28\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/governance/Constitution.ts:40\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/governance/Constitution.ts:44\ntoData(v?): DataConstr\nv\nDataConstr\nv?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nsrc/governance/Constitution.ts:52"
  },
  {
    "prompt": "Credential?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Credential\nT extends CredentialType = CredentialType\nCredentialType\nCredentialType\nToCbor\nToData\nCloneable\nCredential\nT\nnew Credential T (type, hash): Credential T\nT\ntype\nhash\nCredential\nT\ntype: T\nT\nhash: Hash28\nHash28\nCredential T\nCredential\nT\nsrc/credentials/Credential.ts:24\nreadonly hash: T extends KeyHash ? PubKeyHash : ValidatorHash\nreadonly\nT\nKeyHash\nPubKeyHash\nValidatorHash\nsrc/credentials/Credential.ts:22\nreadonly type: T\nreadonly\nT\nsrc/credentials/Credential.ts:21\nget static fake(): Credential KeyHash\nget\nstatic\nCredential\nKeyHash\nCredential KeyHash\nCredential\nKeyHash\nsrc/credentials/Credential.ts:58\nclone(): Credential T\nCredential\nT\nCredential T\nCredential\nT\nCloneable.clone\nCloneable.clone\nsrc/credentials/Credential.ts:50\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/credentials/Credential.ts:100\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/credentials/Credential.ts:104\ntoData(_v?): DataConstr\n_v\nDataConstr\n_v?: any\nany\nDataConstr\nDataConstr\nToData.toData\nToData.toData\nsrc/credentials/Credential.ts:66\ntoJson(): object\nobject\nobject\nobject\ncredentialType: string\nstring\nhash: string\nstring\nsrc/credentials/Credential.ts:131\nstatic fromCbor(cStr): Credential CredentialType\nstatic\ncStr\nCredential\nCredentialType\ncStr: CanBeCborString\nCanBeCborString\nCredential CredentialType\nCredential\nCredentialType\nsrc/credentials/Credential.ts:112\nstatic fromCborObj(cObj): Credential CredentialType\nstatic\ncObj\nCredential\nCredentialType\ncObj: CborObj\nCborObj\nCredential CredentialType\nCredential\nCredentialType\nsrc/credentials/Credential.ts:116\nstatic keyHash(hash): Credential KeyHash\nstatic\nhash\nCredential\nKeyHash\nhash: string | Uint8Array | Hash28\nstring\nUint8Array\nHash28\nCredential KeyHash\nCredential\nKeyHash\nsrc/credentials/Credential.ts:80\nstatic pubKey(hash): Credential KeyHash\nstatic\nhash\nCredential\nKeyHash\nhash: string | Uint8Array | Hash28\nstring\nUint8Array\nHash28\nCredential KeyHash\nCredential\nKeyHash\nuse keyHash instead\nkeyHash\nsrc/credentials/Credential.ts:75\nstatic script(hash): Credential Script\nstatic\nhash\nCredential\nScript\nhash: string | Uint8Array | Hash28\nstring\nUint8Array\nHash28\nCredential Script\nCredential\nScript\nsrc/credentials/Credential.ts:90"
  },
  {
    "prompt": "DRepAlwaysAbstain?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / DRepAlwaysAbstain\nIDRep\nIDRepAlwaysAbstain\nnew DRepAlwaysAbstain(_info?): DRepAlwaysAbstain\n_info\nDRepAlwaysAbstain\n_info?: IDRepAlwaysAbstain\nIDRepAlwaysAbstain\nDRepAlwaysAbstain\nDRepAlwaysAbstain\nsrc/governance/DRep/DRepAlwaysAbstain.ts:18\nreadonly drepType: AlwaysAbstain\nreadonly\nAlwaysAbstain\nIDRep.drepType\nIDRep\ndrepType\nsrc/governance/DRep/DRepAlwaysAbstain.ts:15\nreadonly optional hash: undefined\nreadonly\noptional\nundefined\nIDRepAlwaysAbstain.hash\nIDRepAlwaysAbstain\nhash\nsrc/governance/DRep/DRepAlwaysAbstain.ts:16\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/governance/DRep/DRepAlwaysAbstain.ts:41\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/governance/DRep/DRepAlwaysAbstain.ts:45\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nIDRep.toData\nIDRep\ntoData\nsrc/governance/DRep/DRepAlwaysAbstain.ts:28\ntoJson(): object\nobject\nobject\nobject\ndrepType: string\nstring\nsrc/governance/DRep/DRepAlwaysAbstain.ts:52"
  },
  {
    "prompt": "DRepAlwaysNoConfidence?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / DRepAlwaysNoConfidence\nIDRep\nIDRepAlwaysNoConfidence\nnew DRepAlwaysNoConfidence(_info?): DRepAlwaysNoConfidence\n_info\nDRepAlwaysNoConfidence\n_info?: IDRepAlwaysNoConfidence\nIDRepAlwaysNoConfidence\nDRepAlwaysNoConfidence\nDRepAlwaysNoConfidence\nsrc/governance/DRep/DRepAlwaysNoConfidence.ts:18\nreadonly drepType: AlwaysNoConfidence\nreadonly\nAlwaysNoConfidence\nIDRep.drepType\nIDRep\ndrepType\nsrc/governance/DRep/DRepAlwaysNoConfidence.ts:15\nreadonly optional hash: undefined\nreadonly\noptional\nundefined\nIDRepAlwaysNoConfidence.hash\nIDRepAlwaysNoConfidence\nhash\nsrc/governance/DRep/DRepAlwaysNoConfidence.ts:16\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/governance/DRep/DRepAlwaysNoConfidence.ts:41\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/governance/DRep/DRepAlwaysNoConfidence.ts:45\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nIDRep.toData\nIDRep\ntoData\nsrc/governance/DRep/DRepAlwaysNoConfidence.ts:28\ntoJson(): object\nobject\nobject\nobject\ndrepType: string\nstring\nsrc/governance/DRep/DRepAlwaysNoConfidence.ts:52"
  },
  {
    "prompt": "DRepKeyHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / DRepKeyHash\nIDRep\nIDRepKeyHash\nnew DRepKeyHash(__namedParameters): DRepKeyHash\n__namedParameters\nDRepKeyHash\n__namedParameters: IDRepKeyHash\nIDRepKeyHash\nDRepKeyHash\nDRepKeyHash\nsrc/governance/DRep/DRepKeyHash.ts:26\nreadonly drepType: KeyHash\nreadonly\nKeyHash\nIDRep.drepType\nIDRep\ndrepType\nsrc/governance/DRep/DRepKeyHash.ts:23\nreadonly hash: PubKeyHash\nreadonly\nPubKeyHash\nIDRepKeyHash.hash\nIDRepKeyHash\nhash\nsrc/governance/DRep/DRepKeyHash.ts:24\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/governance/DRep/DRepKeyHash.ts:49\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/governance/DRep/DRepKeyHash.ts:53\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nIDRep.toData\nIDRep\ntoData\nsrc/governance/DRep/DRepKeyHash.ts:36\ntoJson(): object\nobject\nobject\nobject\ndrepType: string\nstring\nhash: string\nstring\nsrc/governance/DRep/DRepKeyHash.ts:76\nstatic fromCborObj(cbor): DRepKeyHash\nstatic\ncbor\nDRepKeyHash\ncbor: CborObj\nCborObj\nDRepKeyHash\nDRepKeyHash\nsrc/governance/DRep/DRepKeyHash.ts:61"
  },
  {
    "prompt": "DRepScript?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / DRepScript\nIDRep\nIDRepScript\nnew DRepScript(__namedParameters): DRepScript\n__namedParameters\nDRepScript\n__namedParameters: IDRepScript\nIDRepScript\nDRepScript\nDRepScript\nsrc/governance/DRep/DRepScript.ts:26\nreadonly drepType: Script\nreadonly\nScript\nIDRep.drepType\nIDRep\ndrepType\nsrc/governance/DRep/DRepScript.ts:23\nreadonly hash: ValidatorHash\nreadonly\nValidatorHash\nIDRepScript.hash\nIDRepScript\nhash\nsrc/governance/DRep/DRepScript.ts:24\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/governance/DRep/DRepScript.ts:50\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/governance/DRep/DRepScript.ts:54\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nIDRep.toData\nIDRep\ntoData\nsrc/governance/DRep/DRepScript.ts:36\ntoJson(): object\nobject\nobject\nobject\ndrepType: string\nstring\nhash: string\nstring\nsrc/governance/DRep/DRepScript.ts:77\nstatic fromCborObj(cbor): DRepScript\nstatic\ncbor\nDRepScript\ncbor: CborObj\nCborObj\nDRepScript\nDRepScript\nsrc/governance/DRep/DRepScript.ts:62"
  },
  {
    "prompt": "GenesisDelegateHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / GenesisDelegateHash\nHash28\nnew GenesisDelegateHash(bs, className): GenesisDelegateHash\nbs\nclassName\nGenesisDelegateHash\nbs: CanBeHash28\nCanBeHash28\nclassName: string = \"Hash28\"\nstring\n\"Hash28\"\nGenesisDelegateHash\nGenesisDelegateHash\nHash28.constructor\nHash28\nconstructor\nsrc/hashes/Hash28/Hash28.ts:26\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash28._bytes\nHash28\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash28._str\nHash28\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash28.asBytes\nHash28\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash28.asString\nHash28\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash28\nHash28\nHash28\nHash28\nHash28.clone\nHash28\nclone\nsrc/hashes/Hash28/Hash28.ts:41\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash28.toBuffer\nHash28\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash28.toBytes\nHash28\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash28.toCbor\nHash28\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash28.toCborObj\nHash28\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash28.toData\nHash28\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash28.toString\nHash28\ntoString\nsrc/hashes/Hash.ts:130\nvalueOf(): string\nstring\nReturns the primitive value of the specified object.\nstring\nstring\nHash28.valueOf\nHash28\nvalueOf\nsrc/hashes/Hash28/Hash28.ts:36\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash28.fromAscii\nHash28\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Hash28\nstatic\ncStr\nHash28\ncStr: CanBeCborString\nCanBeCborString\nHash28\nHash28\nHash28.fromCbor\nHash28\nfromCbor\nsrc/hashes/Hash28/Hash28.ts:46\nstatic fromCborObj(cObj): Hash28\nstatic\ncObj\nHash28\ncObj: CborObj\nCborObj\nHash28\nHash28\nHash28.fromCborObj\nHash28\nfromCborObj\nsrc/hashes/Hash28/Hash28.ts:50\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash28.isStrictInstance\nHash28\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash28.isValidHexValue\nHash28\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash28.toAscii\nHash28\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "GenesisHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / GenesisHash\nHash28\nnew GenesisHash(bs, className): GenesisHash\nbs\nclassName\nGenesisHash\nbs: CanBeHash28\nCanBeHash28\nclassName: string = \"Hash28\"\nstring\n\"Hash28\"\nGenesisHash\nGenesisHash\nHash28.constructor\nHash28\nconstructor\nsrc/hashes/Hash28/Hash28.ts:26\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash28._bytes\nHash28\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash28._str\nHash28\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash28.asBytes\nHash28\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash28.asString\nHash28\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash28\nHash28\nHash28\nHash28\nHash28.clone\nHash28\nclone\nsrc/hashes/Hash28/Hash28.ts:41\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash28.toBuffer\nHash28\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash28.toBytes\nHash28\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash28.toCbor\nHash28\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash28.toCborObj\nHash28\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash28.toData\nHash28\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash28.toString\nHash28\ntoString\nsrc/hashes/Hash.ts:130\nvalueOf(): string\nstring\nReturns the primitive value of the specified object.\nstring\nstring\nHash28.valueOf\nHash28\nvalueOf\nsrc/hashes/Hash28/Hash28.ts:36\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash28.fromAscii\nHash28\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Hash28\nstatic\ncStr\nHash28\ncStr: CanBeCborString\nCanBeCborString\nHash28\nHash28\nHash28.fromCbor\nHash28\nfromCbor\nsrc/hashes/Hash28/Hash28.ts:46\nstatic fromCborObj(cObj): Hash28\nstatic\ncObj\nHash28\ncObj: CborObj\nCborObj\nHash28\nHash28\nHash28.fromCborObj\nHash28\nfromCborObj\nsrc/hashes/Hash28/Hash28.ts:50\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash28.isStrictInstance\nHash28\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash28.isValidHexValue\nHash28\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash28.toAscii\nHash28\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "GovActionInfo?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / GovActionInfo\nIGovAction\nIGovActionInfo\nToCbor\nnew GovActionInfo(_info?): GovActionInfo\n_info\nGovActionInfo\n_info?: IGovActionInfo\nIGovActionInfo\nGovActionInfo\nGovActionInfo\nsrc/governance/GovAction/GovActionInfo.ts:20\nreadonly govActionType: Info\nreadonly\nInfo\nIGovAction.govActionType\nIGovAction\ngovActionType\nsrc/governance/GovAction/GovActionInfo.ts:18\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/governance/GovAction/GovActionInfo.ts:29\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/governance/GovAction/GovActionInfo.ts:33\ntoData(v?): DataConstr\nv\nDataConstr\nv?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nsrc/governance/GovAction/GovActionInfo.ts:40"
  },
  {
    "prompt": "GovActionInitHardFork?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / GovActionInitHardFork\nIGovAction\nIGovActionInitHardFork\nToCbor\nToData\nnew GovActionInitHardFork(__namedParameters): GovActionInitHardFork\n__namedParameters\nGovActionInitHardFork\n__namedParameters: IGovActionInitHardFork\nIGovActionInitHardFork\nGovActionInitHardFork\nGovActionInitHardFork\nsrc/governance/GovAction/GovActionInitHardFork.ts:34\nreadonly govActionId: undefined | TxOutRef\nreadonly\nundefined\nTxOutRef\nIGovActionInitHardFork.govActionId\nIGovActionInitHardFork\ngovActionId\nsrc/governance/GovAction/GovActionInitHardFork.ts:31\nreadonly govActionType: InitHardFork\nreadonly\nInitHardFork\nIGovAction.govActionType\nIGovAction\ngovActionType\nsrc/governance/GovAction/GovActionInitHardFork.ts:30\nreadonly protocolVersion: IProtocolVerisionObj\nreadonly\nIProtocolVerisionObj\nIGovActionInitHardFork.protocolVersion\nIGovActionInitHardFork\nprotocolVersion\nsrc/governance/GovAction/GovActionInitHardFork.ts:32\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/governance/GovAction/GovActionInitHardFork.ts:45\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/governance/GovAction/GovActionInitHardFork.ts:49\ntoData(v?): DataConstr\nv\nDataConstr\nv?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nToData.toData\nToData.toData\nsrc/governance/GovAction/GovActionInitHardFork.ts:58"
  },
  {
    "prompt": "GovActionNewConstitution?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / GovActionNewConstitution\nIGovAction\nIGovActionNewConstitution\nToCbor\nToData\nnew GovActionNewConstitution(__namedParameters): GovActionNewConstitution\n__namedParameters\nGovActionNewConstitution\n__namedParameters: IGovActionNewConstitution\nIGovActionNewConstitution\nGovActionNewConstitution\nGovActionNewConstitution\nsrc/governance/GovAction/GovActionNewConstitution.ts:32\nreadonly constitution: Constitution\nreadonly\nConstitution\nIGovActionNewConstitution.constitution\nIGovActionNewConstitution\nconstitution\nsrc/governance/GovAction/GovActionNewConstitution.ts:30\nreadonly govActionId: undefined | TxOutRef\nreadonly\nundefined\nTxOutRef\nIGovActionNewConstitution.govActionId\nIGovActionNewConstitution\ngovActionId\nsrc/governance/GovAction/GovActionNewConstitution.ts:29\nreadonly govActionType: NewConstitution\nreadonly\nNewConstitution\nIGovAction.govActionType\nIGovAction\ngovActionType\nsrc/governance/GovAction/GovActionNewConstitution.ts:28\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/governance/GovAction/GovActionNewConstitution.ts:43\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/governance/GovAction/GovActionNewConstitution.ts:47\ntoData(v?): DataConstr\nv\nDataConstr\nv?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nToData.toData\nToData.toData\nsrc/governance/GovAction/GovActionNewConstitution.ts:56"
  },
  {
    "prompt": "GovActionNoConfidence?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / GovActionNoConfidence\nIGovAction\nIGovActionNoConfidence\nToCbor\nToData\nnew GovActionNoConfidence(__namedParameters): GovActionNoConfidence\n__namedParameters\nGovActionNoConfidence\n__namedParameters: IGovActionNoConfidence\nIGovActionNoConfidence\nGovActionNoConfidence\nGovActionNoConfidence\nsrc/governance/GovAction/GovActionNoConfidence.ts:28\nreadonly govActionId: undefined | TxOutRef\nreadonly\nundefined\nTxOutRef\nIGovActionNoConfidence.govActionId\nIGovActionNoConfidence\ngovActionId\nsrc/governance/GovAction/GovActionNoConfidence.ts:26\nreadonly govActionType: NoConfidence\nreadonly\nNoConfidence\nIGovAction.govActionType\nIGovAction\ngovActionType\nsrc/governance/GovAction/GovActionNoConfidence.ts:25\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/governance/GovAction/GovActionNoConfidence.ts:38\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/governance/GovAction/GovActionNoConfidence.ts:42\ntoData(v?): DataConstr\nv\nDataConstr\nv?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nToData.toData\nToData.toData\nsrc/governance/GovAction/GovActionNoConfidence.ts:50"
  },
  {
    "prompt": "GovActionParameterChange?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / GovActionParameterChange\nIGovAction\nIGovActionParameterChange\nToCbor\nToData\nnew GovActionParameterChange(__namedParameters): GovActionParameterChange\n__namedParameters\nGovActionParameterChange\n__namedParameters: IGovActionParameterChange\nIGovActionParameterChange\nGovActionParameterChange\nGovActionParameterChange\nsrc/governance/GovAction/GovActionParameterChange.ts:36\nreadonly govActionId: undefined | TxOutRef\nreadonly\nundefined\nTxOutRef\nIGovActionParameterChange.govActionId\nIGovActionParameterChange\ngovActionId\nsrc/governance/GovAction/GovActionParameterChange.ts:32\nreadonly govActionType: ParameterChange\nreadonly\nParameterChange\nIGovAction.govActionType\nIGovAction\ngovActionType\nsrc/governance/GovAction/GovActionParameterChange.ts:31\nreadonly policyHash: undefined | Hash28\nreadonly\nundefined\nHash28\nIGovActionParameterChange.policyHash\nIGovActionParameterChange\npolicyHash\nsrc/governance/GovAction/GovActionParameterChange.ts:34\nreadonly protocolParamsUpdate: Partial ProtocolParameters\nreadonly\nPartial\nProtocolParameters\nIGovActionParameterChange.protocolParamsUpdate\nIGovActionParameterChange\nprotocolParamsUpdate\nsrc/governance/GovAction/GovActionParameterChange.ts:33\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/governance/GovAction/GovActionParameterChange.ts:48\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/governance/GovAction/GovActionParameterChange.ts:52\ntoData(v?): DataConstr\nv\nDataConstr\nv?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nToData.toData\nToData.toData\nsrc/governance/GovAction/GovActionParameterChange.ts:62"
  },
  {
    "prompt": "GovActionTreasuryWithdrawals?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / GovActionTreasuryWithdrawals\nIGovAction\nIGovActionTreasuryWithdrawals\nToCbor\nToData\nnew GovActionTreasuryWithdrawals(__namedParameters): GovActionTreasuryWithdrawals\n__namedParameters\nGovActionTreasuryWithdrawals\n__namedParameters: IGovActionTreasuryWithdrawals\nIGovActionTreasuryWithdrawals\nGovActionTreasuryWithdrawals\nGovActionTreasuryWithdrawals\nsrc/governance/GovAction/GovActionTreasuryWithdrawals.ts:32\nreadonly govActionType: TreasuryWithdrawals\nreadonly\nTreasuryWithdrawals\nIGovAction.govActionType\nIGovAction\ngovActionType\nsrc/governance/GovAction/GovActionTreasuryWithdrawals.ts:28\nreadonly policyHash: undefined | Hash28\nreadonly\nundefined\nHash28\nIGovActionTreasuryWithdrawals.policyHash\nIGovActionTreasuryWithdrawals\npolicyHash\nsrc/governance/GovAction/GovActionTreasuryWithdrawals.ts:30\nreadonly withdrawals: TxWithdrawals\nreadonly\nTxWithdrawals\nIGovActionTreasuryWithdrawals.withdrawals\nIGovActionTreasuryWithdrawals\nwithdrawals\nsrc/governance/GovAction/GovActionTreasuryWithdrawals.ts:29\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/governance/GovAction/GovActionTreasuryWithdrawals.ts:49\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/governance/GovAction/GovActionTreasuryWithdrawals.ts:53\ntoData(v?): DataConstr\nv\nDataConstr\nv?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nToData.toData\nToData.toData\nsrc/governance/GovAction/GovActionTreasuryWithdrawals.ts:62"
  },
  {
    "prompt": "GovActionUpdateCommittee?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / GovActionUpdateCommittee\nIGovAction\nIGovActionUpdateCommittee\nToCbor\nToData\nnew GovActionUpdateCommittee(__namedParameters): GovActionUpdateCommittee\n__namedParameters\nGovActionUpdateCommittee\n__namedParameters: IGovActionUpdateCommittee\nIGovActionUpdateCommittee\nGovActionUpdateCommittee\nGovActionUpdateCommittee\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:64\nreadonly govActionId: undefined | TxOutRef\nreadonly\nundefined\nTxOutRef\nIGovActionUpdateCommittee.govActionId\nIGovActionUpdateCommittee\ngovActionId\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:59\nreadonly govActionType: UpdateCommittee\nreadonly\nUpdateCommittee\nIGovAction.govActionType\nIGovAction\ngovActionType\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:58\nreadonly threshold: CborPositiveRational\nreadonly\nCborPositiveRational\nIGovActionUpdateCommittee.threshold\nIGovActionUpdateCommittee\nthreshold\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:62\nreadonly toAdd: INewCommitteeEntryBI[]\nreadonly\nINewCommitteeEntryBI\nIGovActionUpdateCommittee.toAdd\nIGovActionUpdateCommittee\ntoAdd\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:61\nreadonly toRemove: Credential CredentialType []\nreadonly\nCredential\nCredentialType\nIGovActionUpdateCommittee.toRemove\nIGovActionUpdateCommittee\ntoRemove\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:60\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:80\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:84\ntoData(v?): DataConstr\nv\nDataConstr\nv?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nToData.toData\nToData.toData\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:103"
  },
  {
    "prompt": "Hash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Hash\nHash28\nHash32\nSignature\nCloneable\nHash\nToCbor\nToData\nnew Hash(bs): Hash\nbs\nHash\nbs: string | Uint8Array\nstring\nUint8Array\nHash\nHash\nsrc/hashes/Hash.ts:89\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nsrc/hashes/Hash.ts:125\nclone(): Hash\nHash\nHash\nHash\nCloneable.clone\nCloneable.clone\nsrc/hashes/Hash.ts:156\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nToData.toData\nToData.toData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nsrc/hashes/Hash.ts:130\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Hash\nstatic\ncStr\nHash\ncStr: CanBeCborString\nCanBeCborString\nHash\nHash\nsrc/hashes/Hash.ts:170\nstatic fromCborObj(cObj): Hash\nstatic\ncObj\nHash\ncObj: CborObj\nCborObj\nHash\nHash\nsrc/hashes/Hash.ts:174\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "Hash28?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Hash28\nHash\nValidatorHash\nPubKeyHash\nStakeValidatorHash\nStakeKeyHash\nGenesisDelegateHash\nGenesisHash\nPoolKeyHash\nnew Hash28(bs, className): Hash28\nbs\nclassName\nHash28\nbs: CanBeHash28\nCanBeHash28\nclassName: string = \"Hash28\"\nstring\n\"Hash28\"\nHash28\nHash28\nHash.constructor\nHash\nconstructor\nsrc/hashes/Hash28/Hash28.ts:26\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash._bytes\nHash\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash._str\nHash\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash.asBytes\nHash\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash.asString\nHash\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash28\nHash28\nHash28\nHash28\nHash.clone\nHash\nclone\nsrc/hashes/Hash28/Hash28.ts:41\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash.toBuffer\nHash\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash.toBytes\nHash\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash.toCbor\nHash\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash.toCborObj\nHash\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash.toData\nHash\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash.toString\nHash\ntoString\nsrc/hashes/Hash.ts:130\nvalueOf(): string\nstring\nReturns the primitive value of the specified object.\nstring\nstring\nsrc/hashes/Hash28/Hash28.ts:36\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash.fromAscii\nHash\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Hash28\nstatic\ncStr\nHash28\ncStr: CanBeCborString\nCanBeCborString\nHash28\nHash28\nHash.fromCbor\nHash\nfromCbor\nsrc/hashes/Hash28/Hash28.ts:46\nstatic fromCborObj(cObj): Hash28\nstatic\ncObj\nHash28\ncObj: CborObj\nCborObj\nHash28\nHash28\nHash.fromCborObj\nHash\nfromCborObj\nsrc/hashes/Hash28/Hash28.ts:50\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash.isStrictInstance\nHash\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash.isValidHexValue\nHash\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash.toAscii\nHash\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "Hash32?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Hash32\nHash\nPrivateKey\nPublicKey\nAuxiliaryDataHash\nScriptDataHash\nVRFKeyHash\nVKey\nnew Hash32(bs, className): Hash32\nbs\nclassName\nHash32\nbs: string | Uint8Array | Hash32\nstring\nUint8Array\nHash32\nclassName: string = \"Hash32\"\nstring\n\"Hash32\"\nHash32\nHash32\nHash.constructor\nHash\nconstructor\nsrc/hashes/Hash32/Hash32.ts:25\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash._bytes\nHash\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash._str\nHash\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash.asBytes\nHash\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash.asString\nHash\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash\nHash\nHash\nHash\nHash.clone\nHash\nclone\nsrc/hashes/Hash.ts:156\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash.toBuffer\nHash\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash.toBytes\nHash\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash.toCbor\nHash\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash.toCborObj\nHash\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash.toData\nHash\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash.toString\nHash\ntoString\nsrc/hashes/Hash.ts:130\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash.fromAscii\nHash\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Hash32\nstatic\ncStr\nHash32\ncStr: CanBeCborString\nCanBeCborString\nHash32\nHash32\nHash.fromCbor\nHash\nfromCbor\nsrc/hashes/Hash32/Hash32.ts:35\nstatic fromCborObj(cObj): Hash32\nstatic\ncObj\nHash32\ncObj: CborObj\nCborObj\nHash32\nHash32\nHash.fromCborObj\nHash\nfromCborObj\nsrc/hashes/Hash32/Hash32.ts:39\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash.isStrictInstance\nHash\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash.isValidHexValue\nHash\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash.toAscii\nHash\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "MoveInstantRewardsCert?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / MoveInstantRewardsCert\nToCbor\nToJson\nICert\nnew MoveInstantRewardsCert(__namedParameters): MoveInstantRewardsCert\n__namedParameters\nMoveInstantRewardsCert\n__namedParameters: IMoveInstantRewardsCert\nIMoveInstantRewardsCert\nMoveInstantRewardsCert\nMoveInstantRewardsCert\nsrc/ledger/certs/MoveInstantRewardsCert.ts:102\nreadonly certType: MoveInstantRewards\nreadonly\nMoveInstantRewards\nICert.certType\nICert\ncertType\nsrc/ledger/certs/MoveInstantRewardsCert.ts:93\nreadonly destination: CanBeUInteger | RewardsMap\nreadonly\nCanBeUInteger\nRewardsMap\nIf the second field is a map, funds are moved to stake credentials, otherwise the funds are given to the other accounting pot (eg. source is Reserve, hence founds are going to treasurery)\nsrc/ledger/certs/MoveInstantRewardsCert.ts:100\nreadonly source: InstantRewardsSource\nreadonly\nInstantRewardsSource\nsrc/ledger/certs/MoveInstantRewardsCert.ts:94\ngetRequiredSigners(): Hash28[]\nHash28\nHash28[]\nHash28\nICert.getRequiredSigners\nICert\ngetRequiredSigners\nsrc/ledger/certs/MoveInstantRewardsCert.ts:155\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/ledger/certs/MoveInstantRewardsCert.ts:160\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/ledger/certs/MoveInstantRewardsCert.ts:165\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nICert.toData\nICert\ntoData\nsrc/ledger/certs/MoveInstantRewardsCert.ts:143\ntoJson(): object\nobject\nobject\nobject\ncertType: \"MoveInstantRewards\"\n\"MoveInstantRewards\"\ndestination: string | object[]\nstring\nobject\nsource: \"Reserves\" | \"Treasurery\"\n\"Reserves\"\n\"Treasurery\"\nToJson.toJson\nToJson.toJson\nsrc/ledger/certs/MoveInstantRewardsCert.ts:196\nstatic fromCborObj(cObj): MoveInstantRewardsCert\nstatic\ncObj\nMoveInstantRewardsCert\ncObj: CborObj\nCborObj\nMoveInstantRewardsCert\nMoveInstantRewardsCert\nsrc/ledger/certs/MoveInstantRewardsCert.ts:175"
  },
  {
    "prompt": "PoolKeyHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / PoolKeyHash\nHash28\nnew PoolKeyHash(bs, className): PoolKeyHash\nbs\nclassName\nPoolKeyHash\nbs: CanBeHash28\nCanBeHash28\nclassName: string = \"Hash28\"\nstring\n\"Hash28\"\nPoolKeyHash\nPoolKeyHash\nHash28.constructor\nHash28\nconstructor\nsrc/hashes/Hash28/Hash28.ts:26\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash28._bytes\nHash28\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash28._str\nHash28\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash28.asBytes\nHash28\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash28.asString\nHash28\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash28\nHash28\nHash28\nHash28\nHash28.clone\nHash28\nclone\nsrc/hashes/Hash28/Hash28.ts:41\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash28.toBuffer\nHash28\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash28.toBytes\nHash28\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash28.toCbor\nHash28\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash28.toCborObj\nHash28\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash28.toData\nHash28\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash28.toString\nHash28\ntoString\nsrc/hashes/Hash.ts:130\nvalueOf(): string\nstring\nReturns the primitive value of the specified object.\nstring\nstring\nHash28.valueOf\nHash28\nvalueOf\nsrc/hashes/Hash28/Hash28.ts:36\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash28.fromAscii\nHash28\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Hash28\nstatic\ncStr\nHash28\ncStr: CanBeCborString\nCanBeCborString\nHash28\nHash28\nHash28.fromCbor\nHash28\nfromCbor\nsrc/hashes/Hash28/Hash28.ts:46\nstatic fromCborObj(cObj): Hash28\nstatic\ncObj\nHash28\ncObj: CborObj\nCborObj\nHash28\nHash28\nHash28.fromCborObj\nHash28\nfromCborObj\nsrc/hashes/Hash28/Hash28.ts:50\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash28.isStrictInstance\nHash28\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash28.isValidHexValue\nHash28\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash28.toAscii\nHash28\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "PoolParams?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / PoolParams\nITypedPoolParams\nnew PoolParams(params): PoolParams\nparams\nPoolParams\nparams: IPoolParams\nIPoolParams\nPoolParams\nPoolParams\nsrc/ledger/PoolParams.ts:81\nreadonly cost: bigint\nreadonly\nbigint\nITypedPoolParams.cost\nITypedPoolParams\ncost\nsrc/ledger/PoolParams.ts:74\nreadonly margin: CborPositiveRational\nreadonly\nCborPositiveRational\nITypedPoolParams.margin\nITypedPoolParams\nmargin\nsrc/ledger/PoolParams.ts:75\nreadonly optional metadata: ITypedPoolParamsMetadata\nreadonly\noptional\nITypedPoolParamsMetadata\nITypedPoolParams.metadata\nITypedPoolParams\nmetadata\nsrc/ledger/PoolParams.ts:79\nreadonly operator: PoolKeyHash\nreadonly\nPoolKeyHash\nITypedPoolParams.operator\nITypedPoolParams\noperator\nsrc/ledger/PoolParams.ts:71\nreadonly owners: PubKeyHash[]\nreadonly\nPubKeyHash\nITypedPoolParams.owners\nITypedPoolParams\nowners\nsrc/ledger/PoolParams.ts:77\nreadonly pledge: bigint\nreadonly\nbigint\nITypedPoolParams.pledge\nITypedPoolParams\npledge\nsrc/ledger/PoolParams.ts:73\nreadonly relays: PoolRelay[]\nreadonly\nPoolRelay\nITypedPoolParams.relays\nITypedPoolParams\nrelays\nsrc/ledger/PoolParams.ts:78\nreadonly rewardAccount: StakeAddress StakeAddressType\nreadonly\nStakeAddress\nStakeAddressType\nITypedPoolParams.rewardAccount\nITypedPoolParams\nrewardAccount\nsrc/ledger/PoolParams.ts:76\nreadonly vrfKeyHash: VRFKeyHash\nreadonly\nVRFKeyHash\nITypedPoolParams.vrfKeyHash\nITypedPoolParams\nvrfKeyHash\nsrc/ledger/PoolParams.ts:72\ntoCborObjArray(): CborObj[]\nCborObj\nCborObj[]\nCborObj\nsrc/ledger/PoolParams.ts:190\ntoJson(): object\nobject\nobject\nobject\ncost: string\nstring\nmargin: number\nnumber\nmetadata: undefined | object\nundefined\nobject\noperator: string\nstring\nowners: string[]\nstring\npledge: string\nstring\nrelays: (object | object | object)[]\nobject\nobject\nobject\nrewardAccount: StakeAddress StakeAddressType\nStakeAddress\nStakeAddressType\nvrfKeyHash: string\nstring\nsrc/ledger/PoolParams.ts:263\nstatic fromCborObjArray(__namedParameters): PoolParams\nstatic\n__namedParameters\nPoolParams\n__namedParameters: CborObj[]\nCborObj\nPoolParams\nPoolParams\nsrc/ledger/PoolParams.ts:210"
  },
  {
    "prompt": "PrivateKey?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / PrivateKey\nHash32\nnew PrivateKey(bs, className): PrivateKey\nbs\nclassName\nPrivateKey\nbs: string | Uint8Array | Hash32\nstring\nUint8Array\nHash32\nclassName: string = \"Hash32\"\nstring\n\"Hash32\"\nPrivateKey\nPrivateKey\nHash32.constructor\nHash32\nconstructor\nsrc/hashes/Hash32/Hash32.ts:25\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash32._bytes\nHash32\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash32._str\nHash32\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash32.asBytes\nHash32\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash32.asString\nHash32\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash\nHash\nHash\nHash\nHash32.clone\nHash32\nclone\nsrc/hashes/Hash.ts:156\nderivePublicKey(): PublicKey\nPublicKey\nPublicKey\nPublicKey\nsrc/credentials/PrivateKey.ts:8\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash32.toBuffer\nHash32\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash32.toBytes\nHash32\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash32.toCbor\nHash32\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash32.toCborObj\nHash32\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash32.toData\nHash32\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash32.toString\nHash32\ntoString\nsrc/hashes/Hash.ts:130\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash32.fromAscii\nHash32\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): PrivateKey\nstatic\ncStr\nPrivateKey\ncStr: CanBeCborString\nCanBeCborString\nPrivateKey\nPrivateKey\nHash32.fromCbor\nHash32\nfromCbor\nsrc/credentials/PrivateKey.ts:19\nstatic fromCborObj(cObj): PrivateKey\nstatic\ncObj\nPrivateKey\ncObj: CborObj\nCborObj\nPrivateKey\nPrivateKey\nHash32.fromCborObj\nHash32\nfromCborObj\nsrc/credentials/PrivateKey.ts:23\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash32.isStrictInstance\nHash32\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash32.isValidHexValue\nHash32\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash32.toAscii\nHash32\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "ProposalProcedure?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ProposalProcedure\nIProposalProcedure\nToCbor\nToData\nnew ProposalProcedure(__namedParameters): ProposalProcedure\n__namedParameters\nProposalProcedure\n__namedParameters: IProposalProcedure\nIProposalProcedure\nProposalProcedure\nProposalProcedure\nsrc/governance/ProposalProcedure.ts:38\nreadonly anchor: Anchor\nreadonly\nAnchor\nIProposalProcedure.anchor\nIProposalProcedure\nanchor\nsrc/governance/ProposalProcedure.ts:36\nreadonly deposit: bigint\nreadonly\nbigint\nIProposalProcedure.deposit\nIProposalProcedure\ndeposit\nsrc/governance/ProposalProcedure.ts:33\nreadonly govAction: GovAction\nreadonly\nGovAction\nIProposalProcedure.govAction\nIProposalProcedure\ngovAction\nsrc/governance/ProposalProcedure.ts:35\nreadonly rewardAccount: StakeAddress StakeAddressType\nreadonly\nStakeAddress\nStakeAddressType\nIProposalProcedure.rewardAccount\nIProposalProcedure\nrewardAccount\nsrc/governance/ProposalProcedure.ts:34\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/governance/ProposalProcedure.ts:50\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/governance/ProposalProcedure.ts:54\ntoData(v?): DataConstr\nv\nDataConstr\nv?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nToData.toData\nToData.toData\nsrc/governance/ProposalProcedure.ts:64"
  },
  {
    "prompt": "PubKeyHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / PubKeyHash\nHash28\nnew PubKeyHash(bs, className): PubKeyHash\nbs\nclassName\nPubKeyHash\nbs: CanBeHash28\nCanBeHash28\nclassName: string = \"Hash28\"\nstring\n\"Hash28\"\nPubKeyHash\nPubKeyHash\nHash28.constructor\nHash28\nconstructor\nsrc/hashes/Hash28/Hash28.ts:26\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash28._bytes\nHash28\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash28._str\nHash28\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash28.asBytes\nHash28\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash28.asString\nHash28\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash28\nHash28\nHash28\nHash28\nHash28.clone\nHash28\nclone\nsrc/hashes/Hash28/Hash28.ts:41\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash28.toBuffer\nHash28\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash28.toBytes\nHash28\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash28.toCbor\nHash28\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash28.toCborObj\nHash28\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash28.toData\nHash28\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash28.toString\nHash28\ntoString\nsrc/hashes/Hash.ts:130\nvalueOf(): string\nstring\nReturns the primitive value of the specified object.\nstring\nstring\nHash28.valueOf\nHash28\nvalueOf\nsrc/hashes/Hash28/Hash28.ts:36\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash28.fromAscii\nHash28\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): PubKeyHash\nstatic\ncStr\nPubKeyHash\ncStr: CanBeCborString\nCanBeCborString\nPubKeyHash\nPubKeyHash\nHash28.fromCbor\nHash28\nfromCbor\nsrc/credentials/PubKeyHash.ts:6\nstatic fromCborObj(cObj): PubKeyHash\nstatic\ncObj\nPubKeyHash\ncObj: CborObj\nCborObj\nPubKeyHash\nPubKeyHash\nHash28.fromCborObj\nHash28\nfromCborObj\nsrc/credentials/PubKeyHash.ts:10\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash28.isStrictInstance\nHash28\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash28.isValidHexValue\nHash28\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash28.toAscii\nHash28\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "PublicKey?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / PublicKey\nHash32\nnew PublicKey(pubKey): PublicKey\npubKey\nPublicKey\npubKey: string | Uint8Array | Hash32\nstring\nUint8Array\nHash32\nPublicKey\nPublicKey\nHash32.constructor\nHash32\nconstructor\nsrc/credentials/PublicKey.ts:11\nreadonly hash: PubKeyHash\nreadonly\nPubKeyHash\nsrc/credentials/PublicKey.ts:9\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash32._bytes\nHash32\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash32._str\nHash32\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash32.asBytes\nHash32\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash32.asString\nHash32\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash\nHash\nHash\nHash\nHash32.clone\nHash32\nclone\nsrc/hashes/Hash.ts:156\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash32.toBuffer\nHash32\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash32.toBytes\nHash32\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash32.toCbor\nHash32\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash32.toCborObj\nHash32\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash32.toData\nHash32\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash32.toString\nHash32\ntoString\nsrc/hashes/Hash.ts:130\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash32.fromAscii\nHash32\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): PublicKey\nstatic\ncStr\nPublicKey\ncStr: CanBeCborString\nCanBeCborString\nPublicKey\nPublicKey\nHash32.fromCbor\nHash32\nfromCbor\nsrc/credentials/PublicKey.ts:40\nstatic fromCborObj(cObj): PublicKey\nstatic\ncObj\nPublicKey\ncObj: CborObj\nCborObj\nPublicKey\nPublicKey\nHash32.fromCborObj\nHash32\nfromCborObj\nsrc/credentials/PublicKey.ts:44\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash32.isStrictInstance\nHash32\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash32.isValidHexValue\nHash32\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash32.toAscii\nHash32\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "ScriptDataHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ScriptDataHash\nHash32\nnew ScriptDataHash(bs, className): ScriptDataHash\nbs\nclassName\nScriptDataHash\nbs: string | Uint8Array | Hash32\nstring\nUint8Array\nHash32\nclassName: string = \"Hash32\"\nstring\n\"Hash32\"\nScriptDataHash\nScriptDataHash\nHash32.constructor\nHash32\nconstructor\nsrc/hashes/Hash32/Hash32.ts:25\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash32._bytes\nHash32\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash32._str\nHash32\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash32.asBytes\nHash32\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash32.asString\nHash32\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash\nHash\nHash\nHash\nHash32.clone\nHash32\nclone\nsrc/hashes/Hash.ts:156\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash32.toBuffer\nHash32\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash32.toBytes\nHash32\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash32.toCbor\nHash32\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash32.toCborObj\nHash32\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash32.toData\nHash32\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash32.toString\nHash32\ntoString\nsrc/hashes/Hash.ts:130\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash32.fromAscii\nHash32\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Hash32\nstatic\ncStr\nHash32\ncStr: CanBeCborString\nCanBeCborString\nHash32\nHash32\nHash32.fromCbor\nHash32\nfromCbor\nsrc/hashes/Hash32/Hash32.ts:35\nstatic fromCborObj(cObj): Hash32\nstatic\ncObj\nHash32\ncObj: CborObj\nCborObj\nHash32\nHash32\nHash32.fromCborObj\nHash32\nfromCborObj\nsrc/hashes/Hash32/Hash32.ts:39\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash32.isStrictInstance\nHash32\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash32.isValidHexValue\nHash32\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash32.toAscii\nHash32\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "Signature?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Signature\nHash\nnew Signature(bs): Signature\nbs\nSignature\nbs: string | Uint8Array | Signature\nstring\nUint8Array\nSignature\nSignature\nSignature\nHash.constructor\nHash\nconstructor\nsrc/hashes/Signature/index.ts:7\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash._bytes\nHash\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash._str\nHash\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash.asBytes\nHash\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash.asString\nHash\nasString\nsrc/hashes/Hash.ts:125\nclone(): Signature\nSignature\nSignature\nSignature\nHash.clone\nHash\nclone\nsrc/hashes/Signature/index.ts:17\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash.toBuffer\nHash\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash.toBytes\nHash\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash.toCbor\nHash\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash.toCborObj\nHash\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash.toData\nHash\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash.toString\nHash\ntoString\nsrc/hashes/Hash.ts:130\nvalueOf(): string\nstring\nReturns the primitive value of the specified object.\nstring\nstring\nsrc/hashes/Signature/index.ts:22\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash.fromAscii\nHash\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Signature\nstatic\ncStr\nSignature\ncStr: CanBeCborString\nCanBeCborString\nSignature\nSignature\nHash.fromCbor\nHash\nfromCbor\nsrc/hashes/Signature/index.ts:27\nstatic fromCborObj(cObj): Signature\nstatic\ncObj\nSignature\ncObj: CborObj\nCborObj\nSignature\nSignature\nHash.fromCborObj\nHash\nfromCborObj\nsrc/hashes/Signature/index.ts:31\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash.isStrictInstance\nHash\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash.isValidHexValue\nHash\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash.toAscii\nHash\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "StakeAddress?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / StakeAddress\nT extends StakeAddressType = StakeAddressType\nStakeAddressType\nStakeAddressType\nnew StakeAddress T (network, credentials, type?): StakeAddress T\nT\nnetwork\ncredentials\ntype\nStakeAddress\nT\nnetwork: NetworkT\nNetworkT\ncredentials: Hash28\nHash28\ntype?: T\nT\nStakeAddress T\nStakeAddress\nT\nsrc/ledger/StakeAddress.ts:26\nreadonly credentials: StakeAddressCredentials T\nreadonly\nStakeAddressCredentials\nT\nsrc/ledger/StakeAddress.ts:24\nreadonly network: NetworkT\nreadonly\nNetworkT\nsrc/ledger/StakeAddress.ts:22\nreadonly type: T\nreadonly\nT\nsrc/ledger/StakeAddress.ts:23\nclone(): StakeAddress T\nStakeAddress\nT\nStakeAddress T\nStakeAddress\nT\nsrc/ledger/StakeAddress.ts:66\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nsrc/ledger/StakeAddress.ts:101\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nsrc/ledger/StakeAddress.ts:129\ntoCredential(): Credential CredentialType\nCredential\nCredentialType\nCredential CredentialType\nCredential\nCredentialType\nsrc/ledger/StakeAddress.ts:146\ntoStakeCredentials(): StakeCredentials T\nStakeCredentials\nT\nStakeCredentials T\nStakeCredentials\nT\nsrc/ledger/StakeAddress.ts:154\ntoString(): StakeAddressBech32\nStakeAddressBech32\nStakeAddressBech32\nStakeAddressBech32\nsrc/ledger/StakeAddress.ts:75\nstatic fromBytes(bs, netwok, type): StakeAddress StakeAddressType\nstatic\nbs\nnetwok\ntype\nStakeAddress\nStakeAddressType\nbs: string | Uint8Array | byte[]\nstring\nUint8Array\nbyte\nnetwok: NetworkT = \"mainnet\"\nNetworkT\n\"mainnet\"\ntype: StakeAddressType = \"stakeKey\"\nStakeAddressType\n\"stakeKey\"\nStakeAddress StakeAddressType\nStakeAddress\nStakeAddressType\nsrc/ledger/StakeAddress.ts:106\nstatic fromCbor(cStr): StakeAddress StakeAddressType\nstatic\ncStr\nStakeAddress\nStakeAddressType\ncStr: CanBeCborString\nCanBeCborString\nStakeAddress StakeAddressType\nStakeAddress\nStakeAddressType\nsrc/ledger/StakeAddress.ts:134\nstatic fromCborObj(cObj): StakeAddress StakeAddressType\nstatic\ncObj\nStakeAddress\nStakeAddressType\ncObj: CborObj\nCborObj\nStakeAddress StakeAddressType\nStakeAddress\nStakeAddressType\nsrc/ledger/StakeAddress.ts:138\nstatic fromString(str): StakeAddress StakeAddressType\nstatic\nstr\nStakeAddress\nStakeAddressType\nstr: string\nstring\nStakeAddress StakeAddressType\nStakeAddress\nStakeAddressType\nsrc/ledger/StakeAddress.ts:83\nstatic fromString T (str, type): StakeAddress T\nstatic\nT\nstr\ntype\nStakeAddress\nT\nT extends StakeAddressType = StakeAddressType\nStakeAddressType\nStakeAddressType\nstr: string\nstring\ntype: T\nT\nStakeAddress T\nStakeAddress\nT\nsrc/ledger/StakeAddress.ts:84"
  },
  {
    "prompt": "StakeCredentials?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / StakeCredentials\nT extends StakeCredentialsType = StakeCredentialsType\nStakeCredentialsType\nStakeCredentialsType\nToCbor\nToData\nnew StakeCredentials T (type, hash): StakeCredentials T\nT\ntype\nhash\nStakeCredentials\nT\ntype: T\nT\nhash: StakeHash T\nStakeHash\nT\nStakeCredentials T\nStakeCredentials\nT\nsrc/credentials/StakeCredentials.ts:27\nreadonly hash: StakeHash T\nreadonly\nStakeHash\nT\nsrc/credentials/StakeCredentials.ts:25\nreadonly type: T\nreadonly\nT\nsrc/credentials/StakeCredentials.ts:24\nclone(): StakeCredentials T\nStakeCredentials\nT\nStakeCredentials T\nStakeCredentials\nT\nsrc/credentials/StakeCredentials.ts:74\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/credentials/StakeCredentials.ts:112\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/credentials/StakeCredentials.ts:117\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nToData.toData\nToData.toData\nsrc/credentials/StakeCredentials.ts:82\ntoJson(): object | object\nobject\nobject\nobject | object\nobject\nobject\nsrc/credentials/StakeCredentials.ts:164\nstatic fromCbor(cObj): StakeCredentials StakeCredentialsType\nstatic\ncObj\nStakeCredentials\nStakeCredentialsType\ncObj: CanBeCborString\nCanBeCborString\nStakeCredentials StakeCredentialsType\nStakeCredentials\nStakeCredentialsType\nsrc/credentials/StakeCredentials.ts:130\nstatic fromCborObj(cObj): StakeCredentials StakeCredentialsType\nstatic\ncObj\nStakeCredentials\nStakeCredentialsType\ncObj: CborObj\nCborObj\nStakeCredentials StakeCredentialsType\nStakeCredentials\nStakeCredentialsType\nsrc/credentials/StakeCredentials.ts:134"
  },
  {
    "prompt": "StakeKeyHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / StakeKeyHash\nHash28\nnew StakeKeyHash(bs, className): StakeKeyHash\nbs\nclassName\nStakeKeyHash\nbs: CanBeHash28\nCanBeHash28\nclassName: string = \"Hash28\"\nstring\n\"Hash28\"\nStakeKeyHash\nStakeKeyHash\nHash28.constructor\nHash28\nconstructor\nsrc/hashes/Hash28/Hash28.ts:26\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash28._bytes\nHash28\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash28._str\nHash28\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash28.asBytes\nHash28\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash28.asString\nHash28\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash28\nHash28\nHash28\nHash28\nHash28.clone\nHash28\nclone\nsrc/hashes/Hash28/Hash28.ts:41\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash28.toBuffer\nHash28\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash28.toBytes\nHash28\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash28.toCbor\nHash28\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash28.toCborObj\nHash28\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash28.toData\nHash28\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash28.toString\nHash28\ntoString\nsrc/hashes/Hash.ts:130\nvalueOf(): string\nstring\nReturns the primitive value of the specified object.\nstring\nstring\nHash28.valueOf\nHash28\nvalueOf\nsrc/hashes/Hash28/Hash28.ts:36\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash28.fromAscii\nHash28\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Hash28\nstatic\ncStr\nHash28\ncStr: CanBeCborString\nCanBeCborString\nHash28\nHash28\nHash28.fromCbor\nHash28\nfromCbor\nsrc/hashes/Hash28/Hash28.ts:46\nstatic fromCborObj(cObj): Hash28\nstatic\ncObj\nHash28\ncObj: CborObj\nCborObj\nHash28\nHash28\nHash28.fromCborObj\nHash28\nfromCborObj\nsrc/hashes/Hash28/Hash28.ts:50\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash28.isStrictInstance\nHash28\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash28.isValidHexValue\nHash28\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash28.toAscii\nHash28\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "StakeValidatorHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / StakeValidatorHash\nHash28\nnew StakeValidatorHash(bs, className): StakeValidatorHash\nbs\nclassName\nStakeValidatorHash\nbs: CanBeHash28\nCanBeHash28\nclassName: string = \"Hash28\"\nstring\n\"Hash28\"\nStakeValidatorHash\nStakeValidatorHash\nHash28.constructor\nHash28\nconstructor\nsrc/hashes/Hash28/Hash28.ts:26\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash28._bytes\nHash28\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash28._str\nHash28\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash28.asBytes\nHash28\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash28.asString\nHash28\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash28\nHash28\nHash28\nHash28\nHash28.clone\nHash28\nclone\nsrc/hashes/Hash28/Hash28.ts:41\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash28.toBuffer\nHash28\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash28.toBytes\nHash28\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash28.toCbor\nHash28\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash28.toCborObj\nHash28\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash28.toData\nHash28\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash28.toString\nHash28\ntoString\nsrc/hashes/Hash.ts:130\nvalueOf(): string\nstring\nReturns the primitive value of the specified object.\nstring\nstring\nHash28.valueOf\nHash28\nvalueOf\nsrc/hashes/Hash28/Hash28.ts:36\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash28.fromAscii\nHash28\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Hash28\nstatic\ncStr\nHash28\ncStr: CanBeCborString\nCanBeCborString\nHash28\nHash28\nHash28.fromCbor\nHash28\nfromCbor\nsrc/hashes/Hash28/Hash28.ts:46\nstatic fromCborObj(cObj): Hash28\nstatic\ncObj\nHash28\ncObj: CborObj\nCborObj\nHash28\nHash28\nHash28.fromCborObj\nHash28\nfromCborObj\nsrc/hashes/Hash28/Hash28.ts:50\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash28.isStrictInstance\nHash28\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash28.isValidHexValue\nHash28\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash28.toAscii\nHash28\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "TxBody?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxBody\nITxBody\nToCbor\nToJson\nnew TxBody(body): TxBody\nbody\nTxBody\nbody: ITxBody\nITxBody\nobject describing the transaction\nTxBody\nTxBody\nonly if the the body parameter does not respect the ITxBody interface DOES NOT THROW if the transaction is unbalanced; that needs to be checked using TxBody.isValueConserved static method\nbody\nITxBody\nTxBody.isValueConserved\nsrc/tx/body/TxBody.ts:142\nreadonly optional auxDataHash: AuxiliaryDataHash\nreadonly\noptional\nAuxiliaryDataHash\nITxBody.auxDataHash\nITxBody\nauxDataHash\nsrc/tx/body/TxBody.ts:115\nreadonly optional certs: Certificate[]\nreadonly\noptional\nCertificate\nITxBody.certs\nITxBody\ncerts\nsrc/tx/body/TxBody.ts:112\nreadonly optional collateralInputs: UTxO[]\nreadonly\noptional\nUTxO\nITxBody.collateralInputs\nITxBody\ncollateralInputs\nsrc/tx/body/TxBody.ts:119\nreadonly optional collateralReturn: TxOut\nreadonly\noptional\nTxOut\nITxBody.collateralReturn\nITxBody\ncollateralReturn\nsrc/tx/body/TxBody.ts:122\nreadonly optional currentTreasuryValue: bigint\nreadonly\noptional\nbigint\nITxBody.currentTreasuryValue\nITxBody\ncurrentTreasuryValue\nsrc/tx/body/TxBody.ts:128\nreadonly optional donation: bigint\nreadonly\noptional\nbigint\nITxBody.donation\nITxBody\ndonation\nsrc/tx/body/TxBody.ts:129\nreadonly fee: bigint\nreadonly\nbigint\nITxBody.fee\nITxBody\nfee\nsrc/tx/body/TxBody.ts:110\nreadonly hash: Hash32\nreadonly\nHash32\ngetter\nsrc/tx/body/TxBody.ts:134\nreadonly inputs: [UTxO, ...UTxO[]]\nreadonly\nUTxO\n...UTxO[]\nITxBody.inputs\nITxBody\ninputs\nsrc/tx/body/TxBody.ts:108\nreadonly optional mint: Value\nreadonly\noptional\nValue\nITxBody.mint\nITxBody\nmint\nsrc/tx/body/TxBody.ts:117\nreadonly optional network: NetworkT\nreadonly\noptional\nNetworkT\nITxBody.network\nITxBody\nnetwork\nsrc/tx/body/TxBody.ts:121\nreadonly outputs: TxOut[]\nreadonly\nTxOut\nITxBody.outputs\nITxBody\noutputs\nsrc/tx/body/TxBody.ts:109\nreadonly optional proposalProcedures: ProposalProcedure[]\nreadonly\noptional\nProposalProcedure\nITxBody.proposalProcedures\nITxBody\nproposalProcedures\nsrc/tx/body/TxBody.ts:127\nreadonly optional protocolUpdate: LegacyPPUpdateProposal\nreadonly\noptional\nLegacyPPUpdateProposal\nITxBody.protocolUpdate\nITxBody\nprotocolUpdate\nsrc/tx/body/TxBody.ts:114\nreadonly optional refInputs: UTxO[]\nreadonly\noptional\nUTxO\nITxBody.refInputs\nITxBody\nrefInputs\nsrc/tx/body/TxBody.ts:124\nreadonly optional requiredSigners: PubKeyHash[]\nreadonly\noptional\nPubKeyHash\nITxBody.requiredSigners\nITxBody\nrequiredSigners\nsrc/tx/body/TxBody.ts:120\nreadonly optional scriptDataHash: ScriptDataHash\nreadonly\noptional\nScriptDataHash\nITxBody.scriptDataHash\nITxBody\nscriptDataHash\nsrc/tx/body/TxBody.ts:118\nreadonly optional totCollateral: bigint\nreadonly\noptional\nbigint\nITxBody.totCollateral\nITxBody\ntotCollateral\nsrc/tx/body/TxBody.ts:123\nreadonly optional ttl: bigint\nreadonly\noptional\nbigint\nITxBody.ttl\nITxBody\nttl\nsrc/tx/body/TxBody.ts:111\nreadonly optional validityIntervalStart: bigint\nreadonly\noptional\nbigint\nITxBody.validityIntervalStart\nITxBody\nvalidityIntervalStart\nsrc/tx/body/TxBody.ts:116\nreadonly optional votingProcedures: VotingProcedures\nreadonly\noptional\nVotingProcedures\nITxBody.votingProcedures\nITxBody\nvotingProcedures\nsrc/tx/body/TxBody.ts:126\nreadonly optional withdrawals: TxWithdrawals\nreadonly\noptional\nTxWithdrawals\nITxBody.withdrawals\nITxBody\nwithdrawals\nsrc/tx/body/TxBody.ts:113\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/body/TxBody.ts:465\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/body/TxBody.ts:469\ntoJson(): object\nobject\nobject\nobject\nauxDataHash: undefined | string\nundefined\nstring\ncerts: undefined | (object | object | object | object | object | object | object | object | object | object | object | object | object | object | object | object | object | object | object)[]\nundefined\nobject\nobject\nobject\nobject\nobject\nobject\nobject\nobject\nobject\nobject\nobject\nobject\nobject\nobject\nobject\nobject\nobject\nobject\nobject\ncollateralInputs: undefined | object[]\nundefined\nobject\ncollateralReturn: undefined | object\nundefined\nobject\nfee: string\nstring\ninputs: object[]\nobject\nmint: undefined | ValueJson\nundefined\nValueJson\nnetwork: undefined | NetworkT\nundefined\nNetworkT\noutputs: object[]\nobject\nprotocolUpdate: undefined | object\nundefined\nobject\nrefInputs: undefined | object[]\nundefined\nobject\nrequiredSigners: undefined | string[]\nundefined\nstring\nscriptDataHash: undefined | string\nundefined\nstring\ntotCollateral: undefined | string\nundefined\nstring\nttl: undefined | string\nundefined\nstring\nvalidityIntervalStart: undefined | string\nundefined\nstring\nwithdrawals: undefined | object\nundefined\nobject\nToJson.toJson\nToJson.toJson\nsrc/tx/body/TxBody.ts:641\nstatic fromCbor(cStr): TxBody\nstatic\ncStr\nTxBody\ncStr: CanBeCborString\nCanBeCborString\nTxBody\nTxBody\nsrc/tx/body/TxBody.ts:557\nstatic fromCborObj(cObj): TxBody\nstatic\ncObj\nTxBody\ncObj: CborObj\nCborObj\nTxBody\nTxBody\nsrc/tx/body/TxBody.ts:561\nstatic isValueConserved(tx): boolean\nstatic\ntx\nboolean\ntests that inputs + withdrawals + refund + mints === outputs + burns + deposit + fee\ntx: TxBody\nTxBody\nboolean\nboolean\nadd mints and burns\nuntil mints and burns are added\nsrc/tx/body/TxBody.ts:673"
  },
  {
    "prompt": "TxIn?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxIn\nUTxO\nnew TxIn(utxo): TxIn\nutxo\nTxIn\nutxo: IUTxO\nIUTxO\nTxIn\nTxIn\nUTxO.constructor\nUTxO\nconstructor\nsrc/tx/body/output/UTxO.ts:32\nreadonly resolved: TxOut\nreadonly\nTxOut\nUTxO.resolved\nUTxO\nresolved\nsrc/tx/body/output/UTxO.ts:30\nreadonly utxoRef: TxOutRef\nreadonly\nTxOutRef\nUTxO.utxoRef\nUTxO\nutxoRef\nsrc/tx/body/output/UTxO.ts:29\nclone(): UTxO\nUTxO\nUTxO\nUTxO\nUTxO.clone\nUTxO\nclone\nsrc/tx/body/output/UTxO.ts:47\ntoCbor(): CborString\nCborString\nCborString\nCborString\nUTxO.toCbor\nUTxO\ntoCbor\nsrc/tx/body/output/UTxO.ts:63\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nUTxO.toCborObj\nUTxO\ntoCborObj\nsrc/tx/body/output/UTxO.ts:67\ntoData(version?): Data\nversion\nData\nversion?: ToDataVersion\nToDataVersion\nData\nData\nUTxO.toData\nUTxO\ntoData\nsrc/tx/body/output/UTxO.ts:52\ntoJson(): object\nobject\nobject\nobject\nresolved: object\nobject\naddress: `addr1${string}` | `addr_test1${string}`\ndatum: any\nany\nrefScript: undefined | ScriptSignature | ScriptAll | ScriptAny | ScriptAtLeast | ScriptAfter | ScriptBefore | object\nundefined\nScriptSignature\nScriptAll\nScriptAny\nScriptAtLeast\nScriptAfter\nScriptBefore\nobject\nvalue: ValueJson\nValueJson\nutxoRef: UTxORefJson\nUTxORefJson\nUTxO.toJson\nUTxO\ntoJson\nsrc/tx/body/output/UTxO.ts:107\nstatic fromCbor(cStr): UTxO\nstatic\ncStr\nUTxO\ncStr: CanBeCborString\nCanBeCborString\nUTxO\nUTxO\nUTxO.fromCbor\nUTxO\nfromCbor\nsrc/tx/body/output/UTxO.ts:75\nstatic fromCborObj(cObj): UTxO\nstatic\ncObj\nUTxO\ncObj: CborObj\nCborObj\nUTxO\nUTxO\nUTxO.fromCborObj\nUTxO\nfromCborObj\nsrc/tx/body/output/UTxO.ts:79\nstatic sort(a, b): number\nstatic\na\nb\nnumber\na: IUTxO\nIUTxO\nb: IUTxO\nIUTxO\nnumber\nnumber\nUTxO.sort\nUTxO\nsort\nsrc/tx/body/output/UTxO.ts:115"
  },
  {
    "prompt": "TxMetadata?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxMetadata\nToCbor\nToJson\nnew TxMetadata(metadata): TxMetadata\nmetadata\nTxMetadata\nmetadata: ITxMetadata\nITxMetadata\nTxMetadata\nTxMetadata\nsrc/tx/metadata/TxMetadata.ts:19\nreadonly metadata: ITxMetadataStr\nreadonly\nITxMetadataStr\nsrc/tx/metadata/TxMetadata.ts:17\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/metadata/TxMetadata.ts:49\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/metadata/TxMetadata.ts:53\ntoJson(): any\nany\nany\nany\nToJson.toJson\nToJson.toJson\nsrc/tx/metadata/TxMetadata.ts:92\nstatic fromCbor(cStr): TxMetadata\nstatic\ncStr\nTxMetadata\ncStr: CanBeCborString\nCanBeCborString\nTxMetadata\nTxMetadata\nsrc/tx/metadata/TxMetadata.ts:65\nstatic fromCborObj(cObj): TxMetadata\nstatic\ncObj\nTxMetadata\ncObj: CborObj\nCborObj\nTxMetadata\nTxMetadata\nsrc/tx/metadata/TxMetadata.ts:69"
  },
  {
    "prompt": "TxMetadatumBytes?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxMetadatumBytes\nToCbor\nToJson\nnew TxMetadatumBytes(bytes): TxMetadatumBytes\nbytes\nTxMetadatumBytes\nbytes: ByteString | Uint8Array\nByteString\nUint8Array\nTxMetadatumBytes\nTxMetadatumBytes\nsrc/tx/metadata/TxMetadatum.ts:191\nreadonly bytes: Uint8Array\nreadonly\nUint8Array\nsrc/tx/metadata/TxMetadatum.ts:189\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/metadata/TxMetadatum.ts:200\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/metadata/TxMetadatum.ts:204\ntoJson(): object\nobject\nobject\nobject\nbytes: string\nstring\nToJson.toJson\nToJson.toJson\nsrc/tx/metadata/TxMetadatum.ts:225"
  },
  {
    "prompt": "TxMetadatumInt?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxMetadatumInt\nToCbor\nToJson\nnew TxMetadatumInt(n): TxMetadatumInt\nn\nTxMetadatumInt\nn: number | bigint\nnumber\nbigint\nTxMetadatumInt\nTxMetadatumInt\nsrc/tx/metadata/TxMetadatum.ts:162\nreadonly n: bigint\nreadonly\nbigint\nsrc/tx/metadata/TxMetadatum.ts:160\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/metadata/TxMetadatum.ts:171\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/metadata/TxMetadatum.ts:175\ntoJson(): object\nobject\nobject\nobject\nint: string\nstring\nToJson.toJson\nToJson.toJson\nsrc/tx/metadata/TxMetadatum.ts:180"
  },
  {
    "prompt": "TxMetadatumList?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxMetadatumList\nToCbor\nToJson\nnew TxMetadatumList(map): TxMetadatumList\nmap\nTxMetadatumList\nmap: TxMetadatum[]\nTxMetadatum\nTxMetadatumList\nTxMetadatumList\nsrc/tx/metadata/TxMetadatum.ts:128\nreadonly list: TxMetadatum[]\nreadonly\nTxMetadatum\nsrc/tx/metadata/TxMetadatum.ts:126\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/metadata/TxMetadatum.ts:142\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/metadata/TxMetadatum.ts:146\ntoJson(): any[]\nany\nany[]\nany\nToJson.toJson\nToJson.toJson\nsrc/tx/metadata/TxMetadatum.ts:151"
  },
  {
    "prompt": "TxMetadatumMap?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxMetadatumMap\nToCbor\nToJson\nnew TxMetadatumMap(map): TxMetadatumMap\nmap\nTxMetadatumMap\nmap: TxMetadatumMapEntry[]\nTxMetadatumMapEntry\nTxMetadatumMap\nTxMetadatumMap\nsrc/tx/metadata/TxMetadatum.ts:82\nreadonly map: TxMetadatumMapEntry[]\nreadonly\nTxMetadatumMapEntry\nsrc/tx/metadata/TxMetadatum.ts:80\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/metadata/TxMetadatum.ts:96\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/metadata/TxMetadatum.ts:100\ntoJson(): object[]\nobject\nobject[]\nobject\nToJson.toJson\nToJson.toJson\nsrc/tx/metadata/TxMetadatum.ts:112"
  },
  {
    "prompt": "TxMetadatumText?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxMetadatumText\nToCbor\nToJson\nnew TxMetadatumText(text): TxMetadatumText\ntext\nTxMetadatumText\ntext: string\nstring\nTxMetadatumText\nTxMetadatumText\nsrc/tx/metadata/TxMetadatum.ts:236\nreadonly text: string\nreadonly\nstring\nsrc/tx/metadata/TxMetadatum.ts:234\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/metadata/TxMetadatum.ts:250\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/metadata/TxMetadatum.ts:254\ntoJson(): object\nobject\nobject\nobject\ntext: string\nstring\nToJson.toJson\nToJson.toJson\nsrc/tx/metadata/TxMetadatum.ts:275"
  },
  {
    "prompt": "TxOut?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxOut\nITxOut\nToCbor\nCloneable\nTxOut\nToData\nToJson\nnew TxOut(txOutput): TxOut\ntxOutput\nTxOut\ntxOutput: ITxOut\nITxOut\nTxOut\nTxOut\nsrc/tx/body/output/TxOut.ts:46\nreadonly address: Address\nreadonly\nAddress\nITxOut.address\nITxOut\naddress\nsrc/tx/body/output/TxOut.ts:41\nreadonly optional datum: Data | Hash32\nreadonly\noptional\nData\nHash32\nITxOut.datum\nITxOut\ndatum\nsrc/tx/body/output/TxOut.ts:43\nreadonly optional refScript: Script LitteralScriptType\nreadonly\noptional\nScript\nLitteralScriptType\nITxOut.refScript\nITxOut\nrefScript\nsrc/tx/body/output/TxOut.ts:44\nreadonly value: Value\nreadonly\nValue\nITxOut.value\nITxOut\nvalue\nsrc/tx/body/output/TxOut.ts:42\nget static fake(): TxOut\nget\nstatic\nTxOut\nTxOut\nTxOut\nsrc/tx/body/output/TxOut.ts:119\nclone(): TxOut\nTxOut\nTxOut\nTxOut\nCloneable.clone\nCloneable.clone\nsrc/tx/body/output/TxOut.ts:109\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/body/output/TxOut.ts:168\ntoCborObj(): CborMap\nCborMap\nCborMap\nCborMap\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/body/output/TxOut.ts:172\ntoData(version): Data\nversion\nData\nversion: ToDataVersion = \"v2\"\nToDataVersion\n\"v2\"\nData\nData\nToData.toData\nToData.toData\nsrc/tx/body/output/TxOut.ts:129\ntoJson(): object\nobject\nobject\nobject\naddress: `addr1${string}` | `addr_test1${string}`\ndatum: any\nany\nrefScript: undefined | ScriptSignature | ScriptAll | ScriptAny | ScriptAtLeast | ScriptAfter | ScriptBefore | object\nundefined\nScriptSignature\nScriptAll\nScriptAny\nScriptAtLeast\nScriptAfter\nScriptBefore\nobject\nvalue: ValueJson\nValueJson\nToJson.toJson\nToJson.toJson\nsrc/tx/body/output/TxOut.ts:333\nstatic fromCbor(cStr): TxOut\nstatic\ncStr\nTxOut\ncStr: CanBeCborString\nCanBeCborString\nTxOut\nTxOut\nsrc/tx/body/output/TxOut.ts:223\nstatic fromCborObj(cObj): TxOut\nstatic\ncObj\nTxOut\ncObj: CborObj\nCborObj\nTxOut\nTxOut\nsrc/tx/body/output/TxOut.ts:227"
  },
  {
    "prompt": "TxOutRef?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxOutRef\nITxOutRef\nToData\nToCbor\nToJson\nnew TxOutRef(__namedParameters): TxOutRef\n__namedParameters\nTxOutRef\n__namedParameters: ITxOutRef\nITxOutRef\nTxOutRef\nTxOutRef\nsrc/tx/body/output/TxOutRef.ts:73\nreadonly id: Hash32\nreadonly\nHash32\nITxOutRef.id\nITxOutRef\nid\nsrc/tx/body/output/TxOutRef.ts:70\nreadonly index: number\nreadonly\nnumber\nITxOutRef.index\nITxOutRef\nindex\nsrc/tx/body/output/TxOutRef.ts:71\nget static fake(): TxOutRef\nget\nstatic\nTxOutRef\nTxOutRef\nTxOutRef\nsrc/tx/body/output/TxOutRef.ts:166\neq(other): boolean\nother\nboolean\nother: ITxOutRef\nITxOutRef\nboolean\nboolean\nsrc/tx/body/output/TxOutRef.ts:179\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/body/output/TxOutRef.ts:124\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/body/output/TxOutRef.ts:128\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nToData.toData\nToData.toData\nsrc/tx/body/output/TxOutRef.ts:110\ntoJson(): UTxORefJson\nUTxORefJson\nUTxORefJson\nUTxORefJson\nToJson.toJson\nToJson.toJson\nsrc/tx/body/output/TxOutRef.ts:158\ntoString(): `${string}#${number}`\nReturns a string representation of an object.\n`${string}#${number}`\nsrc/tx/body/output/TxOutRef.ts:93\nstatic eq(a, b): boolean\nstatic\na\nb\nboolean\na: ITxOutRef\nITxOutRef\nb: ITxOutRef\nITxOutRef\nboolean\nboolean\nsrc/tx/body/output/TxOutRef.ts:174\nstatic fromCbor(cStr): TxOutRef\nstatic\ncStr\nTxOutRef\ncStr: CanBeCborString\nCanBeCborString\nTxOutRef\nTxOutRef\nsrc/tx/body/output/TxOutRef.ts:136\nstatic fromCborObj(cObj): TxOutRef\nstatic\ncObj\nTxOutRef\ncObj: CborObj\nCborObj\nTxOutRef\nTxOutRef\nsrc/tx/body/output/TxOutRef.ts:140\nstatic fromString(str): TxOutRef\nstatic\nstr\nTxOutRef\nstr: string\nstring\nTxOutRef\nTxOutRef\nsrc/tx/body/output/TxOutRef.ts:98\nstatic sort(a, b): number\nstatic\na\nb\nnumber\na: ITxOutRef\nITxOutRef\nb: ITxOutRef\nITxOutRef\nnumber\nnumber\nsrc/tx/body/output/TxOutRef.ts:184"
  },
  {
    "prompt": "TxRedeemer?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxRedeemer\nITxRedeemer\nToCbor\nCloneable\nTxRedeemer\nToJson\nnew TxRedeemer(redeemer): TxRedeemer\nredeemer\nTxRedeemer\nredeemer: ITxRedeemer\nITxRedeemer\nTxRedeemer\nTxRedeemer\nsrc/tx/TxWitnessSet/TxRedeemer.ts:84\nreadonly data: Data\nreadonly\nData\nthe actual value of the redeemer\nITxRedeemer.data\nITxRedeemer\ndata\nsrc/tx/TxWitnessSet/TxRedeemer.ts:81\nexecUnits: ExBudget\nExBudget\nITxRedeemer.execUnits\nITxRedeemer\nexecUnits\nsrc/tx/TxWitnessSet/TxRedeemer.ts:82\nreadonly index: number\nreadonly\nnumber\nindex of the input the redeemer corresponds to\nITxRedeemer.index\nITxRedeemer\nindex\nsrc/tx/TxWitnessSet/TxRedeemer.ts:77\nreadonly tag: TxRedeemerTag\nreadonly\nTxRedeemerTag\nITxRedeemer.tag\nITxRedeemer\ntag\nsrc/tx/TxWitnessSet/TxRedeemer.ts:73\nclone(): TxRedeemer\nTxRedeemer\nTxRedeemer\nTxRedeemer\nCloneable.clone\nCloneable.clone\nsrc/tx/TxWitnessSet/TxRedeemer.ts:157\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/TxWitnessSet/TxRedeemer.ts:200\ntoCborMapEntry(): CborMapEntry\nCborMapEntry\nCborMapEntry\nCborMapEntry\nsrc/tx/TxWitnessSet/TxRedeemer.ts:166\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/TxWitnessSet/TxRedeemer.ts:204\ntoJson(): object\nobject\nobject\nobject\ndata: any\nany\nexecUnits: object\nobject\nmemory: string\nstring\nsteps: string\nstring\nindex: number\nnumber\ntag: \"Spend\" | \"Mint\" | \"Cert\" | \"Withdraw\" | \"Voting\" | \"Proposing\"\n\"Spend\"\n\"Mint\"\n\"Cert\"\n\"Withdraw\"\n\"Voting\"\n\"Proposing\"\nToJson.toJson\nToJson.toJson\nsrc/tx/TxWitnessSet/TxRedeemer.ts:236\nstatic fromCbor(cStr): TxRedeemer\nstatic\ncStr\nTxRedeemer\ncStr: CanBeCborString\nCanBeCborString\nTxRedeemer\nTxRedeemer\nsrc/tx/TxWitnessSet/TxRedeemer.ts:214\nstatic fromCborMapEntry(entry): TxRedeemer\nstatic\nentry\nTxRedeemer\nentry: CborMapEntry\nCborMapEntry\nTxRedeemer\nTxRedeemer\nsrc/tx/TxWitnessSet/TxRedeemer.ts:180\nstatic fromCborObj(cObj): TxRedeemer\nstatic\ncObj\nTxRedeemer\ncObj: CborObj\nCborObj\nTxRedeemer\nTxRedeemer\nsrc/tx/TxWitnessSet/TxRedeemer.ts:218"
  },
  {
    "prompt": "TxWithdrawals?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxWithdrawals\nToCbor\nToData\nnew TxWithdrawals(map, network): TxWithdrawals\nmap\nnetwork\nTxWithdrawals\nmap: ITxWithdrawals\nITxWithdrawals\nnetwork: NetworkT = \"mainnet\"\nNetworkT\n\"mainnet\"\nTxWithdrawals\nTxWithdrawals\nsrc/ledger/TxWithdrawals.ts:70\nreadonly map: TxWithdrawalsMapBigInt\nreadonly\nTxWithdrawalsMapBigInt\nsrc/ledger/TxWithdrawals.ts:68\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/ledger/TxWithdrawals.ts:138\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/ledger/TxWithdrawals.ts:142\ntoData(version?): DataMap DataConstr, DataI\nversion\nDataMap\nDataConstr\nDataI\nversion?: ToDataVersion\nToDataVersion\nDataMap DataConstr, DataI\nDataMap\nDataConstr\nDataI\nToData.toData\nToData.toData\nsrc/ledger/TxWithdrawals.ts:125\ntoJson(): object\nobject\nobject\nobject\nsrc/ledger/TxWithdrawals.ts:177\ntoTotalWitdrawn(): Value\nValue\nValue\nValue\nsrc/ledger/TxWithdrawals.ts:117\nstatic fromCbor(cStr): TxWithdrawals\nstatic\ncStr\nTxWithdrawals\ncStr: CanBeCborString\nCanBeCborString\nTxWithdrawals\nTxWithdrawals\nsrc/ledger/TxWithdrawals.ts:154\nstatic fromCborObj(cObj): TxWithdrawals\nstatic\ncObj\nTxWithdrawals\ncObj: CborObj\nCborObj\nTxWithdrawals\nTxWithdrawals\nsrc/ledger/TxWithdrawals.ts:158\nstatic fromJson(json): TxWithdrawals\nstatic\njson\nTxWithdrawals\njson: any\nany\nTxWithdrawals\nTxWithdrawals\nsrc/ledger/TxWithdrawals.ts:191"
  },
  {
    "prompt": "TxWitnessSet?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxWitnessSet\nITxWitnessSet\nToCbor\nToJson\nnew TxWitnessSet(witnesses, allRequiredSigners): TxWitnessSet\nwitnesses\nallRequiredSigners\nTxWitnessSet\nwitnesses: ITxWitnessSet\nITxWitnessSet\nallRequiredSigners: undefined | Hash28[] = undefined\nundefined\nHash28\nundefined\nTxWitnessSet\nTxWitnessSet\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:115\nreadonly addVKeyWitness: (vkeyWit) = void\nreadonly\nvkeyWit\nvoid\nvkeyWit: VKeyWitness\nVKeyWitness\nvoid\nvoid\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:101\nreadonly optional bootstrapWitnesses: BootstrapWitness[]\nreadonly\noptional\nBootstrapWitness\nITxWitnessSet.bootstrapWitnesses\nITxWitnessSet\nbootstrapWitnesses\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:89\nreadonly optional datums: Data[]\nreadonly\noptional\nData\nITxWitnessSet.datums\nITxWitnessSet\ndatums\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:91\nreadonly isComplete: boolean\nreadonly\nboolean\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:113\nreadonly optional nativeScripts: Script NativeScript []\nreadonly\noptional\nScript\nNativeScript\nITxWitnessSet.nativeScripts\nITxWitnessSet\nnativeScripts\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:88\nreadonly optional plutusV1Scripts: Script PlutusV1 []\nreadonly\noptional\nScript\nPlutusV1\nITxWitnessSet.plutusV1Scripts\nITxWitnessSet\nplutusV1Scripts\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:90\nreadonly optional plutusV2Scripts: Script PlutusV2 []\nreadonly\noptional\nScript\nPlutusV2\nITxWitnessSet.plutusV2Scripts\nITxWitnessSet\nplutusV2Scripts\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:93\nreadonly optional plutusV3Scripts: Script PlutusV3 []\nreadonly\noptional\nScript\nPlutusV3\nITxWitnessSet.plutusV3Scripts\nITxWitnessSet\nplutusV3Scripts\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:94\nreadonly optional redeemers: TxRedeemer[]\nreadonly\noptional\nTxRedeemer\nITxWitnessSet.redeemers\nITxWitnessSet\nredeemers\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:92\nreadonly optional vkeyWitnesses: VKeyWitness[]\nreadonly\noptional\nVKeyWitness\nITxWitnessSet.vkeyWitnesses\nITxWitnessSet\nvkeyWitnesses\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:87\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:223\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:227\ntoJson(): object\nobject\nobject\nobject\nbootstrapWitnesses: undefined | object[]\nundefined\nobject\ndatums: undefined | any[]\nundefined\nany\nnativeScripts: undefined | (ScriptSignature | ScriptAll | ScriptAny | ScriptAtLeast | ScriptAfter | ScriptBefore | object)[]\nundefined\nScriptSignature\nScriptAll\nScriptAny\nScriptAtLeast\nScriptAfter\nScriptBefore\nobject\nplutusV1Scripts: undefined | (ScriptSignature | ScriptAll | ScriptAny | ScriptAtLeast | ScriptAfter | ScriptBefore | object)[]\nundefined\nScriptSignature\nScriptAll\nScriptAny\nScriptAtLeast\nScriptAfter\nScriptBefore\nobject\nplutusV2Scripts: undefined | (ScriptSignature | ScriptAll | ScriptAny | ScriptAtLeast | ScriptAfter | ScriptBefore | object)[]\nundefined\nScriptSignature\nScriptAll\nScriptAny\nScriptAtLeast\nScriptAfter\nScriptBefore\nobject\nplutusV3Scripts: undefined | (ScriptSignature | ScriptAll | ScriptAny | ScriptAtLeast | ScriptAfter | ScriptBefore | object)[]\nundefined\nScriptSignature\nScriptAll\nScriptAny\nScriptAtLeast\nScriptAfter\nScriptBefore\nobject\nredeemers: undefined | object[]\nundefined\nobject\nvkeyWitnesses: undefined | object[]\nundefined\nobject\nToJson.toJson\nToJson.toJson\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:209\nstatic fromCbor(cStr): TxWitnessSet\nstatic\ncStr\nTxWitnessSet\ncStr: CanBeCborString\nCanBeCborString\nTxWitnessSet\nTxWitnessSet\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:305\nstatic fromCborObj(cObj): TxWitnessSet\nstatic\ncObj\nTxWitnessSet\ncObj: CborObj\nCborObj\nTxWitnessSet\nTxWitnessSet\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:309"
  },
  {
    "prompt": "UTxO?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / UTxO\nTxIn\nIUTxO\nToData\nToJson\nToCbor\nCloneable\nUTxO\nnew UTxO(utxo): UTxO\nutxo\nUTxO\nutxo: IUTxO\nIUTxO\nUTxO\nUTxO\nsrc/tx/body/output/UTxO.ts:32\nreadonly resolved: TxOut\nreadonly\nTxOut\nIUTxO.resolved\nIUTxO\nresolved\nsrc/tx/body/output/UTxO.ts:30\nreadonly utxoRef: TxOutRef\nreadonly\nTxOutRef\nIUTxO.utxoRef\nIUTxO\nutxoRef\nsrc/tx/body/output/UTxO.ts:29\nclone(): UTxO\nUTxO\nUTxO\nUTxO\nCloneable.clone\nCloneable.clone\nsrc/tx/body/output/UTxO.ts:47\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/body/output/UTxO.ts:63\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/body/output/UTxO.ts:67\ntoData(version?): Data\nversion\nData\nversion?: ToDataVersion\nToDataVersion\nData\nData\nToData.toData\nToData.toData\nsrc/tx/body/output/UTxO.ts:52\ntoJson(): object\nobject\nobject\nobject\nresolved: object\nobject\naddress: `addr1${string}` | `addr_test1${string}`\ndatum: any\nany\nrefScript: undefined | ScriptSignature | ScriptAll | ScriptAny | ScriptAtLeast | ScriptAfter | ScriptBefore | object\nundefined\nScriptSignature\nScriptAll\nScriptAny\nScriptAtLeast\nScriptAfter\nScriptBefore\nobject\nvalue: ValueJson\nValueJson\nutxoRef: UTxORefJson\nUTxORefJson\nToJson.toJson\nToJson.toJson\nsrc/tx/body/output/UTxO.ts:107\nstatic fromCbor(cStr): UTxO\nstatic\ncStr\nUTxO\ncStr: CanBeCborString\nCanBeCborString\nUTxO\nUTxO\nsrc/tx/body/output/UTxO.ts:75\nstatic fromCborObj(cObj): UTxO\nstatic\ncObj\nUTxO\ncObj: CborObj\nCborObj\nUTxO\nUTxO\nsrc/tx/body/output/UTxO.ts:79\nstatic sort(a, b): number\nstatic\na\nb\nnumber\na: IUTxO\nIUTxO\nb: IUTxO\nIUTxO\nnumber\nnumber\nsrc/tx/body/output/UTxO.ts:115"
  },
  {
    "prompt": "VKey?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / VKey\nHash32\nnew VKey(bs): VKey\nbs\nVKey\nbs: string | Uint8Array | Hash32\nstring\nUint8Array\nHash32\nVKey\nVKey\nHash32.constructor\nHash32\nconstructor\nsrc/tx/TxWitnessSet/VKeyWitness/VKey.ts:13\nreadonly hash: PubKeyHash\nreadonly\nPubKeyHash\ngetter\nsrc/tx/TxWitnessSet/VKeyWitness/VKey.ts:11\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash32._bytes\nHash32\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash32._str\nHash32\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash32.asBytes\nHash32\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash32.asString\nHash32\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash\nHash\nHash\nHash\nHash32.clone\nHash32\nclone\nsrc/hashes/Hash.ts:156\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash32.toBuffer\nHash32\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash32.toBytes\nHash32\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash32.toCbor\nHash32\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash32.toCborObj\nHash32\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash32.toData\nHash32\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash32.toString\nHash32\ntoString\nsrc/hashes/Hash.ts:130\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash32.fromAscii\nHash32\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Hash32\nstatic\ncStr\nHash32\ncStr: CanBeCborString\nCanBeCborString\nHash32\nHash32\nHash32.fromCbor\nHash32\nfromCbor\nsrc/hashes/Hash32/Hash32.ts:35\nstatic fromCborObj(cObj): Hash32\nstatic\ncObj\nHash32\ncObj: CborObj\nCborObj\nHash32\nHash32\nHash32.fromCborObj\nHash32\nfromCborObj\nsrc/hashes/Hash32/Hash32.ts:39\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash32.isStrictInstance\nHash32\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash32.isValidHexValue\nHash32\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash32.toAscii\nHash32\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "VKeyWitness?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / VKeyWitness\nToCbor\nCloneable\nVKeyWitness\nToJson\nnew VKeyWitness(vkey, signature): VKeyWitness\nvkey\nsignature\nVKeyWitness\nvkey: Hash32\nHash32\nsignature: Signature\nSignature\nVKeyWitness\nVKeyWitness\nsrc/tx/TxWitnessSet/VKeyWitness/VKeyWitness.ts:18\nreadonly signature: Signature\nreadonly\nSignature\nsrc/tx/TxWitnessSet/VKeyWitness/VKeyWitness.ts:16\nreadonly vkey: VKey\nreadonly\nVKey\nsrc/tx/TxWitnessSet/VKeyWitness/VKeyWitness.ts:15\nclone(): VKeyWitness\nVKeyWitness\nVKeyWitness\nVKeyWitness\nCloneable.clone\nCloneable.clone\nsrc/tx/TxWitnessSet/VKeyWitness/VKeyWitness.ts:41\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/tx/TxWitnessSet/VKeyWitness/VKeyWitness.ts:49\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/tx/TxWitnessSet/VKeyWitness/VKeyWitness.ts:53\ntoJson(): object\nobject\nobject\nobject\nsignature: string\nstring\nvkey: string\nstring\nToJson.toJson\nToJson.toJson\nsrc/tx/TxWitnessSet/VKeyWitness/VKeyWitness.ts:76\nstatic fromCbor(cStr): VKeyWitness\nstatic\ncStr\nVKeyWitness\ncStr: CanBeCborString\nCanBeCborString\nVKeyWitness\nVKeyWitness\nsrc/tx/TxWitnessSet/VKeyWitness/VKeyWitness.ts:61\nstatic fromCborObj(cObj): VKeyWitness\nstatic\ncObj\nVKeyWitness\ncObj: CborObj\nCborObj\nVKeyWitness\nVKeyWitness\nsrc/tx/TxWitnessSet/VKeyWitness/VKeyWitness.ts:65"
  },
  {
    "prompt": "VRFKeyHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / VRFKeyHash\nHash32\nnew VRFKeyHash(bs, className): VRFKeyHash\nbs\nclassName\nVRFKeyHash\nbs: string | Uint8Array | Hash32\nstring\nUint8Array\nHash32\nclassName: string = \"Hash32\"\nstring\n\"Hash32\"\nVRFKeyHash\nVRFKeyHash\nHash32.constructor\nHash32\nconstructor\nsrc/hashes/Hash32/Hash32.ts:25\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash32._bytes\nHash32\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash32._str\nHash32\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash32.asBytes\nHash32\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash32.asString\nHash32\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash\nHash\nHash\nHash\nHash32.clone\nHash32\nclone\nsrc/hashes/Hash.ts:156\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash32.toBuffer\nHash32\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash32.toBytes\nHash32\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash32.toCbor\nHash32\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash32.toCborObj\nHash32\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash32.toData\nHash32\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash32.toString\nHash32\ntoString\nsrc/hashes/Hash.ts:130\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash32.fromAscii\nHash32\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Hash32\nstatic\ncStr\nHash32\ncStr: CanBeCborString\nCanBeCborString\nHash32\nHash32\nHash32.fromCbor\nHash32\nfromCbor\nsrc/hashes/Hash32/Hash32.ts:35\nstatic fromCborObj(cObj): Hash32\nstatic\ncObj\nHash32\ncObj: CborObj\nCborObj\nHash32\nHash32\nHash32.fromCborObj\nHash32\nfromCborObj\nsrc/hashes/Hash32/Hash32.ts:39\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash32.isStrictInstance\nHash32\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash32.isValidHexValue\nHash32\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash32.toAscii\nHash32\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "ValidatorHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ValidatorHash\nHash28\nnew ValidatorHash(bs, className): ValidatorHash\nbs\nclassName\nValidatorHash\nbs: CanBeHash28\nCanBeHash28\nclassName: string = \"Hash28\"\nstring\n\"Hash28\"\nValidatorHash\nValidatorHash\nHash28.constructor\nHash28\nconstructor\nsrc/hashes/Hash28/Hash28.ts:26\nget protected _bytes(): Uint8Array\nget\nprotected\nUint8Array\nUint8Array\nUint8Array\nHash28._bytes\nHash28\n_bytes\nsrc/hashes/Hash.ts:45\nget protected _str(): string\nget\nprotected\nstring\nstring\nstring\nHash28._str\nHash28\n_str\nsrc/hashes/Hash.ts:67\nget asBytes(): Uint8Array\nget\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nUint8Array\nUint8Array\nHash28.asBytes\nHash28\nasBytes\nsrc/hashes/Hash.ts:138\nget asString(): string\nget\nstring\nuse toString() instead\ntoString()\nstring\nstring\nHash28.asString\nHash28\nasString\nsrc/hashes/Hash.ts:125\nclone(): Hash28\nHash28\nHash28\nHash28\nHash28.clone\nHash28\nclone\nsrc/hashes/Hash28/Hash28.ts:41\ntoBuffer(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nHash28.toBuffer\nHash28\ntoBuffer\nsrc/hashes/Hash.ts:143\ntoBytes(): Uint8Array\nUint8Array\nUint8Array\nUint8Array\nuse toBuffer() instead\ntoBuffer()\nHash28.toBytes\nHash28\ntoBytes\nsrc/hashes/Hash.ts:151\ntoCbor(): CborString\nCborString\nCborString\nCborString\nHash28.toCbor\nHash28\ntoCbor\nsrc/hashes/Hash.ts:161\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nHash28.toCborObj\nHash28\ntoCborObj\nsrc/hashes/Hash.ts:165\ntoData(_version?): Data\n_version\nData\n_version?: ToDataVersion\nToDataVersion\nData\nData\nHash28.toData\nHash28\ntoData\nsrc/hashes/Hash.ts:182\ntoString(): string\nstring\nReturns a string representation of an object.\nstring\nstring\nHash28.toString\nHash28\ntoString\nsrc/hashes/Hash.ts:130\nvalueOf(): string\nstring\nReturns the primitive value of the specified object.\nstring\nstring\nHash28.valueOf\nHash28\nvalueOf\nsrc/hashes/Hash28/Hash28.ts:36\nstatic fromAscii(asciiStr): Hash\nstatic\nasciiStr\nHash\nasciiStr: string\nstring\nHash\nHash\nHash28.fromAscii\nHash28\nfromAscii\nsrc/hashes/Hash.ts:187\nstatic fromCbor(cStr): Hash28\nstatic\ncStr\nHash28\ncStr: CanBeCborString\nCanBeCborString\nHash28\nHash28\nHash28.fromCbor\nHash28\nfromCbor\nsrc/hashes/Hash28/Hash28.ts:46\nstatic fromCborObj(cObj): Hash28\nstatic\ncObj\nHash28\ncObj: CborObj\nCborObj\nHash28\nHash28\nHash28.fromCborObj\nHash28\nfromCborObj\nsrc/hashes/Hash28/Hash28.ts:50\nstatic isStrictInstance(bs): bs is Hash\nstatic\nbs\nbs is Hash\nbs: any\nany\nbs is Hash\nbs is Hash\nHash28.isStrictInstance\nHash28\nisStrictInstance\nsrc/hashes/Hash.ts:40\nstatic isValidHexValue(str): boolean\nstatic\nstr\nboolean\nstr: string\nstring\nboolean\nboolean\nHash28.isValidHexValue\nHash28\nisValidHexValue\nsrc/hashes/Hash.ts:197\nstatic toAscii(bStr): string\nstatic\nbStr\nstring\nbStr: Hash\nHash\nstring\nstring\nHash28.toAscii\nHash28\ntoAscii\nsrc/hashes/Hash.ts:192"
  },
  {
    "prompt": "Value?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Value\nToCbor\nToData\nnew Value(map): Value\nmap\nValue\nmap: IValue\nIValue\nValue\nValue\nsrc/ledger/Value/Value.ts:47\nreadonly lovelaces: bigint\nreadonly\nbigint\nsrc/ledger/Value/Value.ts:114\nreadonly map: NormalizedIValue\nreadonly\nNormalizedIValue\nsrc/ledger/Value/Value.ts:36\nget static zero(): Value\nget\nstatic\nValue\nValue\nValue\nsrc/ledger/Value/Value.ts:178\n[iterator](): Generator object, void, unknown\nGenerator\nobject\nvoid\nunknown\nGenerator object, void, unknown\nGenerator\nobject\nvoid\nunknown\nassets: IValueAssetBI[]\nIValueAssetBI\npolicy: string\nstring\nsrc/ledger/Value/Value.ts:38\nclone(): Value\nValue\nValue\nValue\nsrc/ledger/Value/Value.ts:287\nget(policy, assetName): bigint\npolicy\nassetName\nbigint\npolicy: string | Uint8Array | Hash28\nstring\nUint8Array\nHash28\nassetName: Uint8Array\nUint8Array\nbigint\nbigint\nsrc/ledger/Value/Value.ts:116\ntoCbor(): CborString\nCborString\nCborString\nCborString\nToCbor.toCbor\nToCbor.toCbor\nsrc/ledger/Value/Value.ts:313\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nToCbor.toCborObj\nToCbor.toCborObj\nsrc/ledger/Value/Value.ts:317\ntoData(): DataMap DataB, DataMap DataB, DataI\nDataMap\nDataB\nDataMap\nDataB\nDataI\nDataMap DataB, DataMap DataB, DataI\nDataMap\nDataB\nDataMap\nDataB\nDataI\nToData.toData\nToData.toData\nsrc/ledger/Value/Value.ts:292\ntoJson(): ValueJson\nValueJson\nValueJson\nValueJson\nsrc/ledger/Value/Value.ts:449\ntoString(includeLovelaces): string\nincludeLovelaces\nstring\ncardano-cli format\nincludeLovelaces: boolean = true\nboolean\ntrue\nstring\nstring\nsrc/ledger/Value/Value.ts:457\ntoUnits(): ValueUnitsBI\nValueUnitsBI\nValueUnitsBI\nValueUnitsBI\nsrc/ledger/Value/Value.ts:135\nstatic add(a, b): Value\nstatic\na\nb\nValue\na: Value\nValue\nb: Value\nValue\nValue\nValue\nsrc/ledger/Value/Value.ts:277\nstatic assetEntry(name, qty): IValueAssetBI\nstatic\nname\nqty\nIValueAssetBI\nname: Uint8Array\nUint8Array\nqty: number | bigint\nnumber\nbigint\nIValueAssetBI\nIValueAssetBI\nsrc/ledger/Value/Value.ts:227\nstatic entry(policy, assets): NormalizedIValuePolicyEntry\nstatic\npolicy\nassets\nNormalizedIValuePolicyEntry\npolicy: Hash28\nHash28\nassets: IValueAsset[]\nIValueAsset\nNormalizedIValuePolicyEntry\nNormalizedIValuePolicyEntry\nsrc/ledger/Value/Value.ts:269\nstatic fromCbor(cStr): Value\nstatic\ncStr\nValue\ncStr: CanBeCborString\nCanBeCborString\nValue\nValue\nsrc/ledger/Value/Value.ts:350\nstatic fromCborObj(cObj): Value\nstatic\ncObj\nValue\ncObj: CborObj\nCborObj\nValue\nValue\nsrc/ledger/Value/Value.ts:354\nstatic fromUnits(units): Value\nstatic\nunits\nValue\nunits: ValueUnits\nValueUnits\nValue\nValue\nsrc/ledger/Value/Value.ts:150\nstatic isAdaOnly(v): boolean\nstatic\nv\nboolean\nv: Value\nValue\nboolean\nboolean\nsrc/ledger/Value/Value.ts:204\nstatic isPositive(v): boolean\nstatic\nv\nboolean\nv: Value\nValue\nboolean\nboolean\nsrc/ledger/Value/Value.ts:195\nstatic isZero(v): boolean\nstatic\nv\nboolean\nv: Value\nValue\nboolean\nboolean\nsrc/ledger/Value/Value.ts:183\nstatic lovelaceEntry(n): NormalizedIValueAdaEntry\nstatic\nn\nNormalizedIValueAdaEntry\nn: CanBeUInteger\nCanBeUInteger\nNormalizedIValueAdaEntry\nNormalizedIValueAdaEntry\nsrc/ledger/Value/Value.ts:209\nstatic lovelaces(n): Value\nstatic\nn\nValue\nn: number | bigint\nnumber\nbigint\nValue\nValue\nsrc/ledger/Value/Value.ts:222\nstatic singleAsset(policy, name, qty): Value\nstatic\npolicy\nname\nqty\nValue\npolicy: Hash28\nHash28\nname: Uint8Array\nUint8Array\nqty: number | bigint\nnumber\nbigint\nValue\nValue\nsrc/ledger/Value/Value.ts:254\nstatic singleAssetEntry(policy, name, qty): NormalizedIValuePolicyEntry\nstatic\npolicy\nname\nqty\nNormalizedIValuePolicyEntry\npolicy: Hash28\nHash28\nname: Uint8Array\nUint8Array\nqty: number | bigint\nnumber\nbigint\nNormalizedIValuePolicyEntry\nNormalizedIValuePolicyEntry\nsrc/ledger/Value/Value.ts:242\nstatic sub(a, b): Value\nstatic\na\nb\nValue\na: Value\nValue\nb: Value\nValue\nValue\nValue\nsrc/ledger/Value/Value.ts:282"
  },
  {
    "prompt": "Voter?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Voter\nIVoter\nToData\nnew Voter(__namedParameters): Voter\n__namedParameters\nVoter\n__namedParameters: IVoter\nIVoter\nVoter\nVoter\nsrc/governance/Voter.ts:70\nreadonly hash: Hash28\nreadonly\nHash28\nIVoter.hash\nIVoter\nhash\nsrc/governance/Voter.ts:68\nreadonly kind: VoterKind\nreadonly\nVoterKind\nIVoter.kind\nIVoter\nkind\nsrc/governance/Voter.ts:67\ntoCborObj(): CborArray\nCborArray\nCborArray\nCborArray\nsrc/governance/Voter.ts:101\ntoData(version?): DataConstr\nversion\nDataConstr\nversion?: ToDataVersion\nToDataVersion\nDataConstr\nDataConstr\nToData.toData\nToData.toData\nsrc/governance/Voter.ts:109\nstatic ConstitutionalCommitteKeyHash(hash): Voter\nstatic\nhash\nVoter\nhash: CanBeHash28\nCanBeHash28\nVoter\nVoter\nsrc/governance/Voter.ts:80\nstatic ConstitutionalCommitteScript(hash): Voter\nstatic\nhash\nVoter\nhash: CanBeHash28\nCanBeHash28\nVoter\nVoter\nsrc/governance/Voter.ts:84\nstatic DRepKeyHash(hash): Voter\nstatic\nhash\nVoter\nhash: CanBeHash28\nCanBeHash28\nVoter\nVoter\nsrc/governance/Voter.ts:88\nstatic DRepScript(hash): Voter\nstatic\nhash\nVoter\nhash: CanBeHash28\nCanBeHash28\nVoter\nVoter\nsrc/governance/Voter.ts:92\nstatic StakingPoolKeyHash(hash): Voter\nstatic\nhash\nVoter\nhash: CanBeHash28\nCanBeHash28\nVoter\nVoter\nsrc/governance/Voter.ts:96"
  },
  {
    "prompt": "VotingProcedure?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / VotingProcedure\nIVotingProcedure\nnew VotingProcedure(__namedParameters): VotingProcedure\n__namedParameters\nVotingProcedure\n__namedParameters: IVotingProcedure\nIVotingProcedure\nVotingProcedure\nVotingProcedure\nsrc/governance/VotingProcedure.ts:28\nreadonly anchor: undefined | Anchor\nreadonly\nundefined\nAnchor\nIVotingProcedure.anchor\nIVotingProcedure\nanchor\nsrc/governance/VotingProcedure.ts:26\nreadonly vote: Vote\nreadonly\nVote\nIVotingProcedure.vote\nIVotingProcedure\nvote\nsrc/governance/VotingProcedure.ts:25\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/governance/VotingProcedure.ts:38\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nsrc/governance/VotingProcedure.ts:42"
  },
  {
    "prompt": "VotingProcedures?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / VotingProcedures\nnew VotingProcedures(procedures): VotingProcedures\nprocedures\nVotingProcedures\nprocedures: IVotingProcedures\nIVotingProcedures\nVotingProcedures\nVotingProcedures\nsrc/governance/VotingProcedures.ts:50\nreadonly procedures: ITypedVotingProcedures\nreadonly\nITypedVotingProcedures\nsrc/governance/VotingProcedures.ts:48\ntoCbor(): CborString\nCborString\nCborString\nCborString\nsrc/governance/VotingProcedures.ts:66\ntoCborObj(): CborObj\nCborObj\nCborObj\nCborObj\nsrc/governance/VotingProcedures.ts:70"
  },
  {
    "prompt": "LitteralScriptType?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / LitteralScriptType\nLitteralScriptType: ScriptType | \"NativeScript\" | \"PlutusScriptV1\" | \"PlutusScriptV2\" | \"PlutusScriptV3\"\nScriptType\n\"NativeScript\"\n\"PlutusScriptV1\"\n\"PlutusScriptV2\"\n\"PlutusScriptV3\"\nsrc/script/Script.ts:20"
  },
  {
    "prompt": "ScriptType?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ScriptType\nNativeScript: \"NativeScript\"\n\"NativeScript\"\nsrc/script/Script.ts:10\nPlutusV1: \"PlutusScriptV1\"\n\"PlutusScriptV1\"\nsrc/script/Script.ts:11\nPlutusV2: \"PlutusScriptV2\"\n\"PlutusScriptV2\"\nsrc/script/Script.ts:12\nPlutusV3: \"PlutusScriptV3\"\n\"PlutusScriptV3\"\nsrc/script/Script.ts:13"
  },
  {
    "prompt": "NativeScript?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / NativeScript\nNativeScript: ScriptSignature | ScriptAll | ScriptAny | ScriptAtLeast | ScriptAfter | ScriptBefore\nScriptSignature\nScriptAll\nScriptAny\nScriptAtLeast\nScriptAfter\nScriptBefore\nsrc/script/NativeScript.ts:6"
  },
  {
    "prompt": "PlutusScriptJsonFormat?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / PlutusScriptJsonFormat\nT extends PlutusScriptType = PlutusScriptType\nPlutusScriptType\nPlutusScriptType\ncborHex: string\nstring\nsrc/script/Script.ts:25\noptional description: string\noptional\nstring\nsrc/script/Script.ts:24\ntype: T\nT\nsrc/script/Script.ts:23"
  },
  {
    "prompt": "PlutusScriptType?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / PlutusScriptType\nPlutusScriptType: PlutusV1 | PlutusV2 | PlutusV3 | \"PlutusScriptV1\" | \"PlutusScriptV2\" | \"PlutusScriptV3\"\nPlutusV1\nPlutusV2\nPlutusV3\n\"PlutusScriptV1\"\n\"PlutusScriptV2\"\n\"PlutusScriptV3\"\nsrc/script/Script.ts:18"
  },
  {
    "prompt": "ScriptSignature?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ScriptSignature\nkeyHash: string | Hash28\nstring\nHash28\nsrc/script/NativeScript.ts:16\ntype: \"sig\"\n\"sig\"\nsrc/script/NativeScript.ts:15"
  },
  {
    "prompt": "ScriptAll?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ScriptAll\nscripts: NativeScript[]\nNativeScript\nsrc/script/NativeScript.ts:21\ntype: \"all\"\n\"all\"\nsrc/script/NativeScript.ts:20"
  },
  {
    "prompt": "ScriptAny?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ScriptAny\nscripts: NativeScript[]\nNativeScript\nsrc/script/NativeScript.ts:26\ntype: \"any\"\n\"any\"\nsrc/script/NativeScript.ts:25"
  },
  {
    "prompt": "ScriptAtLeast?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ScriptAtLeast\nrequired: CanBeUInteger\nCanBeUInteger\nsrc/script/NativeScript.ts:31\nscripts: NativeScript[]\nNativeScript\nsrc/script/NativeScript.ts:32\ntype: \"atLeast\"\n\"atLeast\"\nsrc/script/NativeScript.ts:30"
  },
  {
    "prompt": "ScriptAfter?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ScriptAfter\nslot: CanBeUInteger\nCanBeUInteger\nsrc/script/NativeScript.ts:37\ntype: \"after\"\n\"after\"\nsrc/script/NativeScript.ts:36"
  },
  {
    "prompt": "ScriptBefore?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ScriptBefore\nslot: CanBeUInteger\nCanBeUInteger\nsrc/script/NativeScript.ts:42\ntype: \"before\"\n\"before\"\nsrc/script/NativeScript.ts:41"
  },
  {
    "prompt": "NetworkT?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / NetworkT\nNetworkT: Network | \"mainnet\" | \"testnet\"\nNetwork\n\"mainnet\"\n\"testnet\"\nsrc/ledger/Network.ts:9"
  },
  {
    "prompt": "CredentialType?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CredentialType\nKeyHash: 0\n0\nsrc/credentials/Credential.ts:12\nScript: 1\n1\nsrc/credentials/Credential.ts:13"
  },
  {
    "prompt": "StakeCredentialsType?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / StakeCredentialsType\nStakeCredentialsType: \"stakeKey\" | \"script\" | \"pointer\"\n\"stakeKey\"\n\"script\"\n\"pointer\"\nsrc/credentials/StakeCredentials.ts:13"
  },
  {
    "prompt": "AddressType?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / AddressType\nAddressType: \"base\" | \"pointer\" | \"enterprise\" | \"bootstrap\" | \"unknown\"\n\"base\"\n\"pointer\"\n\"enterprise\"\n\"bootstrap\"\n\"unknown\"\nsrc/ledger/Address.ts:29"
  },
  {
    "prompt": "plam and pfn?",
    "completion": "plam\npfn\nFunctions can be transformed from the Typescript world to the plu-ts one just like any other value.\nplu-ts\nThis can be done with two functions:\nplam\npfn\nplam\nJust like the lam type, plam only works for functions with one input; don't worry, pfn is more powerful, but plam will help us understand the basics.\nlam\nplam\npfn\nplam\nThe plam signature is:\nplam\nfunction plam<A extends TermType, B extends TermType >( inputType: A, outputType: B ) : ( termFunc : ( input: Term<ToPType<A>> ) => Term<ToPType<B>> ) => Term<PLam<ToPType<A>,ToPType<B>>>\nfunction plam<A extends TermType, B extends TermType >( inputType: A, outputType: B ) : ( termFunc : ( input: Term<ToPType<A>> ) => Term<ToPType<B>> ) => Term<PLam<ToPType<A>,ToPType<B>>>\nIf this seems familiar it's because it works on the same principle of pList we saw in the explanation of simple values.\npList\nplam first requires us to specify the plu-ts types we are working with and it gives back a function ad-hoc for those types.\nplam\nplu-ts\nconst makeLambdaFromIntToBool : ( tellMeHow: ( int: Term<PInt> ) => Term<PBool> ) => Term<PLam<PInt, PBool>> = plam( int, bool )\nconst makeLambdaFromIntToBool : ( tellMeHow: ( int: Term<PInt> ) => Term<PBool> ) => Term<PLam<PInt, PBool>> = plam( int, bool )\nThe function we get back expects a typescript function as input that describe how to \"transform\" the input to the output.\nSince the tellMeHow function should return a Term; we need some way to \"build\" a new term.\ntellMeHow\nIn plu-ts you never need to write anything like new Term(...); rather you use plu-ts functions to build new plu-ts terms.\nplu-ts\nnew Term(...)\nplu-ts\nplu-ts\nWait what? Aren't plu-ts functions also Terms? How do I build new Terms if I need other Terms to build new Terms?\nplu-ts\nFortunately for us there are some builtin functions that form the fundamentals of the language.\nWe can use these to describe the body of our lambda.\nThese builtins will often be aviable directly on our Term, as in the example below\nTerm\nconst pintIsZero = makeLambdaFromIntToBool( someInt => peqInt.$( someInt ).$( 0 ));\nconst pintIsZero = makeLambdaFromIntToBool( someInt => peqInt.$( someInt ).$( 0 ));\np<Stuff>\nis convention to name plu-ts functions starting with a lower case \"p\"; indicating that we are in the plu-ts world and not the typescript one\nplu-ts\nplu-ts\nHere we are using the peqInt builtin function; the $ method is a short form for the papp function and is how we pass arguments to a plu-ts function (we'll cover function application in the very next section).\npeqInt\n$\npapp\nplu-ts\nWhat matters for now is that we successfully transformed an int into a bool using only plu-ts; and we now have a new function that we can re-use when needed.\nint\nbool\nplu-ts\npintIsZero.$( pInt(42) ) // this is a Term<PBool> equivalent to `pBool( false )`\npintIsZero.$( pInt(42) ) // this is a Term<PBool> equivalent to `pBool( false )`\npfn\nNow that we know how the plam machinery works let's look at the more useful pfn.\nplam\npfn\nThe signature (a bit simplified; this is not Typescript) is\nfunction pfn<InputsTypes extends [ TermType, ...TermType[] ], OutputType extends TermType>( inputsTypes: InputsTypes, outputType: OutputType ) : ( termFunction: ( ...inputs: PInputs ) => POutput ) => Term<PFn<PInputs, POutput>>\nfunction pfn<InputsTypes extends [ TermType, ...TermType[] ], OutputType extends TermType>( inputsTypes: InputsTypes, outputType: OutputType ) : ( termFunction: ( ...inputs: PInputs ) => POutput ) => Term<PFn<PInputs, POutput>>\nAnd with the exception of an array of types as input rather than a single type we see it is doing the exact same thing as plam but with more inputs.\nplam\nSo if we want a function that builds a plu-ts level function for us of type int - int - list( int ) we just write\nplu-ts\nint -> int -> list( int )\nconst makeListFromTwoInts = pfn( [ int, int ], list( int ) );\nconst makeListFromTwoInts = pfn( [ int, int ], list( int ) );\nAnd just like the plam case, we use the function we just got to build a plu-ts one.\nplam\nplu-ts\nconst pTwoIntegersList = makeListFromTwoInts( ( int1, int2 ) => pList([ int1, int2 ]));\nconst pTwoIntegersList = makeListFromTwoInts( ( int1, int2 ) => pList([ int1, int2 ]));\nplam\npfn"
  },
  {
    "prompt": "Function application?",
    "completion": "Lambdas and functions in general in plu-ts are often just constants seen from the typescript world, however we usually know that what we have is more than just a constant and that it can take arguments.\nplu-ts\nFor this particular reason we have the papp function (which stands for \"plu-ts application\")and all it does is tell Typescript that we want to apply one term to another, or in other words pass an argument to a function.\npapp\nplu-ts\nThe type signature of papp is something like:\nfunction papp<Input extends PType, Output extends PType>( funcTerm: Term<PLam<Input,Output>>, argTerm : Term<Input> ) : Term<Output>\nfunction papp<Input extends PType, Output extends PType>( funcTerm: Term<PLam<Input,Output>>, argTerm : Term<Input> ) : Term<Output>\nAs we'll see in the next section, functions can be partially applied so, to preserve this behavior, papp only takes two arguments:\nthe function we want to pass the argument to\nthe argument\nThen it checks the types are matching, evaluates the argument and applies the result of the evaluation and finally returns the result.\n$\nHowever, having to use an external function in order to pass arguments tends to make the code hard to read.\nHere is an example of code if all we had was papp:\npapp\npapp( papp( pTwoIntegersList, 42 ), 69);\npapp( papp( pTwoIntegersList, 42 ), 69);\nFor this reason, often you'll encounter Terms that have a type that looks like this:\ntype LambdaWithApply = Term<PLam<SomeInput, SomeOutput>> // this is our usual type & { // extended with some functionalities $: ( input: Term<SomeInput> ) => Term<SomeOutput> }\ntype LambdaWithApply = Term<PLam<SomeInput, SomeOutput>> // this is our usual type & { // extended with some functionalities $: ( input: Term<SomeInput> ) => Term<SomeOutput> }\nwhere the $ method definition is often nothing more than:\n$\nmyTerm[\"$\"] = ( someInput: Term<SomeInput> ) => papp( myTerm, someInput );\nmyTerm[\"$\"] = ( someInput: Term<SomeInput> ) => papp( myTerm, someInput );\nAt first glance, this seems like it does nothing fancy, but it allows us to transform the previous code in something more readable like:\npTwoIntegersList.$( 42 ).$( 69 )\npTwoIntegersList.$( 42 ).$( 69 )\n$"
  },
  {
    "prompt": "IUTxO?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IUTxO\nresolved: ITxOut\nITxOut\nsrc/tx/body/output/UTxO.ts:14\nutxoRef: ITxOutRef\nITxOutRef\nsrc/tx/body/output/UTxO.ts:13"
  },
  {
    "prompt": "StakeAddressBech32?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / StakeAddressBech32\nStakeAddressBech32: `stake1${string}` | `stake_test1${string}`\nsrc/ledger/StakeAddress.ts:14"
  },
  {
    "prompt": "TxMetadatum?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxMetadatum\nTxMetadatum: TxMetadatumMap | TxMetadatumList | TxMetadatumInt | TxMetadatumBytes | TxMetadatumText\nTxMetadatumMap\nTxMetadatumList\nTxMetadatumInt\nTxMetadatumBytes\nTxMetadatumText\nsrc/tx/metadata/TxMetadatum.ts:10"
  },
  {
    "prompt": "ITxOut?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITxOut\naddress: `addr1${string}` | `addr_test1${string}` | Address\nAddress\nsrc/tx/body/output/TxOut.ts:17\noptional datum: Data | Hash32\noptional\nData\nHash32\nsrc/tx/body/output/TxOut.ts:19\noptional refScript: Script LitteralScriptType\noptional\nScript\nLitteralScriptType\nsrc/tx/body/output/TxOut.ts:20\nvalue: IValue | Value\nIValue\nValue\nsrc/tx/body/output/TxOut.ts:18"
  },
  {
    "prompt": "ITxOutRef?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITxOutRef\nid: string | Hash32\nstring\nHash32\nsrc/tx/body/output/TxOutRef.ts:17\nindex: number\nnumber\nsrc/tx/body/output/TxOutRef.ts:18"
  },
  {
    "prompt": "TxOutRefStr?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxOutRefStr\nTxOutRefStr: `${string}#${number}`\nsrc/tx/body/output/TxOutRef.ts:14"
  },
  {
    "prompt": "DRepType?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / DRepType\nAlwaysAbstain: 2\n2\nsrc/governance/DRep/DRepType.ts:5\nAlwaysNoConfidence: 3\n3\nsrc/governance/DRep/DRepType.ts:6\nKeyHash: 0\n0\nsrc/governance/DRep/DRepType.ts:3\nScript: 1\n1\nsrc/governance/DRep/DRepType.ts:4"
  },
  {
    "prompt": "Era?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Era\nAllegra: \"allegra\"\n\"allegra\"\nsrc/ledger/Era.ts:5\nAlonzo: \"alonzo\"\n\"alonzo\"\nsrc/ledger/Era.ts:7\nBabbage: \"babbage\"\n\"babbage\"\nsrc/ledger/Era.ts:8\nByron: \"byron\"\n\"byron\"\nsrc/ledger/Era.ts:3\nMary: \"mary\"\n\"mary\"\nsrc/ledger/Era.ts:6\nShelley: \"shelley\"\n\"shelley\"\nsrc/ledger/Era.ts:4"
  },
  {
    "prompt": "GovActionType?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / GovActionType\nInfo: 6\n6\nsrc/governance/GovAction/GovActionType.ts:8\nInitHardFork: 1\n1\nsrc/governance/GovAction/GovActionType.ts:3\nNewConstitution: 5\n5\nsrc/governance/GovAction/GovActionType.ts:7\nNoConfidence: 3\n3\nsrc/governance/GovAction/GovActionType.ts:5\nParameterChange: 0\n0\nsrc/governance/GovAction/GovActionType.ts:2\nTreasuryWithdrawals: 2\n2\nsrc/governance/GovAction/GovActionType.ts:4\nUpdateCommittee: 4\n4\nsrc/governance/GovAction/GovActionType.ts:6"
  },
  {
    "prompt": "InstantRewardsSource?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / InstantRewardsSource\nReserves: 0\n0\nsrc/ledger/certs/MoveInstantRewardsCert.ts:15\nTreasurery: 1\n1\nsrc/ledger/certs/MoveInstantRewardsCert.ts:16"
  },
  {
    "prompt": "Network?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Network\nmainnet: \"mainnet\"\n\"mainnet\"\nsrc/ledger/Network.ts:3\ntestnet: \"testnet\"\n\"testnet\"\nsrc/ledger/Network.ts:4"
  },
  {
    "prompt": "TxRedeemerTag?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxRedeemerTag\nCert: 2\n2\nsrc/tx/TxWitnessSet/TxRedeemer.ts:15\nMint: 1\n1\nsrc/tx/TxWitnessSet/TxRedeemer.ts:14\nProposing: 5\n5\nsrc/tx/TxWitnessSet/TxRedeemer.ts:18\nSpend: 0\n0\nsrc/tx/TxWitnessSet/TxRedeemer.ts:13\nVoting: 4\n4\nsrc/tx/TxWitnessSet/TxRedeemer.ts:17\nWithdraw: 3\n3\nsrc/tx/TxWitnessSet/TxRedeemer.ts:16"
  },
  {
    "prompt": "Vote?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Vote\nAbstain: 2\n2\nsrc/governance/Vote.ts:6\nNo: 0\n0\nsrc/governance/Vote.ts:4\nYes: 1\n1\nsrc/governance/Vote.ts:5"
  },
  {
    "prompt": "VoterKind?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / VoterKind\nConstitutionalCommitteKeyHash: 0\n0\nsrc/governance/Voter.ts:10\nConstitutionalCommitteScript: 1\n1\nsrc/governance/Voter.ts:11\nDRepKeyHash: 3\n3\nsrc/governance/Voter.ts:12\nDRepScript: 4\n4\nsrc/governance/Voter.ts:13\nStakingPoolKeyHash: 5\n5\nsrc/governance/Voter.ts:14"
  },
  {
    "prompt": "IValueToJson?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IValueToJson\nIValueToJson(iVal): ValueJson\niVal\nValueJson\niVal: IValue\nIValue\nValueJson\nValueJson\nsrc/ledger/Value/IValue.ts:135"
  },
  {
    "prompt": "IVotingProcedure?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IVotingProcedure\nIVotingProcedure(stuff): stuff is IVotingProcedure\nstuff\nstuff is IVotingProcedure\nstuff: any\nany\nstuff is IVotingProcedure\nstuff is IVotingProcedure\nsrc/governance/VotingProcedure.ts:12"
  },
  {
    "prompt": "LegacyPPUpdateMapFromCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / LegacyPPUpdateMapFromCborObj\nLegacyPPUpdateMapFromCborObj(cObj): LegacyPPUpdateMap\ncObj\nLegacyPPUpdateMap\ncObj: CborObj\nCborObj\nLegacyPPUpdateMap\nLegacyPPUpdateMap\nsrc/ledger/protocol/LegacyPPUpdateProposal.ts:63"
  },
  {
    "prompt": "LegacyPPUpdateMapToCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / LegacyPPUpdateMapToCborObj\nLegacyPPUpdateMapToCborObj(ppUpdate): CborMap\nppUpdate\nCborMap\nppUpdate: LegacyPPUpdateMap\nLegacyPPUpdateMap\nCborMap\nCborMap\nsrc/ledger/protocol/LegacyPPUpdateProposal.ts:51"
  },
  {
    "prompt": "LegacyPPUpdateProposalFromCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / LegacyPPUpdateProposalFromCborObj\nLegacyPPUpdateProposalFromCborObj(cObj): LegacyPPUpdateProposal\ncObj\nLegacyPPUpdateProposal\ncObj: CborObj\nCborObj\nLegacyPPUpdateProposal\nLegacyPPUpdateProposal\nsrc/ledger/protocol/LegacyPPUpdateProposal.ts:82"
  },
  {
    "prompt": "LegacyPPUpdateProposalToCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / LegacyPPUpdateProposalToCborObj\nLegacyPPUpdateProposalToCborObj(protocolUpdate): CborObj\nprotocolUpdate\nCborObj\nprotocolUpdate: LegacyPPUpdateProposal\nLegacyPPUpdateProposal\nCborObj\nCborObj\nsrc/ledger/protocol/LegacyPPUpdateProposal.ts:74"
  },
  {
    "prompt": "addIValues?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / addIValues\naddIValues(a, b): IValue\na\nb\nIValue\na: IValue\nIValue\nb: IValue\nIValue\nIValue\nIValue\nsrc/ledger/Value/IValue.ts:307"
  },
  {
    "prompt": "canBeCborPostiveRational?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / canBeCborPostiveRational\ncanBeCborPostiveRational(cbor): cbor is CborTag | CborPositiveRational\ncbor\ncbor: CborObj\nCborObj\ncbor is CborTag | CborPositiveRational\nsrc/ledger/protocol/Rational.ts:5"
  },
  {
    "prompt": "canBeHash28?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / canBeHash28\ncanBeHash28(stuff): stuff is CanBeHash28\nstuff\nstuff is CanBeHash28\nstuff: any\nany\nstuff is CanBeHash28\nstuff is CanBeHash28\nsrc/hashes/Hash28/Hash28.ts:9"
  },
  {
    "prompt": "canBeHash32?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / canBeHash32\ncanBeHash32(stuff): stuff is CanBeHash32\nstuff\nstuff is CanBeHash32\nstuff: any\nany\nstuff is CanBeHash32\nstuff is CanBeHash32\nsrc/hashes/Hash32/Hash32.ts:8"
  },
  {
    "prompt": "canBeHashInstance?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / canBeHashInstance\ncanBeHashInstance(obj): boolean\nobj\nboolean\nobj: any\nany\nboolean\nboolean\nsrc/hashes/Hash.ts:10"
  },
  {
    "prompt": "canBeTxWithdrawals?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / canBeTxWithdrawals\ncanBeTxWithdrawals(stuff): stuff is ITxWithdrawals | TxWithdrawals\nstuff\nstuff: any\nany\nstuff is ITxWithdrawals | TxWithdrawals\nsrc/ledger/TxWithdrawals.ts:208"
  },
  {
    "prompt": "cborFromRational?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / cborFromRational\ncborFromRational(n): CborPositiveRational\nn\nCborPositiveRational\nn: Rational\nRational\nCborPositiveRational\nCborPositiveRational\nsrc/ledger/protocol/Rational.ts:27"
  },
  {
    "prompt": "certToDepositLovelaces?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / certToDepositLovelaces\ncertToDepositLovelaces(cert): bigint\ncert\nbigint\ncert: ICert\nICert\nbigint\nbigint\nsrc/ledger/certs/ICert.ts:12"
  },
  {
    "prompt": "certTypeToString?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / certTypeToString\ncertTypeToString CertT (certT): CertTypeToStr CertT\nCertT\ncertT\nCertTypeToStr\nCertT\nCertT extends CertificateType\nCertificateType\ncertT: CertT\nCertT\nCertTypeToStr CertT\nCertTypeToStr\nCertT\nsrc/ledger/certs/CertificateType.ts:60"
  },
  {
    "prompt": "certificateFromCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / certificateFromCborObj\ncertificateFromCborObj(cbor): Certificate\ncbor\nCertificate\ncbor: CborObj\nCborObj\nCertificate\nCertificate\nsrc/ledger/certs/Certificate.ts:69"
  },
  {
    "prompt": "certificateFromCertificateLike?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / certificateFromCertificateLike\ncertificateFromCertificateLike(like): Certificate\nlike\nCertificate\nlike: CertificateLike\nCertificateLike\nCertificate\nCertificate\nsrc/ledger/certs/Certificate.ts:129"
  },
  {
    "prompt": "certificatesToDepositLovelaces?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / certificatesToDepositLovelaces\ncertificatesToDepositLovelaces(certs): bigint\ncerts\nbigint\ncerts: ICert[]\nICert\nbigint\nbigint\nsrc/ledger/certs/ICert.ts:25"
  },
  {
    "prompt": "cloneIValue?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / cloneIValue\ncloneIValue(ival): IValue\nival\nIValue\nival: IValue\nIValue\nIValue\nIValue\nsrc/ledger/Value/IValue.ts:122"
  },
  {
    "prompt": "cloneIValueEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / cloneIValueEntry\ncloneIValueEntry Entry (__namedParameters): Entry\nEntry\n__namedParameters\nEntry\nEntry extends IValuePolicyEntry | IValueAdaEntry\nIValuePolicyEntry\nIValueAdaEntry\n__namedParameters: Entry\nEntry\nEntry\nEntry\nsrc/ledger/Value/IValue.ts:167"
  },
  {
    "prompt": "drepFromCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / drepFromCborObj\ndrepFromCborObj(cbor): DRep\ncbor\nDRep\ncbor: CborObj\nCborObj\nDRep\nDRep\nsrc/governance/DRep/DRep.ts:14"
  },
  {
    "prompt": "drepTypeToString?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / drepTypeToString\ndrepTypeToString(t): string\nt\nstring\nt: DRepType\nDRepType\nstring\nstring\nsrc/governance/DRep/DRepType.ts:19"
  },
  {
    "prompt": "drepVotingThresholdsToCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / drepVotingThresholdsToCborObj\ndrepVotingThresholdsToCborObj(drepVotingThresholds): CborArray\ndrepVotingThresholds\nCborArray\ndrepVotingThresholds: PParamsDrepVotingThresholds\nPParamsDrepVotingThresholds\nCborArray\nCborArray\nsrc/ledger/protocol/PParamsDrepVotingThresholds.ts:34"
  },
  {
    "prompt": "eqITxOutRef?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / eqITxOutRef\neqITxOutRef(a, b): boolean\na\nb\nboolean\na: ITxOutRef\nITxOutRef\nb: ITxOutRef\nITxOutRef\nboolean\nboolean\nsrc/tx/body/output/TxOutRef.ts:36"
  },
  {
    "prompt": "eqIVoter?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / eqIVoter\neqIVoter(a, b): boolean\na\nb\nboolean\na: IVoter\nIVoter\nb: IVoter\nIVoter\nboolean\nboolean\nsrc/governance/Voter.ts:44"
  },
  {
    "prompt": "forceTxOutRef?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / forceTxOutRef\nforceTxOutRef(canBe): TxOutRef\ncanBe\nTxOutRef\ncanBe: CanBeTxOutRef\nCanBeTxOutRef\nTxOutRef\nTxOutRef\nsrc/tx/body/output/CanBeTxOutRef.ts:12"
  },
  {
    "prompt": "forceTxOutRefStr?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / forceTxOutRefStr\nforceTxOutRefStr(canBe): TxOutRefStr\ncanBe\nTxOutRefStr\ncanBe: CanBeTxOutRef\nCanBeTxOutRef\nTxOutRefStr\nTxOutRefStr\nsrc/tx/body/output/CanBeTxOutRef.ts:7"
  },
  {
    "prompt": "forceTxWithdrawals?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / forceTxWithdrawals\nforceTxWithdrawals(stuff): TxWithdrawals\nstuff\nTxWithdrawals\nstuff: ITxWithdrawals | TxWithdrawals\nITxWithdrawals\nTxWithdrawals\nTxWithdrawals\nTxWithdrawals\nsrc/ledger/TxWithdrawals.ts:213"
  },
  {
    "prompt": "getAllRequiredSigners?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / getAllRequiredSigners\ngetAllRequiredSigners(body): Hash28[]\nbody\nHash28\nsigners needed are:\nrequiredSigners\nbody: Readonly TxBody\nReadonly\nTxBody\nHash28[]\nHash28\nsrc/tx/Tx.ts:277"
  },
  {
    "prompt": "getEmptyNameQty?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / getEmptyNameQty\ngetEmptyNameQty(assets): CanBeUInteger | undefined\nassets\nCanBeUInteger\nundefined\nassets: undefined | IValueAsset[]\nundefined\nIValueAsset\nCanBeUInteger | undefined\nCanBeUInteger\nundefined\nsrc/ledger/Value/IValue.ts:302"
  },
  {
    "prompt": "getNSignersNeeded?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / getNSignersNeeded\ngetNSignersNeeded(body): number\nbody\nnumber\nbody: Readonly TxBody\nReadonly\nTxBody\nnumber\nnumber\nsrc/tx/Tx.ts:314"
  },
  {
    "prompt": "getNameQty?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / getNameQty\ngetNameQty(assets, searchName): CanBeUInteger | undefined\nassets\nsearchName\nCanBeUInteger\nundefined\nassets: undefined | IValueAsset[]\nundefined\nIValueAsset\nsearchName: Uint8Array\nUint8Array\nCanBeUInteger | undefined\nCanBeUInteger\nundefined\nsrc/ledger/Value/IValue.ts:289"
  },
  {
    "prompt": "isAddressStr?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isAddressStr\nisAddressStr(stuff): stuff is `addr1${string}` | `addr_test1${string}`\nstuff\nstuff: any\nany\nstuff is `addr1${string}` | `addr_test1${string}`\nsrc/ledger/Address.ts:17"
  },
  {
    "prompt": "isCertificate?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isCertificate\nisCertificate(stuff): stuff is Certificate\nstuff\nstuff is Certificate\nstuff: any\nany\nstuff is Certificate\nstuff is Certificate\nsrc/ledger/certs/Certificate.ts:44"
  },
  {
    "prompt": "isCertificateType?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isCertificateType\nisCertificateType(stuff): stuff is CertificateType\nstuff\nstuff is CertificateType\nstuff: any\nany\nstuff is CertificateType\nstuff is CertificateType\nsrc/ledger/certs/CertificateType.ts:30"
  },
  {
    "prompt": "isDRepLike?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isDRepLike\nisDRepLike(stuff): stuff is DRepLike\nstuff\nstuff is DRepLike\nstuff: any\nany\nstuff is DRepLike\nstuff is DRepLike\nsrc/governance/DRep/DRepLike.ts:15"
  },
  {
    "prompt": "isDRepType?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isDRepType\nisDRepType(stuff): stuff is DRepType\nstuff\nstuff is DRepType\nstuff: any\nany\nstuff is DRepType\nstuff is DRepType\nsrc/governance/DRep/DRepType.ts:11"
  },
  {
    "prompt": "isDnsPoolRelay?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isDnsPoolRelay\nisDnsPoolRelay T (something): something is T & DnsPoolRelay\nT\nsomething\nsomething is T & DnsPoolRelay\nT extends object\nobject\nsomething: T\nT\nsomething is T & DnsPoolRelay\nsomething is T & DnsPoolRelay\nsrc/ledger/PoolRelay.ts:107"
  },
  {
    "prompt": "isGovActionLike?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isGovActionLike\nisGovActionLike(stuff): stuff is GovActionLike\nstuff\nstuff is GovActionLike\nstuff: any\nany\nstuff is GovActionLike\nstuff is GovActionLike\nsrc/governance/GovAction/GovActionLike.ts:36"
  },
  {
    "prompt": "isGovActionType?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isGovActionType\nisGovActionType(stuff): stuff is GovActionType\nstuff\nstuff is GovActionType\nstuff: any\nany\nstuff is GovActionType\nstuff is GovActionType\nsrc/governance/GovAction/GovActionType.ts:13"
  },
  {
    "prompt": "isIAnchor?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIAnchor\nisIAnchor(stuff): stuff is IAnchor\nstuff\nstuff is IAnchor\nstuff: any\nany\nstuff is IAnchor\nstuff is IAnchor\nsrc/governance/Anchor.ts:11"
  },
  {
    "prompt": "isIConstitution?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIConstitution\nisIConstitution(stuff): stuff is IConstitution\nstuff\nstuff is IConstitution\nstuff: any\nany\nstuff is IConstitution\nstuff is IConstitution\nsrc/governance/Constitution.ts:16"
  },
  {
    "prompt": "isIDRep?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIDRep\nisIDRep(stuff): stuff is IDRep\nstuff\nstuff is IDRep\nstuff: any\nany\nstuff is IDRep\nstuff is IDRep\nsrc/governance/DRep/IDRep.ts:9"
  },
  {
    "prompt": "isIDRepKeyHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIDRepKeyHash\nisIDRepKeyHash(stuff): stuff is IDRepKeyHash\nstuff\nstuff is IDRepKeyHash\nstuff: any\nany\nstuff is IDRepKeyHash\nstuff is IDRepKeyHash\nsrc/governance/DRep/DRepKeyHash.ts:15"
  },
  {
    "prompt": "isIDRepScript?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIDRepScript\nisIDRepScript(stuff): stuff is IDRepScript\nstuff\nstuff is IDRepScript\nstuff: any\nany\nstuff is IDRepScript\nstuff is IDRepScript\nsrc/governance/DRep/DRepScript.ts:15"
  },
  {
    "prompt": "isIGovActionInfo?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIGovActionInfo\nisIGovActionInfo(stuff): stuff is IGovActionInfo\nstuff\nstuff is IGovActionInfo\nstuff: any\nany\nstuff is IGovActionInfo\nstuff is IGovActionInfo\nsrc/governance/GovAction/GovActionInfo.ts:13"
  },
  {
    "prompt": "isIGovActionInitHardFork?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIGovActionInitHardFork\nisIGovActionInitHardFork(stuff): stuff is IGovActionInitHardFork\nstuff\nstuff is IGovActionInitHardFork\nstuff: any\nany\nstuff is IGovActionInitHardFork\nstuff is IGovActionInitHardFork\nsrc/governance/GovAction/GovActionInitHardFork.ts:19"
  },
  {
    "prompt": "isIGovActionNewConstitution?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIGovActionNewConstitution\nisIGovActionNewConstitution(stuff): stuff is IGovActionNewConstitution\nstuff\nstuff is IGovActionNewConstitution\nstuff: any\nany\nstuff is IGovActionNewConstitution\nstuff is IGovActionNewConstitution\nsrc/governance/GovAction/GovActionNewConstitution.ts:17"
  },
  {
    "prompt": "isIGovActionNoConfidence?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIGovActionNoConfidence\nisIGovActionNoConfidence(stuff): stuff is IGovActionNoConfidence\nstuff\nstuff is IGovActionNoConfidence\nstuff: any\nany\nstuff is IGovActionNoConfidence\nstuff is IGovActionNoConfidence\nsrc/governance/GovAction/GovActionNoConfidence.ts:15"
  },
  {
    "prompt": "isIGovActionParameterChange?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIGovActionParameterChange\nisIGovActionParameterChange(stuff): stuff is IGovActionParameterChange\nstuff\nstuff is IGovActionParameterChange\nstuff: any\nany\nstuff is IGovActionParameterChange\nstuff is IGovActionParameterChange\nsrc/governance/GovAction/GovActionParameterChange.ts:19"
  },
  {
    "prompt": "isIGovActionTreasuryWithdrawals?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIGovActionTreasuryWithdrawals\nisIGovActionTreasuryWithdrawals(stuff): stuff is IGovActionTreasuryWithdrawals\nstuff\nstuff is IGovActionTreasuryWithdrawals\nstuff: any\nany\nstuff is IGovActionTreasuryWithdrawals\nstuff is IGovActionTreasuryWithdrawals\nsrc/governance/GovAction/GovActionTreasuryWithdrawals.ts:17"
  },
  {
    "prompt": "isIGovActionUpdateCommittee?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIGovActionUpdateCommittee\nisIGovActionUpdateCommittee(stuff): stuff is IGovActionUpdateCommittee\nstuff\nstuff is IGovActionUpdateCommittee\nstuff: any\nany\nstuff is IGovActionUpdateCommittee\nstuff is IGovActionUpdateCommittee\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:39"
  },
  {
    "prompt": "isINewCommitteeEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isINewCommitteeEntry\nisINewCommitteeEntry(stuff): stuff is INewCommitteeEntry\nstuff\nstuff is INewCommitteeEntry\nstuff: any\nany\nstuff is INewCommitteeEntry\nstuff is INewCommitteeEntry\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:19"
  },
  {
    "prompt": "isIPoolParamsMetadata?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIPoolParamsMetadata\nisIPoolParamsMetadata(stuff): stuff is IPoolParamsMetadata\nstuff\nstuff is IPoolParamsMetadata\nstuff: any\nany\nstuff is IPoolParamsMetadata\nstuff is IPoolParamsMetadata\nsrc/ledger/PoolParams.ts:23"
  },
  {
    "prompt": "isIProposalProcedure?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIProposalProcedure\nisIProposalProcedure(stuff): stuff is IProposalProcedure\nstuff\nstuff is IProposalProcedure\nstuff: any\nany\nstuff is IProposalProcedure\nstuff is IProposalProcedure\nsrc/governance/ProposalProcedure.ts:20"
  },
  {
    "prompt": "isIProtocolVersion?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIProtocolVersion\nisIProtocolVersion(ppv): ppv is IProtocolVerision\nppv\nppv is IProtocolVerision\nppv: any\nany\nppv is IProtocolVerision\nppv is IProtocolVerision\nsrc/ledger/protocol/protocolVersion.ts:30"
  },
  {
    "prompt": "isITxBody?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isITxBody\nisITxBody(body): body is ITxBody\nbody\nbody is ITxBody\nbody: object\nobject\nbody is ITxBody\nbody is ITxBody\nsrc/tx/body/TxBody.ts:40"
  },
  {
    "prompt": "isITxOut?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isITxOut\nisITxOut(stuff): stuff is ITxOut\nstuff\nstuff is ITxOut\nstuff: any\nany\nstuff is ITxOut\nstuff is ITxOut\nsrc/tx/body/output/TxOut.ts:23"
  },
  {
    "prompt": "isITxOutRef?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isITxOutRef\nisITxOutRef(stuff): stuff is ITxOutRef\nstuff\nstuff is ITxOutRef\nstuff: any\nany\nstuff is ITxOutRef\nstuff is ITxOutRef\nsrc/tx/body/output/TxOutRef.ts:21"
  },
  {
    "prompt": "isITxWithdrawals?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isITxWithdrawals\nisITxWithdrawals(stuff): stuff is ITxWithdrawals\nstuff\nstuff is ITxWithdrawals\nstuff: any\nany\nstuff is ITxWithdrawals\nstuff is ITxWithdrawals\nsrc/ledger/TxWithdrawals.ts:45"
  },
  {
    "prompt": "isITxWitnessSet?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isITxWitnessSet\nisITxWitnessSet(set): set is ITxWitnessSet\nset\nset is ITxWitnessSet\nset: object\nobject\nset is ITxWitnessSet\nset is ITxWitnessSet\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:36"
  },
  {
    "prompt": "isIUTxO?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIUTxO\nisIUTxO(stuff): stuff is IUTxO\nstuff\nstuff is IUTxO\nstuff: any\nany\nstuff is IUTxO\nstuff is IUTxO\nsrc/tx/body/output/UTxO.ts:17"
  },
  {
    "prompt": "isIValue?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIValue\nisIValue(entries): entries is IValue\nentries\nentries is IValue\nentries: any[]\nany\nentries is IValue\nentries is IValue\nsrc/ledger/Value/IValue.ts:239"
  },
  {
    "prompt": "isIValueAssetBI?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIValueAssetBI\nisIValueAssetBI(stuff): stuff is IValueAssetBI\nstuff\nstuff is IValueAssetBI\nstuff: any\nany\nstuff is IValueAssetBI\nstuff is IValueAssetBI\nsrc/ledger/Value/IValue.ts:66"
  },
  {
    "prompt": "isIVoter?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIVoter\nisIVoter(stuff): stuff is IVoter\nstuff\nstuff is IVoter\nstuff: any\nany\nstuff is IVoter\nstuff is IVoter\nsrc/governance/Voter.ts:34"
  },
  {
    "prompt": "isIVotingProceduresEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIVotingProceduresEntry\nisIVotingProceduresEntry(stuff): stuff is IVotingProceduresEntry\nstuff\nstuff is IVotingProceduresEntry\nstuff: any\nany\nstuff is IVotingProceduresEntry\nstuff is IVotingProceduresEntry\nsrc/governance/VotingProcedures.ts:18"
  },
  {
    "prompt": "isIpPoolRelay?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isIpPoolRelay\nisIpPoolRelay T (something): something is T & IpPoolRelay\nT\nsomething\nsomething is T & IpPoolRelay\nT extends object\nobject\nsomething: T\nT\nsomething is T & IpPoolRelay\nsomething is T & IpPoolRelay\nsrc/ledger/PoolRelay.ts:87"
  },
  {
    "prompt": "isLegacyPPUpdateMap?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isLegacyPPUpdateMap\nisLegacyPPUpdateMap(something): something is LegacyPPUpdateMap\nsomething\nsomething is LegacyPPUpdateMap\nsomething: object\nobject\nsomething is LegacyPPUpdateMap\nsomething is LegacyPPUpdateMap\nsrc/ledger/protocol/LegacyPPUpdateProposal.ts:16"
  },
  {
    "prompt": "isLegacyPPUpdateProposal?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isLegacyPPUpdateProposal\nisLegacyPPUpdateProposal(something): something is LegacyPPUpdateProposal\nsomething\nsomething is LegacyPPUpdateProposal\nsomething: any\nany\nsomething is LegacyPPUpdateProposal\nsomething is LegacyPPUpdateProposal\nsrc/ledger/protocol/LegacyPPUpdateProposal.ts:30"
  },
  {
    "prompt": "isMultiHostPoolRelay?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isMultiHostPoolRelay\nisMultiHostPoolRelay T (something): something is T & MultiHostPoolRelay\nT\nsomething\nsomething is T & MultiHostPoolRelay\nT extends object\nobject\nsomething: T\nT\nsomething is T & MultiHostPoolRelay\nsomething is T & MultiHostPoolRelay\nsrc/ledger/PoolRelay.ts:118"
  },
  {
    "prompt": "isNormalizedIValuePolicyEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isNormalizedIValuePolicyEntry\nisNormalizedIValuePolicyEntry(stuff): stuff is NormalizedIValuePolicyEntry\nstuff\nstuff is NormalizedIValuePolicyEntry\nstuff: any\nany\nstuff is NormalizedIValuePolicyEntry\nstuff is NormalizedIValuePolicyEntry\nsrc/ledger/Value/IValue.ts:103"
  },
  {
    "prompt": "isPParamsDrepVotingThresholds?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isPParamsDrepVotingThresholds\nisPParamsDrepVotingThresholds(stuff): stuff is PParamsDrepVotingThresholds\nstuff\nstuff is PParamsDrepVotingThresholds\nstuff: any\nany\nstuff is PParamsDrepVotingThresholds\nstuff is PParamsDrepVotingThresholds\nsrc/ledger/protocol/PParamsDrepVotingThresholds.ts:18"
  },
  {
    "prompt": "isPParamsPoolVotingThresholds?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isPParamsPoolVotingThresholds\nisPParamsPoolVotingThresholds(stuff): stuff is PParamsPoolVotingThresholds\nstuff\nstuff is PParamsPoolVotingThresholds\nstuff: any\nany\nstuff is PParamsPoolVotingThresholds\nstuff is PParamsPoolVotingThresholds\nsrc/ledger/protocol/PParamsPoolVotingThresholds.ts:13"
  },
  {
    "prompt": "isPartialProtocolParameters?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isPartialProtocolParameters\nisPartialProtocolParameters(something): something is Partial ProtocolParameters\nsomething\nsomething is Partial<ProtocolParameters>\nsomething: object\nobject\nsomething is Partial ProtocolParameters\nsomething is Partial<ProtocolParameters>\nsrc/ledger/protocol/ProtocolParameters.ts:172"
  },
  {
    "prompt": "isPoolRelay?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isPoolRelay\nisPoolRelay T (something): something is T & PoolRelay\nT\nsomething\nsomething is T & PoolRelay\nT extends object\nobject\nsomething: T\nT\nsomething is T & PoolRelay\nsomething is T & PoolRelay\nsrc/ledger/PoolRelay.ts:128"
  },
  {
    "prompt": "isProtocolParameters?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isProtocolParameters\nisProtocolParameters(something): something is ProtocolParameters\nsomething\nsomething is ProtocolParameters\nsomething: any\nany\nsomething is ProtocolParameters\nsomething is ProtocolParameters\nsrc/ledger/protocol/ProtocolParameters.ts:57"
  },
  {
    "prompt": "isRational?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isRational\nisRational(n): n is Rational\nn\nn is Rational\nn: any\nany\nn is Rational\nn is Rational\nsrc/ledger/protocol/Rational.ts:17"
  },
  {
    "prompt": "isRationalOrUndefined?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isRationalOrUndefined\nisRationalOrUndefined(n): n is undefined | Rational\nn\nn: any\nany\nn is undefined | Rational\nsrc/ledger/protocol/Rational.ts:22"
  },
  {
    "prompt": "isTxMetadatum?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isTxMetadatum\nisTxMetadatum(something): something is TxMetadatum\nsomething\nsomething is TxMetadatum\nsomething: any\nany\nsomething is TxMetadatum\nsomething is TxMetadatum\nsrc/tx/metadata/TxMetadatum.ts:50"
  },
  {
    "prompt": "isTxWithdrawalsMap?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isTxWithdrawalsMap\nisTxWithdrawalsMap(stuff): stuff is ITxWithdrawalsMap\nstuff\nstuff is ITxWithdrawalsMap\nstuff: any\nany\nstuff is ITxWithdrawalsMap\nstuff is ITxWithdrawalsMap\nsrc/ledger/TxWithdrawals.ts:32"
  },
  {
    "prompt": "isVote?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isVote\nisVote(stuff): stuff is Vote\nstuff\nstuff is Vote\nstuff: any\nany\nstuff is Vote\nstuff is Vote\nsrc/governance/Vote.ts:11"
  },
  {
    "prompt": "isVoterKind?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / isVoterKind\nisVoterKind(stuff): stuff is VoterKind\nstuff\nstuff is VoterKind\nstuff: any\nany\nstuff is VoterKind\nstuff is VoterKind\nsrc/governance/Voter.ts:19"
  },
  {
    "prompt": "nativeScriptFromCbor?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / nativeScriptFromCbor\nnativeScriptFromCbor(cbor): NativeScript\ncbor\nNativeScript\ncbor: CborString\nCborString\nNativeScript\nNativeScript\nsrc/script/NativeScript.ts:167"
  },
  {
    "prompt": "nativeScriptFromCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / nativeScriptFromCborObj\nnativeScriptFromCborObj(cbor): NativeScript\ncbor\nNativeScript\ncbor: CborObj\nCborObj\nNativeScript\nNativeScript\nsrc/script/NativeScript.ts:98"
  },
  {
    "prompt": "nativeScriptToCbor?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / nativeScriptToCbor\nnativeScriptToCbor(nativeScript): CborString\nnativeScript\nCborString\nnativeScript: NativeScript\nNativeScript\nCborString\nCborString\nsrc/script/NativeScript.ts:89"
  },
  {
    "prompt": "nativeScriptToCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / nativeScriptToCborObj\nnativeScriptToCborObj(nativeScript): CborArray\nnativeScript\nCborArray\nnativeScript: NativeScript\nNativeScript\nCborArray\nCborArray\nsrc/script/NativeScript.ts:45"
  },
  {
    "prompt": "normalizeIValue?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / normalizeIValue\nnormalizeIValue(val): NormalizedIValue\nval\nNormalizedIValue\nval: IValue\nIValue\nNormalizedIValue\nNormalizedIValue\nsrc/ledger/Value/IValue.ts:13"
  },
  {
    "prompt": "normalizeIValueAsset?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / normalizeIValueAsset\nnormalizeIValueAsset(asset): IValueAssetBI\nasset\nIValueAssetBI\nasset: IValueAsset\nIValueAsset\nIValueAssetBI\nIValueAssetBI\nsrc/ledger/Value/IValue.ts:53"
  },
  {
    "prompt": "normalizeIValuePolicyEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / normalizeIValuePolicyEntry\nnormalizeIValuePolicyEntry(__namedParameters): NormalizedIValuePolicyEntry\n__namedParameters\nNormalizedIValuePolicyEntry\n__namedParameters: IValuePolicyEntry\nIValuePolicyEntry\nNormalizedIValuePolicyEntry\nNormalizedIValuePolicyEntry\nsrc/ledger/Value/IValue.ts:84"
  },
  {
    "prompt": "numberFromRational?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / numberFromRational\nnumberFromRational(n): number\nn\nnumber\nn: Rational\nRational\nnumber\nnumber\nsrc/ledger/protocol/Rational.ts:40"
  },
  {
    "prompt": "partialProtocolParametersFromCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / partialProtocolParametersFromCborObj\npartialProtocolParametersFromCborObj(cObj): Partial ProtocolParameters\ncObj\nPartial\nProtocolParameters\ncObj: CborObj\nCborObj\nPartial ProtocolParameters\nPartial\nProtocolParameters\nsrc/ledger/protocol/ProtocolParameters.ts:391"
  },
  {
    "prompt": "partialProtocolParametersToCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / partialProtocolParametersToCborObj\npartialProtocolParametersToCborObj(pps): CborMap\npps\nCborMap\npps: Partial ProtocolParameters\nPartial\nProtocolParameters\nCborMap\nCborMap\nsrc/ledger/protocol/ProtocolParameters.ts:277"
  },
  {
    "prompt": "partialProtocolParametersToData?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / partialProtocolParametersToData\npartialProtocolParametersToData(pps): Data\npps\nData\npps: Partial ProtocolParameters\nPartial\nProtocolParameters\nData\nData\nsrc/ledger/protocol/ProtocolParameters.ts:342"
  },
  {
    "prompt": "partialProtocolParamsToJson?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / partialProtocolParamsToJson\npartialProtocolParamsToJson(pp): object\npp\nobject\npp: Partial ProtocolParameters\nPartial\nProtocolParameters\nobject\nobject\noptional collateralPercentage: CanBeUInteger\noptional\nCanBeUInteger\noptional committeeTermLimit: CanBeUInteger\noptional\nCanBeUInteger\ncostModels: undefined | object\nundefined\nobject\noptional drepActivityPeriod: CanBeUInteger\noptional\nCanBeUInteger\noptional drepDeposit: CanBeUInteger\noptional\nCanBeUInteger\noptional drepVotingThresholds: PParamsDrepVotingThresholds\noptional\nPParamsDrepVotingThresholds\nexecutionUnitPrices: undefined | object\nundefined\nobject\noptional governanceActionDeposit: CanBeUInteger\noptional\nCanBeUInteger\noptional governanceActionValidityPeriod: CanBeUInteger\noptional\nCanBeUInteger\noptional maxBlockBodySize: CanBeUInteger\noptional\nCanBeUInteger\nmaxBlockExecutionUnits: undefined | ExBudgetJson | object\nundefined\nExBudgetJson\nobject\noptional maxBlockHeaderSize: CanBeUInteger\noptional\nCanBeUInteger\noptional maxCollateralInputs: CanBeUInteger\noptional\nCanBeUInteger\nmaxTxExecutionUnits: undefined | ExBudgetJson | object\nundefined\nExBudgetJson\nobject\noptional maxTxSize: CanBeUInteger\noptional\nCanBeUInteger\noptional maxValueSize: CanBeUInteger\noptional\nCanBeUInteger\noptional minCommitteSize: CanBeUInteger\noptional\nCanBeUInteger\noptional minPoolCost: CanBeUInteger\noptional\nCanBeUInteger\noptional minfeeRefScriptCostPerByte: Rational\noptional\nRational\nmonetaryExpansion: undefined | number\nundefined\nnumber\npoolPledgeInfluence: undefined | number\nundefined\nnumber\noptional poolRetireMaxEpoch: CanBeUInteger\noptional\nCanBeUInteger\noptional poolVotingThresholds: PParamsPoolVotingThresholds\noptional\nPParamsPoolVotingThresholds\noptional protocolVersion: IProtocolVerision\noptional\nIProtocolVerision\nprotocolVersion removed in conway\noptional stakeAddressDeposit: CanBeUInteger\noptional\nCanBeUInteger\noptional stakePoolDeposit: CanBeUInteger\noptional\nCanBeUInteger\noptional stakePoolTargetNum: CanBeUInteger\noptional\nCanBeUInteger\ntreasuryCut: undefined | number\nundefined\nnumber\noptional txFeeFixed: CanBeUInteger\noptional\nCanBeUInteger\noptional txFeePerByte: CanBeUInteger\noptional\nCanBeUInteger\noptional utxoCostPerByte: CanBeUInteger\noptional\nCanBeUInteger\nsrc/ledger/protocol/ProtocolParameters.ts:552"
  },
  {
    "prompt": "poolRelayFromCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / poolRelayFromCborObj\npoolRelayFromCborObj(cObj): PoolRelay\ncObj\nPoolRelay\ncObj: CborObj\nCborObj\nPoolRelay\nPoolRelay\nsrc/ledger/PoolRelay.ts:192"
  },
  {
    "prompt": "poolRelayToCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / poolRelayToCborObj\npoolRelayToCborObj(poolRelay): CborObj\npoolRelay\nCborObj\npoolRelay: PoolRelay\nPoolRelay\nCborObj\nCborObj\nsrc/ledger/PoolRelay.ts:137"
  },
  {
    "prompt": "poolRelayToJson?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / poolRelayToJson\npoolRelayToJson(relay): object | object | object\nrelay\nobject\nobject\nobject\nrelay: PoolRelay\nPoolRelay\nobject | object | object\nobject\nobject\nobject\nsrc/ledger/PoolRelay.ts:32"
  },
  {
    "prompt": "poolVotingThresholdsToCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / poolVotingThresholdsToCborObj\npoolVotingThresholdsToCborObj(poolVotingThresholds): CborArray\npoolVotingThresholds\nCborArray\npoolVotingThresholds: PParamsPoolVotingThresholds\nPParamsPoolVotingThresholds\nCborArray\nCborArray\nsrc/ledger/protocol/PParamsPoolVotingThresholds.ts:24"
  },
  {
    "prompt": "protocolUpdateToJson?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / protocolUpdateToJson\nprotocolUpdateToJson(pUp): object\npUp\nobject\npUp: LegacyPPUpdateProposal\nLegacyPPUpdateProposal\nobject\nobject\nsrc/ledger/protocol/LegacyPPUpdateProposal.ts:40"
  },
  {
    "prompt": "protocolVersionAsArray?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / protocolVersionAsArray\nprotocolVersionAsArray(ppv): IProtocolVersionArr\nppv\nIProtocolVersionArr\nppv: IProtocolVerision\nIProtocolVerision\nIProtocolVersionArr\nIProtocolVersionArr\nsrc/ledger/protocol/protocolVersion.ts:16"
  },
  {
    "prompt": "protocolVersionAsObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / protocolVersionAsObj\nprotocolVersionAsObj(ppv): IProtocolVerisionObj\nppv\nIProtocolVerisionObj\nppv: IProtocolVerision\nIProtocolVerision\nIProtocolVerisionObj\nIProtocolVerisionObj\nsrc/ledger/protocol/protocolVersion.ts:21"
  },
  {
    "prompt": "protocolVersionToCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / protocolVersionToCborObj\nprotocolVersionToCborObj(ppv): CborArray\nppv\nCborArray\nppv: IProtocolVerision\nIProtocolVerision\nCborArray\nCborArray\nsrc/ledger/protocol/protocolVersion.ts:43"
  },
  {
    "prompt": "rewardSourceToStr?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / rewardSourceToStr\nrewardSourceToStr S (source): RewardSourceToStr S\nS\nsource\nRewardSourceToStr\nS\nS extends InstantRewardsSource\nInstantRewardsSource\nsource: S\nS\nRewardSourceToStr S\nRewardSourceToStr\nS\nsrc/ledger/certs/MoveInstantRewardsCert.ts:26"
  },
  {
    "prompt": "subIValues?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / subIValues\nsubIValues(a, b): IValue\na\nb\nIValue\na: IValue\nIValue\nb: IValue\nIValue\nIValue\nIValue\nsrc/ledger/Value/IValue.ts:458"
  },
  {
    "prompt": "toRealDRep?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / toRealDRep\ntoRealDRep(like): DRep\nlike\nDRep\nlike: DRepLike\nDRepLike\nDRep\nDRep\nsrc/governance/DRep/DRepLike.ts:32"
  },
  {
    "prompt": "toRealGovAction?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / toRealGovAction\ntoRealGovAction(govActionLike): GovAction\ngovActionLike\nGovAction\ngovActionLike: GovActionLike\nGovActionLike\nGovAction\nGovAction\nsrc/governance/GovAction/GovActionLike.ts:21"
  },
  {
    "prompt": "tryCborFromRational?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / tryCborFromRational\ntryCborFromRational(n): CborPositiveRational | undefined\nn\nCborPositiveRational\nundefined\nn: any\nany\nCborPositiveRational | undefined\nCborPositiveRational\nundefined\nsrc/ledger/protocol/Rational.ts:32"
  },
  {
    "prompt": "tryGetPParamsDrepVotingThresholdsFromCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / tryGetPParamsDrepVotingThresholdsFromCborObj\ntryGetPParamsDrepVotingThresholdsFromCborObj(cbor): PParamsDrepVotingThresholds | undefined\ncbor\nPParamsDrepVotingThresholds\nundefined\ncbor: undefined | CborObj\nundefined\nCborObj\nPParamsDrepVotingThresholds | undefined\nPParamsDrepVotingThresholds\nundefined\nsrc/ledger/protocol/PParamsDrepVotingThresholds.ts:50"
  },
  {
    "prompt": "tryGetPParamsPoolVotingThresholdsFromCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / tryGetPParamsPoolVotingThresholdsFromCborObj\ntryGetPParamsPoolVotingThresholdsFromCborObj(cbor): PParamsPoolVotingThresholds | undefined\ncbor\nPParamsPoolVotingThresholds\nundefined\ncbor: undefined | CborObj\nundefined\nCborObj\nPParamsPoolVotingThresholds | undefined\nPParamsPoolVotingThresholds\nundefined\nsrc/ledger/protocol/PParamsPoolVotingThresholds.ts:35"
  },
  {
    "prompt": "tryIProtocolVersionFromCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / tryIProtocolVersionFromCborObj\ntryIProtocolVersionFromCborObj(cbor): [bigint, bigint] | undefined\ncbor\nbigint\nbigint\nundefined\ncbor: undefined | CborObj\nundefined\nCborObj\n[bigint, bigint] | undefined\nbigint\nbigint\nundefined\nsrc/ledger/protocol/protocolVersion.ts:52"
  },
  {
    "prompt": "txMetadatumFromCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / txMetadatumFromCborObj\ntxMetadatumFromCborObj(cObj): TxMetadatum\ncObj\nTxMetadatum\ncObj: CborObj\nCborObj\nTxMetadatum\nTxMetadatum\nsrc/tx/metadata/TxMetadatum.ts:17"
  },
  {
    "prompt": "txRdmrTagToString?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / txRdmrTagToString\ntxRdmrTagToString(tag): string\ntag\nstring\ntag: TxRedeemerTag\nTxRedeemerTag\nstring\nstring\nsrc/tx/TxWitnessSet/TxRedeemer.ts:24"
  },
  {
    "prompt": "txRedeemerTagToString?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / txRedeemerTagToString\ntxRedeemerTagToString Tag (tag): TxRedeemerTagStr Tag\nTag\ntag\nTxRedeemerTagStr\nTag\nTag extends TxRedeemerTag\nTxRedeemerTag\ntag: Tag\nTag\nTxRedeemerTagStr Tag\nTxRedeemerTagStr\nTag\nsrc/tx/TxWitnessSet/TxRedeemer.ts:47"
  },
  {
    "prompt": "typedPoolParamsMetadata?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / typedPoolParamsMetadata\ntypedPoolParamsMetadata(__namedParameters): ITypedPoolParamsMetadata\n__namedParameters\nITypedPoolParamsMetadata\n__namedParameters: IPoolParamsMetadata\nIPoolParamsMetadata\nITypedPoolParamsMetadata\nITypedPoolParamsMetadata\nsrc/ledger/PoolParams.ts:36"
  },
  {
    "prompt": "voteToCborObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / voteToCborObj\nvoteToCborObj(vote): CborUInt\nvote\nCborUInt\nvote: Vote\nVote\nCborUInt\nCborUInt\nsrc/governance/Vote.ts:19"
  },
  {
    "prompt": "DnsPoolRelay?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / DnsPoolRelay\ndnsName: string\nstring\nsrc/ledger/PoolRelay.ts:22\noptional port: CanBeUInteger\noptional\nCanBeUInteger\nsrc/ledger/PoolRelay.ts:21\ntype: \"dns\"\n\"dns\"\nsrc/ledger/PoolRelay.ts:20"
  },
  {
    "prompt": "IAnchor?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IAnchor\nanchorDataHash: CanBeHash32\nCanBeHash32\nsrc/governance/Anchor.ts:8\nurl: string\nstring\nsrc/governance/Anchor.ts:7"
  },
  {
    "prompt": "IAuxiliaryData?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IAuxiliaryData\noptional metadata: TxMetadata\noptional\nTxMetadata\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:13\noptional nativeScripts: (NativeScript | Script NativeScript )[]\noptional\nNativeScript\nScript\nNativeScript\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:14\noptional plutusV1Scripts: (Script PlutusV1 | PlutusScriptJsonFormat PlutusV1 | \"PlutusScriptV1\" )[]\noptional\nScript\nPlutusV1\nPlutusScriptJsonFormat\nPlutusV1\n\"PlutusScriptV1\"\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:15\noptional plutusV2Scripts: (Script PlutusV2 | PlutusScriptJsonFormat PlutusV2 | \"PlutusScriptV2\" )[]\noptional\nScript\nPlutusV2\nPlutusScriptJsonFormat\nPlutusV2\n\"PlutusScriptV2\"\nsrc/tx/AuxiliaryData/AuxiliaryData.ts:16"
  },
  {
    "prompt": "ICert?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICert\nToData\ncertType: CertificateType\nCertificateType\nsrc/ledger/certs/ICert.ts:6\ngetRequiredSigners: () = Hash28[]\nHash28\nHash28[]\nHash28\nsrc/ledger/certs/ICert.ts:7\ntoData: (version?) = Data\nversion\nData\nversion?: \"v1\" | \"v2\" | \"v3\"\n\"v1\"\n\"v2\"\n\"v3\"\nData\nData\nToData.toData\nToData.toData\nnode_modules/@harmoniclabs/plutus-data/dist/toData/interface.d.ts:3"
  },
  {
    "prompt": "ICertAuthCommitteeHot?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertAuthCommitteeHot\ncoldCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertAuthCommitteeHot.ts:12\nhotCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertAuthCommitteeHot.ts:13"
  },
  {
    "prompt": "ICertGenesisKeyDelegation?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertGenesisKeyDelegation\ngenesisDelegateHash: CanBeHash28\nCanBeHash28\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:12\ngenesisHash: CanBeHash28\nCanBeHash28\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:11\nvrfKeyHash: CanBeHash32\nCanBeHash32\nsrc/ledger/certs/CertGenesisKeyDelegation.ts:13"
  },
  {
    "prompt": "ICertPoolRegistration?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertPoolRegistration\npoolParams: IPoolParams\nIPoolParams\nsrc/ledger/certs/CertPoolRegistration.ts:12"
  },
  {
    "prompt": "ICertPoolRetirement?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertPoolRetirement\nepoch: CanBeUInteger\nCanBeUInteger\nsrc/ledger/certs/CertPoolRetirement.ts:14\npoolHash: CanBeHash28\nCanBeHash28\nsrc/ledger/certs/CertPoolRetirement.ts:13"
  },
  {
    "prompt": "ICertRegistrationDeposit?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertRegistrationDeposit\ndeposit: CanBeUInteger\nCanBeUInteger\nsrc/ledger/certs/CertRegistrationDeposit.ts:15\nstakeCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertRegistrationDeposit.ts:14"
  },
  {
    "prompt": "ICertRegistrationDrep?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertRegistrationDrep\noptional anchor: IAnchor\noptional\nIAnchor\nsrc/ledger/certs/CertRegistrationDrep.ts:16\ncoin: CanBeUInteger\nCanBeUInteger\nsrc/ledger/certs/CertRegistrationDrep.ts:15\ndrepCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertRegistrationDrep.ts:14"
  },
  {
    "prompt": "ICertResignCommitteeCold?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertResignCommitteeCold\noptional anchor: IAnchor\noptional\nIAnchor\nsrc/ledger/certs/CertResignCommitteeCold.ts:13\ncoldCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertResignCommitteeCold.ts:12"
  },
  {
    "prompt": "ICertStakeDeRegistration?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertStakeDeRegistration\nstakeCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertStakeDeRegistration.ts:12"
  },
  {
    "prompt": "ICertStakeDelegation?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertStakeDelegation\npoolKeyHash: CanBeHash28\nCanBeHash28\nsrc/ledger/certs/CertStakeDelegation.ts:13\nstakeCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertStakeDelegation.ts:12"
  },
  {
    "prompt": "ICertStakeRegistration?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertStakeRegistration\nstakeCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertStakeRegistration.ts:12"
  },
  {
    "prompt": "ICertStakeRegistrationDeleg?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertStakeRegistrationDeleg\ncoin: CanBeUInteger\nCanBeUInteger\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:17\npoolKeyHash: CanBeHash28\nCanBeHash28\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:16\nstakeCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertStakeRegistrationDeleg.ts:15"
  },
  {
    "prompt": "ICertStakeVoteDeleg?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertStakeVoteDeleg\ndrep: DRepLike\nDRepLike\nsrc/ledger/certs/CertStakeVoteDeleg.ts:15\npoolKeyHash: CanBeHash28\nCanBeHash28\nsrc/ledger/certs/CertStakeVoteDeleg.ts:14\nstakeCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertStakeVoteDeleg.ts:13"
  },
  {
    "prompt": "ICertStakeVoteRegistrationDeleg?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertStakeVoteRegistrationDeleg\ncoin: CanBeUInteger\nCanBeUInteger\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:19\ndrep: DRepLike\nDRepLike\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:18\npoolKeyHash: CanBeHash28\nCanBeHash28\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:17\nstakeCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertStakeVoteRegistrationDeleg.ts:16"
  },
  {
    "prompt": "ICertUnRegistrationDeposit?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertUnRegistrationDeposit\ndeposit: CanBeUInteger\nCanBeUInteger\nsrc/ledger/certs/CertUnRegistrationDeposit.ts:15\nstakeCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertUnRegistrationDeposit.ts:14"
  },
  {
    "prompt": "ICertUnRegistrationDrep?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertUnRegistrationDrep\ncoin: CanBeUInteger\nCanBeUInteger\nsrc/ledger/certs/CertUnRegistrationDrep.ts:15\ndrepCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertUnRegistrationDrep.ts:14"
  },
  {
    "prompt": "ICertUpdateDrep?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertUpdateDrep\noptional anchor: IAnchor\noptional\nIAnchor\nsrc/ledger/certs/CertUpdateDrep.ts:13\ndrepCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertUpdateDrep.ts:12"
  },
  {
    "prompt": "ICertVoteDeleg?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertVoteDeleg\ndrep: DRepLike\nDRepLike\nsrc/ledger/certs/CertVoteDeleg.ts:14\nstakeCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertVoteDeleg.ts:13"
  },
  {
    "prompt": "ICertVoteRegistrationDeleg?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ICertVoteRegistrationDeleg\ncoin: CanBeUInteger\nCanBeUInteger\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:17\ndrep: DRepLike\nDRepLike\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:16\nstakeCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/ledger/certs/CertVoteRegistrationDeleg.ts:15"
  },
  {
    "prompt": "IConstitution?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IConstitution\nanchor: IAnchor\nIAnchor\nsrc/governance/Constitution.ts:12\noptional scriptHash: CanBeHash28\noptional\nCanBeHash28\nsrc/governance/Constitution.ts:13"
  },
  {
    "prompt": "IDRep?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IDRep\nToData\ndrepType: DRepType\nDRepType\nsrc/governance/DRep/IDRep.ts:6\ntoData: (version?) = Data\nversion\nData\nversion?: \"v1\" | \"v2\" | \"v3\"\n\"v1\"\n\"v2\"\n\"v3\"\nData\nData\nToData.toData\nToData.toData\nnode_modules/@harmoniclabs/plutus-data/dist/toData/interface.d.ts:3"
  },
  {
    "prompt": "IDRepAlwaysAbstain?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IDRepAlwaysAbstain\noptional hash: undefined\noptional\nundefined\nsrc/governance/DRep/DRepAlwaysAbstain.ts:9"
  },
  {
    "prompt": "IDRepAlwaysNoConfidence?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IDRepAlwaysNoConfidence\noptional hash: undefined\noptional\nundefined\nsrc/governance/DRep/DRepAlwaysNoConfidence.ts:9"
  },
  {
    "prompt": "IDRepKeyHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IDRepKeyHash\nhash: CanBeHash28\nCanBeHash28\nsrc/governance/DRep/DRepKeyHash.ts:12"
  },
  {
    "prompt": "IDRepScript?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IDRepScript\nhash: CanBeHash28\nCanBeHash28\nsrc/governance/DRep/DRepScript.ts:12"
  },
  {
    "prompt": "IGovAction?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IGovAction\ngovActionType: GovActionType\nGovActionType\nsrc/governance/GovAction/IGovAction.ts:4"
  },
  {
    "prompt": "IGovActionInfo?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IGovActionInfo"
  },
  {
    "prompt": "IGovActionInitHardFork?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IGovActionInitHardFork\noptional govActionId: ITxOutRef\noptional\nITxOutRef\nsrc/governance/GovAction/GovActionInitHardFork.ts:15\nprotocolVersion: IProtocolVerision\nIProtocolVerision\nsrc/governance/GovAction/GovActionInitHardFork.ts:16"
  },
  {
    "prompt": "IGovActionNewConstitution?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IGovActionNewConstitution\nconstitution: IConstitution\nIConstitution\nsrc/governance/GovAction/GovActionNewConstitution.ts:14\noptional govActionId: ITxOutRef\noptional\nITxOutRef\nsrc/governance/GovAction/GovActionNewConstitution.ts:13"
  },
  {
    "prompt": "IGovActionNoConfidence?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IGovActionNoConfidence\noptional govActionId: ITxOutRef\noptional\nITxOutRef\nsrc/governance/GovAction/GovActionNoConfidence.ts:12"
  },
  {
    "prompt": "IGovActionParameterChange?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IGovActionParameterChange\noptional govActionId: ITxOutRef\noptional\nITxOutRef\nsrc/governance/GovAction/GovActionParameterChange.ts:14\noptional policyHash: CanBeHash28\noptional\nCanBeHash28\nsrc/governance/GovAction/GovActionParameterChange.ts:16\nprotocolParamsUpdate: Partial ProtocolParameters\nPartial\nProtocolParameters\nsrc/governance/GovAction/GovActionParameterChange.ts:15"
  },
  {
    "prompt": "IGovActionTreasuryWithdrawals?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IGovActionTreasuryWithdrawals\noptional policyHash: CanBeHash28\noptional\nCanBeHash28\nsrc/governance/GovAction/GovActionTreasuryWithdrawals.ts:14\nwithdrawals: ITxWithdrawals | TxWithdrawals\nITxWithdrawals\nTxWithdrawals\nsrc/governance/GovAction/GovActionTreasuryWithdrawals.ts:13"
  },
  {
    "prompt": "IGovActionUpdateCommittee?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IGovActionUpdateCommittee\noptional govActionId: ITxOutRef\noptional\nITxOutRef\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:33\nthreshold: Rational\nRational\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:36\ntoAdd: INewCommitteeEntry[]\nINewCommitteeEntry\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:35\ntoRemove: Credential CredentialType []\nCredential\nCredentialType\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:34"
  },
  {
    "prompt": "IMoveInstantRewardsCert?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IMoveInstantRewardsCert\ndestination: CanBeUInteger | RewardsMap\nCanBeUInteger\nRewardsMap\nsrc/ledger/certs/MoveInstantRewardsCert.ts:86\nsource: InstantRewardsSource\nInstantRewardsSource\nsrc/ledger/certs/MoveInstantRewardsCert.ts:85"
  },
  {
    "prompt": "INewCommitteeEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / INewCommitteeEntry\ncoldCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:15\nepoch: CanBeUInteger\nCanBeUInteger\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:16"
  },
  {
    "prompt": "INewCommitteeEntryBI?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / INewCommitteeEntryBI\ncoldCredential: Credential CredentialType\nCredential\nCredentialType\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:28\nepoch: bigint\nbigint\nsrc/governance/GovAction/GovAcitonUpdateCommittee.ts:29"
  },
  {
    "prompt": "IPoolParams?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IPoolParams\ncost: CanBeUInteger\nCanBeUInteger\nsrc/ledger/PoolParams.ts:48\nmargin: Rational\nRational\nsrc/ledger/PoolParams.ts:49\noptional metadata: IPoolParamsMetadata\noptional\nIPoolParamsMetadata\nsrc/ledger/PoolParams.ts:53\noperator: CanBeHash28\nCanBeHash28\nsrc/ledger/PoolParams.ts:45\nowners: CanBeHash28[]\nCanBeHash28\nsrc/ledger/PoolParams.ts:51\npledge: CanBeUInteger\nCanBeUInteger\nsrc/ledger/PoolParams.ts:47\nrelays: PoolRelay[]\nPoolRelay\nsrc/ledger/PoolParams.ts:52\nrewardAccount: CanBeHash28 | StakeAddress StakeAddressType\nCanBeHash28\nStakeAddress\nStakeAddressType\nsrc/ledger/PoolParams.ts:50\nvrfKeyHash: CanBeHash32\nCanBeHash32\nsrc/ledger/PoolParams.ts:46"
  },
  {
    "prompt": "IPoolParamsMetadata?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IPoolParamsMetadata\nhash: CanBeHash32\nCanBeHash32\nsrc/ledger/PoolParams.ts:20\npoolMetadataUrl: string\nstring\nsrc/ledger/PoolParams.ts:19"
  },
  {
    "prompt": "IProposalProcedure?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IProposalProcedure\nanchor: IAnchor\nIAnchor\nsrc/governance/ProposalProcedure.ts:17\ndeposit: CanBeUInteger\nCanBeUInteger\nsrc/governance/ProposalProcedure.ts:14\ngovAction: GovActionLike\nGovActionLike\nsrc/governance/ProposalProcedure.ts:16\nrewardAccount: StakeAddress StakeAddressType\nStakeAddress\nStakeAddressType\nsrc/governance/ProposalProcedure.ts:15"
  },
  {
    "prompt": "IProtocolVerisionObj?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IProtocolVerisionObj\nmajor: number\nnumber\nsrc/ledger/protocol/protocolVersion.ts:6\nminor: number\nnumber\nsrc/ledger/protocol/protocolVersion.ts:7"
  },
  {
    "prompt": "ITx?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITx\noptional auxiliaryData: null | AuxiliaryData\noptional\nnull\nAuxiliaryData\nsrc/tx/Tx.ts:18\nbody: ITxBody\nITxBody\nsrc/tx/Tx.ts:15\noptional isScriptValid: boolean\noptional\nboolean\nsrc/tx/Tx.ts:17\nwitnesses: ITxWitnessSet\nITxWitnessSet\nsrc/tx/Tx.ts:16"
  },
  {
    "prompt": "ITxBody?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITxBody\noptional auxDataHash: AuxiliaryDataHash\noptional\nAuxiliaryDataHash\nsrc/tx/body/TxBody.ts:23\noptional certs: Certificate[]\noptional\nCertificate\nsrc/tx/body/TxBody.ts:20\noptional collateralInputs: UTxO[]\noptional\nUTxO\nsrc/tx/body/TxBody.ts:27\noptional collateralReturn: TxOut\noptional\nTxOut\nsrc/tx/body/TxBody.ts:30\noptional currentTreasuryValue: CanBeUInteger\noptional\nCanBeUInteger\nsrc/tx/body/TxBody.ts:36\noptional donation: CanBeUInteger\noptional\nCanBeUInteger\nsrc/tx/body/TxBody.ts:37\nfee: CanBeUInteger\nCanBeUInteger\nsrc/tx/body/TxBody.ts:18\ninputs: [UTxO, ...UTxO[]]\nUTxO\n...UTxO[]\nsrc/tx/body/TxBody.ts:16\noptional mint: Value\noptional\nValue\nsrc/tx/body/TxBody.ts:25\noptional network: NetworkT\noptional\nNetworkT\nsrc/tx/body/TxBody.ts:29\noutputs: TxOut[]\nTxOut\nsrc/tx/body/TxBody.ts:17\noptional proposalProcedures: (IProposalProcedure | ProposalProcedure)[]\noptional\nIProposalProcedure\nProposalProcedure\nsrc/tx/body/TxBody.ts:35\noptional protocolUpdate: LegacyPPUpdateProposal\noptional\nLegacyPPUpdateProposal\nsrc/tx/body/TxBody.ts:22\noptional refInputs: UTxO[]\noptional\nUTxO\nsrc/tx/body/TxBody.ts:32\noptional requiredSigners: PubKeyHash[]\noptional\nPubKeyHash\nsrc/tx/body/TxBody.ts:28\noptional scriptDataHash: ScriptDataHash\noptional\nScriptDataHash\nsrc/tx/body/TxBody.ts:26\noptional totCollateral: CanBeUInteger\noptional\nCanBeUInteger\nsrc/tx/body/TxBody.ts:31\noptional ttl: CanBeUInteger\noptional\nCanBeUInteger\nsrc/tx/body/TxBody.ts:19\noptional validityIntervalStart: CanBeUInteger\noptional\nCanBeUInteger\nsrc/tx/body/TxBody.ts:24\noptional votingProcedures: VotingProcedures | IVotingProcedures\noptional\nVotingProcedures\nIVotingProcedures\nsrc/tx/body/TxBody.ts:34\noptional withdrawals: ITxWithdrawals | TxWithdrawals\noptional\nITxWithdrawals\nTxWithdrawals\nsrc/tx/body/TxBody.ts:21"
  },
  {
    "prompt": "ITxRedeemer?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITxRedeemer\ndata: Data\nData\nsrc/tx/TxWitnessSet/TxRedeemer.ts:65\nexecUnits: ExBudget\nExBudget\nsrc/tx/TxWitnessSet/TxRedeemer.ts:66\nindex: CanBeUInteger\nCanBeUInteger\nsrc/tx/TxWitnessSet/TxRedeemer.ts:64\ntag: TxRedeemerTag\nTxRedeemerTag\nsrc/tx/TxWitnessSet/TxRedeemer.ts:63"
  },
  {
    "prompt": "ITxWitnessSet?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITxWitnessSet\noptional bootstrapWitnesses: BootstrapWitness[]\noptional\nBootstrapWitness\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:18\noptional datums: Data[]\noptional\nData\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:20\noptional nativeScripts: Script NativeScript []\noptional\nScript\nNativeScript\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:17\noptional plutusV1Scripts: Script PlutusV1 []\noptional\nScript\nPlutusV1\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:19\noptional plutusV2Scripts: Script PlutusV2 []\noptional\nScript\nPlutusV2\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:22\noptional plutusV3Scripts: Script PlutusV3 []\noptional\nScript\nPlutusV3\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:23\noptional redeemers: TxRedeemer[]\noptional\nTxRedeemer\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:21\noptional vkeyWitnesses: VKeyWitness[]\noptional\nVKeyWitness\nsrc/tx/TxWitnessSet/TxWitnessSet.ts:16"
  },
  {
    "prompt": "ITypedPoolParams?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITypedPoolParams\ncost: bigint\nbigint\nsrc/ledger/PoolParams.ts:60\nmargin: CborPositiveRational\nCborPositiveRational\nsrc/ledger/PoolParams.ts:61\noptional metadata: ITypedPoolParamsMetadata\noptional\nITypedPoolParamsMetadata\nsrc/ledger/PoolParams.ts:65\noperator: PoolKeyHash\nPoolKeyHash\nsrc/ledger/PoolParams.ts:57\nowners: PubKeyHash[]\nPubKeyHash\nsrc/ledger/PoolParams.ts:63\npledge: bigint\nbigint\nsrc/ledger/PoolParams.ts:59\nrelays: PoolRelay[]\nPoolRelay\nsrc/ledger/PoolParams.ts:64\nrewardAccount: StakeAddress StakeAddressType\nStakeAddress\nStakeAddressType\nsrc/ledger/PoolParams.ts:62\nvrfKeyHash: VRFKeyHash\nVRFKeyHash\nsrc/ledger/PoolParams.ts:58"
  },
  {
    "prompt": "ITypedPoolParamsMetadata?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITypedPoolParamsMetadata\nhash: Hash32\nHash32\nsrc/ledger/PoolParams.ts:33\npoolMetadataUrl: string\nstring\nsrc/ledger/PoolParams.ts:32"
  },
  {
    "prompt": "ITypedVotingProceduresEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITypedVotingProceduresEntry\nvoter: Voter\nVoter\nsrc/governance/VotingProcedures.ts:36\nvotes: object[]\nobject\nsrc/governance/VotingProcedures.ts:37"
  },
  {
    "prompt": "IValuePolicyEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IValuePolicyEntry\nassets: IValueAsset[]\nIValueAsset\nsrc/ledger/Value/IValue.ts:76\npolicy: CanBeHash28\nCanBeHash28\nsrc/ledger/Value/IValue.ts:75"
  },
  {
    "prompt": "IVoter?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IVoter\nhash: CanBeHash28\nCanBeHash28\nsrc/governance/Voter.ts:31\nkind: VoterKind\nVoterKind\nsrc/governance/Voter.ts:30"
  },
  {
    "prompt": "IVotingProceduresEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IVotingProceduresEntry\nvoter: IVoter\nIVoter\nsrc/governance/VotingProcedures.ts:11\nvotes: object[]\nobject\nsrc/governance/VotingProcedures.ts:12"
  },
  {
    "prompt": "MultiHostPoolRelay?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / MultiHostPoolRelay\ndnsName: string\nstring\nsrc/ledger/PoolRelay.ts:27\ntype: \"multi-host\"\n\"multi-host\"\nsrc/ledger/PoolRelay.ts:26"
  },
  {
    "prompt": "NormalizedIValuePolicyEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / NormalizedIValuePolicyEntry\nassets: IValueAssetBI[]\nIValueAssetBI\nsrc/ledger/Value/IValue.ts:81\npolicy: Hash28\nHash28\nsrc/ledger/Value/IValue.ts:80"
  },
  {
    "prompt": "PParamsDrepVotingThresholds?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / PParamsDrepVotingThresholds\ncommitteeNoConfidence: Rational\nRational\nsrc/ledger/protocol/PParamsDrepVotingThresholds.ts:8\ncommitteeNormal: Rational\nRational\nsrc/ledger/protocol/PParamsDrepVotingThresholds.ts:7\nhardForkInitiation: Rational\nRational\nsrc/ledger/protocol/PParamsDrepVotingThresholds.ts:10\nmotionNoConfidence: Rational\nRational\nsrc/ledger/protocol/PParamsDrepVotingThresholds.ts:6\nppEconomicGroup: Rational\nRational\nsrc/ledger/protocol/PParamsDrepVotingThresholds.ts:12\nppGovGroup: Rational\nRational\nsrc/ledger/protocol/PParamsDrepVotingThresholds.ts:14\nppNetworkGroup: Rational\nRational\nsrc/ledger/protocol/PParamsDrepVotingThresholds.ts:11\nppTechnicalGroup: Rational\nRational\nsrc/ledger/protocol/PParamsDrepVotingThresholds.ts:13\ntreasuryWithdrawal: Rational\nRational\nsrc/ledger/protocol/PParamsDrepVotingThresholds.ts:15\nupdateConstitution: Rational\nRational\nsrc/ledger/protocol/PParamsDrepVotingThresholds.ts:9"
  },
  {
    "prompt": "PParamsPoolVotingThresholds?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / PParamsPoolVotingThresholds\ncommitteeNoConfidence: Rational\nRational\nsrc/ledger/protocol/PParamsPoolVotingThresholds.ts:8\ncommitteeNormal: Rational\nRational\nsrc/ledger/protocol/PParamsPoolVotingThresholds.ts:7\nhardForkInitiation: Rational\nRational\nsrc/ledger/protocol/PParamsPoolVotingThresholds.ts:9\nmotionNoConfidence: Rational\nRational\nsrc/ledger/protocol/PParamsPoolVotingThresholds.ts:6\nsecurityRelevantVotingThresholds: Rational\nRational\nsrc/ledger/protocol/PParamsPoolVotingThresholds.ts:10"
  },
  {
    "prompt": "AssetJson?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / AssetJson\nAssetJson: object\nobject\n[name_hex: string]: `${number}`\nname_hex\nstring\nsrc/ledger/Value/IValue.ts:6"
  },
  {
    "prompt": "CanBeHash28?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CanBeHash28\nCanBeHash28: string | Uint8Array | Hash28\nstring\nUint8Array\nHash28\nsrc/hashes/Hash28/Hash28.ts:7"
  },
  {
    "prompt": "CanBeHash32?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CanBeHash32\nCanBeHash32: string | Uint8Array | Hash32\nstring\nUint8Array\nHash32\nsrc/hashes/Hash32/Hash32.ts:6"
  },
  {
    "prompt": "CanBeTxOutRef?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CanBeTxOutRef\nCanBeTxOutRef: ITxOutRef | IUTxO | TxOutRefStr\nITxOutRef\nIUTxO\nTxOutRefStr\nsrc/tx/body/output/CanBeTxOutRef.ts:5"
  },
  {
    "prompt": "CertTypeToStr?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertTypeToStr\nCertTypeToStr CertT : CertT extends StakeRegistration ? \"StakeRegistration\" : CertT extends StakeDeRegistration ? \"StakeDeRegistration\" : CertT extends StakeDelegation ? \"StakeDelegation\" : CertT extends PoolRegistration ? \"PoolRegistration\" : CertT extends PoolRetirement ? \"PoolRetirement\" : CertT extends GenesisKeyDelegation ? \"GenesisKeyDelegation\" : CertT extends MoveInstantRewards ? \"MoveInstantRewards\" : CertT extends RegistrationDeposit ? \"RegistrationDeposit\" : CertT extends UnRegistrationDeposit ? \"UnRegistrationDeposit\" : CertT extends VoteDeleg ? \"VoteDeleg\" : ... extends ... ? ... : ...\nCertT\nCertT\nStakeRegistration\n\"StakeRegistration\"\nCertT\nStakeDeRegistration\n\"StakeDeRegistration\"\nCertT\nStakeDelegation\n\"StakeDelegation\"\nCertT\nPoolRegistration\n\"PoolRegistration\"\nCertT\nPoolRetirement\n\"PoolRetirement\"\nCertT\nGenesisKeyDelegation\n\"GenesisKeyDelegation\"\nCertT\nMoveInstantRewards\n\"MoveInstantRewards\"\nCertT\nRegistrationDeposit\n\"RegistrationDeposit\"\nCertT\nUnRegistrationDeposit\n\"UnRegistrationDeposit\"\nCertT\nVoteDeleg\n\"VoteDeleg\"\nCertT extends CertificateType\nCertificateType\nsrc/ledger/certs/CertificateType.ts:38"
  },
  {
    "prompt": "Certificate?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Certificate\nCertificate: CertStakeRegistration | CertStakeDeRegistration | CertStakeDelegation | CertPoolRegistration | CertPoolRetirement | CertGenesisKeyDelegation | MoveInstantRewardsCert | CertRegistrationDeposit | CertUnRegistrationDeposit | CertVoteDeleg | CertStakeVoteDeleg | CertStakeRegistrationDeleg | CertVoteRegistrationDeleg | CertStakeVoteRegistrationDeleg | CertAuthCommitteeHot | CertResignCommitteeCold | CertRegistrationDrep | CertUnRegistrationDrep | CertUpdateDrep\nCertStakeRegistration\nCertStakeDeRegistration\nCertStakeDelegation\nCertPoolRegistration\nCertPoolRetirement\nCertGenesisKeyDelegation\nMoveInstantRewardsCert\nCertRegistrationDeposit\nCertUnRegistrationDeposit\nCertVoteDeleg\nCertStakeVoteDeleg\nCertStakeRegistrationDeleg\nCertVoteRegistrationDeleg\nCertStakeVoteRegistrationDeleg\nCertAuthCommitteeHot\nCertResignCommitteeCold\nCertRegistrationDrep\nCertUnRegistrationDrep\nCertUpdateDrep\nsrc/ledger/certs/Certificate.ts:23"
  },
  {
    "prompt": "CertificateLike?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / CertificateLike\nCertificateLike: object & ICertStakeRegistration | object & ICertStakeDeRegistration | object & ICertStakeDelegation | object & ICertPoolRegistration | object & ICertPoolRetirement | object & ICertRegistrationDeposit | object & ICertUnRegistrationDeposit | object & ICertVoteDeleg | object & ICertStakeVoteDeleg | object & ICertStakeRegistrationDeleg | object & ICertStakeRegistration | object & ICertVoteRegistrationDeleg | object & ICertStakeVoteRegistrationDeleg | object & ICertAuthCommitteeHot | object & ICertResignCommitteeCold | object & ICertRegistrationDrep | object & ICertUnRegistrationDrep | object & ICertUpdateDrep | object & ICertGenesisKeyDelegation | object & IMoveInstantRewardsCert\nobject\nICertStakeRegistration\nobject\nICertStakeDeRegistration\nobject\nICertStakeDelegation\nobject\nICertPoolRegistration\nobject\nICertPoolRetirement\nobject\nICertRegistrationDeposit\nobject\nICertUnRegistrationDeposit\nobject\nICertVoteDeleg\nobject\nICertStakeVoteDeleg\nobject\nICertStakeRegistrationDeleg\nobject\nICertStakeRegistration\nobject\nICertVoteRegistrationDeleg\nobject\nICertStakeVoteRegistrationDeleg\nobject\nICertAuthCommitteeHot\nobject\nICertResignCommitteeCold\nobject\nICertRegistrationDrep\nobject\nICertUnRegistrationDrep\nobject\nICertUpdateDrep\nobject\nICertGenesisKeyDelegation\nobject\nIMoveInstantRewardsCert\nsrc/ledger/certs/Certificate.ts:107"
  },
  {
    "prompt": "Coin?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Coin\nCoin: CanBeUInteger\nCanBeUInteger\nsrc/ledger/Coin.ts:3"
  },
  {
    "prompt": "DRep?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / DRep\nDRep: DRepKeyHash | DRepScript | DRepAlwaysAbstain | DRepAlwaysNoConfidence\nDRepKeyHash\nDRepScript\nDRepAlwaysAbstain\nDRepAlwaysNoConfidence\nsrc/governance/DRep/DRep.ts:8"
  },
  {
    "prompt": "DRepLike?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / DRepLike\nDRepLike: object & IDRepKeyHash | object & IDRepScript | object & IDRepAlwaysAbstain | object & IDRepAlwaysNoConfidence\nobject\nIDRepKeyHash\nobject\nIDRepScript\nobject\nIDRepAlwaysAbstain\nobject\nIDRepAlwaysNoConfidence\nsrc/governance/DRep/DRepLike.ts:9"
  },
  {
    "prompt": "Epoch?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Epoch\nEpoch: CanBeUInteger\nCanBeUInteger\nsrc/ledger/Epoch.ts:3"
  },
  {
    "prompt": "GovAction?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / GovAction\nGovAction: GovActionParameterChange | GovActionInitHardFork | GovActionTreasuryWithdrawals | GovActionNoConfidence | GovActionUpdateCommittee | GovActionNewConstitution | GovActionInfo\nGovActionParameterChange\nGovActionInitHardFork\nGovActionTreasuryWithdrawals\nGovActionNoConfidence\nGovActionUpdateCommittee\nGovActionNewConstitution\nGovActionInfo\nsrc/governance/GovAction/GovAction.ts:9"
  },
  {
    "prompt": "GovActionLike?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / GovActionLike\nGovActionLike: IGovActionParameterChange & object | IGovActionInitHardFork & object | IGovActionTreasuryWithdrawals & object | IGovActionNoConfidence & object | IGovActionUpdateCommittee & object | IGovActionNewConstitution & object | IGovActionInfo & object\nIGovActionParameterChange\nobject\nIGovActionInitHardFork\nobject\nIGovActionTreasuryWithdrawals\nobject\nIGovActionNoConfidence\nobject\nIGovActionUpdateCommittee\nobject\nIGovActionNewConstitution\nobject\nIGovActionInfo\nobject\nsrc/governance/GovAction/GovActionLike.ts:12"
  },
  {
    "prompt": "IProtocolVerision?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IProtocolVerision\nIProtocolVerision: IProtocolVersionArr | IProtocolVerisionObj\nIProtocolVersionArr\nIProtocolVerisionObj\nsrc/ledger/protocol/protocolVersion.ts:12"
  },
  {
    "prompt": "IProtocolVersionArr?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IProtocolVersionArr\nIProtocolVersionArr: [CanBeUInteger, CanBeUInteger]\nCanBeUInteger\nCanBeUInteger\nsrc/ledger/protocol/protocolVersion.ts:10"
  },
  {
    "prompt": "ITxMetadata?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITxMetadata\nITxMetadata: object\nobject\n[metadatum_label: number | string]: TxMetadatum\nmetadatum_label\nnumber\nstring\nTxMetadatum\nsrc/tx/metadata/TxMetadata.ts:8"
  },
  {
    "prompt": "ITxWithdrawals?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITxWithdrawals\nITxWithdrawals: object | ITxWithdrawalsMap\nobject\nITxWithdrawalsMap\nsrc/ledger/TxWithdrawals.ts:28"
  },
  {
    "prompt": "ITxWithdrawalsEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITxWithdrawalsEntry\nITxWithdrawalsEntry: object\nobject\namount: Coin\nCoin\nrewardAccount: CanBeHash28 | StakeAddress\nCanBeHash28\nStakeAddress\nsrc/ledger/TxWithdrawals.ts:21"
  },
  {
    "prompt": "ITxWithdrawalsEntryBigInt?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITxWithdrawalsEntryBigInt\nITxWithdrawalsEntryBigInt: object\nobject\namount: bigint\nbigint\nrewardAccount: StakeAddress\nStakeAddress\nsrc/ledger/TxWithdrawals.ts:14"
  },
  {
    "prompt": "ITxWithdrawalsMap?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITxWithdrawalsMap\nITxWithdrawalsMap: ITxWithdrawalsEntry[]\nITxWithdrawalsEntry\nsrc/ledger/TxWithdrawals.ts:26"
  },
  {
    "prompt": "ITypedVotingProcedures?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ITypedVotingProcedures\nITypedVotingProcedures: ITypedVotingProceduresEntry[]\nITypedVotingProceduresEntry\nsrc/governance/VotingProcedures.ts:44"
  },
  {
    "prompt": "IValue?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IValue\nIValue: (IValuePolicyEntry | IValueAdaEntry)[]\nIValuePolicyEntry\nIValueAdaEntry\nsrc/ledger/Value/IValue.ts:10"
  },
  {
    "prompt": "IValueAdaEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IValueAdaEntry\nIValueAdaEntry: object\nobject\nassets: [IValueAsset]\nIValueAsset\npolicy: \"\"\n\"\"\nsrc/ledger/Value/IValue.ts:112"
  },
  {
    "prompt": "IValueAsset?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IValueAsset\nIValueAsset: object\nobject\nname: Uint8Array | string\nUint8Array\nstring\nbytes or HEXADECIMAL string\nquantity: CanBeUInteger\nCanBeUInteger\nsrc/ledger/Value/IValue.ts:47"
  },
  {
    "prompt": "IValueAssetBI?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IValueAssetBI\nIValueAssetBI: object\nobject\nname: Uint8Array\nUint8Array\nquantity: bigint\nbigint\nsrc/ledger/Value/IValue.ts:61"
  },
  {
    "prompt": "IVotingProcedures?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IVotingProcedures\nIVotingProcedures: IVotingProceduresEntry[]\nIVotingProceduresEntry\nsrc/governance/VotingProcedures.ts:43"
  },
  {
    "prompt": "IpPoolRelay?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / IpPoolRelay\nIpPoolRelay: object | object | object & object\nobject\nobject\nobject\nobject\noptional port: CanBeUInteger\noptional\nCanBeUInteger\ntype: \"ip\"\n\"ip\"\nsrc/ledger/PoolRelay.ts:7"
  },
  {
    "prompt": "LegacyPPUpdateMap?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / LegacyPPUpdateMap\nLegacyPPUpdateMap: object[]\nobject\nsrc/ledger/protocol/LegacyPPUpdateProposal.ts:11"
  },
  {
    "prompt": "LegacyPPUpdateProposal?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / LegacyPPUpdateProposal\nLegacyPPUpdateProposal: [LegacyPPUpdateMap, Epoch]\nLegacyPPUpdateMap\nEpoch\nsrc/ledger/protocol/LegacyPPUpdateProposal.ts:9"
  },
  {
    "prompt": "NormalizedIValue?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / NormalizedIValue\nNormalizedIValue: (NormalizedIValuePolicyEntry | NormalizedIValueAdaEntry)[]\nNormalizedIValuePolicyEntry\nNormalizedIValueAdaEntry\nsrc/ledger/Value/IValue.ts:11"
  },
  {
    "prompt": "NormalizedIValueAdaEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / NormalizedIValueAdaEntry\nNormalizedIValueAdaEntry: object\nobject\nassets: [IValueAssetBI]\nIValueAssetBI\npolicy: \"\"\n\"\"\nsrc/ledger/Value/IValue.ts:117"
  },
  {
    "prompt": "PoolRelay?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / PoolRelay\nPoolRelay: IpPoolRelay | DnsPoolRelay | MultiHostPoolRelay\nIpPoolRelay\nDnsPoolRelay\nMultiHostPoolRelay\nsrc/ledger/PoolRelay.ts:30"
  },
  {
    "prompt": "Rational?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / Rational\nRational: CborPositiveRational | number\nCborPositiveRational\nnumber\nsrc/ledger/protocol/Rational.ts:3"
  },
  {
    "prompt": "RewardSourceToStr?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / RewardSourceToStr\nRewardSourceToStr S : S extends Reserves ? \"Reserves\" : S extends Treasurery ? \"Treasurery\" : never\nS\nS\nReserves\n\"Reserves\"\nS\nTreasurery\n\"Treasurery\"\nnever\nS extends InstantRewardsSource\nInstantRewardsSource\nsrc/ledger/certs/MoveInstantRewardsCert.ts:21"
  },
  {
    "prompt": "RewardsMap?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / RewardsMap\nRewardsMap: object[]\nobject\nsrc/ledger/certs/MoveInstantRewardsCert.ts:37"
  },
  {
    "prompt": "StakeAddressCredentials?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / StakeAddressCredentials\nStakeAddressCredentials T : T extends \"stakeKey\" ? StakeKeyHash : StakeValidatorHash\nT\nT\n\"stakeKey\"\nStakeKeyHash\nStakeValidatorHash\nT extends StakeAddressType\nStakeAddressType\nsrc/ledger/StakeAddress.ts:18"
  },
  {
    "prompt": "StakeAddressType?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / StakeAddressType\nStakeAddressType: \"stakeKey\" | \"script\"\n\"stakeKey\"\n\"script\"\nsrc/ledger/StakeAddress.ts:16"
  },
  {
    "prompt": "StakeHash?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / StakeHash\nStakeHash T : T extends \"stakeKey\" ? StakeKeyHash : T extends \"script\" ? StakeValidatorHash : T extends \"pointer\" ? [CanBeUInteger, CanBeUInteger, CanBeUInteger] : never\nT\nT\n\"stakeKey\"\nStakeKeyHash\nT\n\"script\"\nStakeValidatorHash\nT\n\"pointer\"\nCanBeUInteger\nCanBeUInteger\nCanBeUInteger\nnever\nT extends StakeCredentialsType\nStakeCredentialsType\nsrc/credentials/StakeCredentials.ts:15"
  },
  {
    "prompt": "TxMetadatumMapEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxMetadatumMapEntry\nTxMetadatumMapEntry: object\nobject\nk: TxMetadatum\nTxMetadatum\nv: TxMetadatum\nTxMetadatum\nsrc/tx/metadata/TxMetadatum.ts:61"
  },
  {
    "prompt": "TxRedeemerTagStr?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxRedeemerTagStr\nTxRedeemerTagStr Tag : Tag extends Spend ? \"Spend\" : Tag extends Mint ? \"Mint\" : Tag extends Cert ? \"Cert\" : Tag extends Withdraw ? \"Withdraw\" : Tag extends Voting ? \"Voting\" : Tag extends Proposing ? \"Proposing\" : never\nTag\nTag\nSpend\n\"Spend\"\nTag\nMint\n\"Mint\"\nTag\nCert\n\"Cert\"\nTag\nWithdraw\n\"Withdraw\"\nTag\nVoting\n\"Voting\"\nTag\nProposing\n\"Proposing\"\nnever\nTag extends TxRedeemerTag\nTxRedeemerTag\nsrc/tx/TxWitnessSet/TxRedeemer.ts:38"
  },
  {
    "prompt": "TxWithdrawalsMapBigInt?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / TxWithdrawalsMapBigInt\nTxWithdrawalsMapBigInt: ITxWithdrawalsEntryBigInt[]\nITxWithdrawalsEntryBigInt\nsrc/ledger/TxWithdrawals.ts:19"
  },
  {
    "prompt": "UTxORefJson?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / UTxORefJson\nUTxORefJson: object\nobject\nid: string\nstring\nindex: number\nnumber\nsrc/tx/body/output/TxOutRef.ts:62"
  },
  {
    "prompt": "ValueJson?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ValueJson\nValueJson: object\nobject\n[policy_hex: string]: AssetJson\npolicy_hex\nstring\nAssetJson\nsrc/ledger/Value/IValue.ts:8"
  },
  {
    "prompt": "ValueUnitEntry?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ValueUnitEntry\nValueUnitEntry: object\nobject\nquantity: bigint | number | string\nbigint\nnumber\nstring\nunit: string\nstring\nsrc/ledger/Value/Value.ts:17"
  },
  {
    "prompt": "ValueUnitEntryBI?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ValueUnitEntryBI\nValueUnitEntryBI: object\nobject\nquantity: bigint\nbigint\nunit: string\nstring\nsrc/ledger/Value/Value.ts:24"
  },
  {
    "prompt": "ValueUnits?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ValueUnits\nValueUnits: ValueUnitEntry[]\nValueUnitEntry\nsrc/ledger/Value/Value.ts:22"
  },
  {
    "prompt": "ValueUnitsBI?",
    "completion": "@harmoniclabs/cardano-ledger-ts Docs\n@harmoniclabs/cardano-ledger-ts / ValueUnitsBI\nValueUnitsBI: ValueUnitEntryBI[]\nValueUnitEntryBI\nsrc/ledger/Value/Value.ts:29"
  },
  {
    "prompt": "DataConstr?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / DataConstr\nnew DataConstr(constr, fields): DataConstr\nconstr\nfields\nDataConstr\nconstr: CanBeUInteger\nCanBeUInteger\nfields: Data[]\nData\nDataConstr\nDataConstr\nDataConstr.ts:13\nprivate _constr: bigint\nprivate\nbigint\nDataConstr.ts:7\nprivate _fields: Data[]\nprivate\nData\nDataConstr.ts:10\nget constr(): bigint\nget\nbigint\nbigint\nbigint\nDataConstr.ts:8\nget fields(): Data[]\nget\nData\nData[]\nData\nDataConstr.ts:11\nclone(): DataConstr\nDataConstr\nDataConstr\nDataConstr\nDataConstr.ts:24\ntoJson(): any\nany\nany\nany\nDataConstr.ts:34\ntoString(): string\nstring\nstring\nstring\nDataConstr.ts:42"
  },
  {
    "prompt": "DataI?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / DataI\nnew DataI(I): DataI\nI\nDataI\nI: number | bigint= 0\nnumber\nbigint\n0\nDataI\nDataI\nDataI.ts:6\nprivate _int: bigint\nprivate\nbigint\nDataI.ts:3\nget int(): bigint\nget\nbigint\nbigint\nbigint\nDataI.ts:4\nclone(): DataI\nDataI\nDataI\nDataI\nDataI.ts:11\ntoJson(): Object\nObject\nObject\nObject\nint: string\nstring\nDataI.ts:20\ntoString(): string\nstring\nstring\nstring\nDataI.ts:25"
  },
  {
    "prompt": "DataList?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / DataList\nnew DataList(list): DataList\nlist\nDataList\nlist: Data[]\nData\nDataList\nDataList\nDataList.ts:10\nprivate _list: Data[]\nprivate\nData\nDataList.ts:7\nget list(): Data[]\nget\nData\nData[]\nData\nDataList.ts:8\nclone(): DataList\nDataList\nDataList\nDataList\nDataList.ts:20\ntoJson(): Object\nObject\nObject\nObject\nlist: any[]\nany\nDataList.ts:29\ntoString(): string\nstring\nstring\nstring\nDataList.ts:36"
  },
  {
    "prompt": "DataMap?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / DataMap\nDataKey extends Data\nData\nDataValue extends Data\nData\nnew DataMap DataKey, DataValue (map): DataMap DataKey, DataValue\nDataKey\nDataValue\nmap\nDataMap\nDataKey\nDataValue\nmap: DataPair DataKey, DataValue []\nDataPair\nDataKey\nDataValue\nDataMap DataKey, DataValue\nDataMap\nDataKey\nDataValue\nDataMap.ts:11\nprivate _map: DataPair DataKey, DataValue []\nprivate\nDataPair\nDataKey\nDataValue\nDataMap.ts:8\nget map(): DataPair DataKey, DataValue []\nget\nDataPair\nDataKey\nDataValue\nDataPair DataKey, DataValue []\nDataPair\nDataKey\nDataValue\nDataMap.ts:9\nclone(): DataMap DataKey, DataValue\nDataMap\nDataKey\nDataValue\nDataMap DataKey, DataValue\nDataMap\nDataKey\nDataValue\nDataMap.ts:24\ntoJson(): Object\nObject\nObject\nObject\nmap: Object[]\nObject\nDataMap.ts:33\ntoString(): string\nstring\nstring\nstring\nDataMap.ts:45"
  },
  {
    "prompt": "DataPair?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / DataPair\nDataFst extends Data\nData\nDataSnd extends Data\nData\nnew DataPair DataFst, DataSnd (fst, snd): DataPair DataFst, DataSnd\nDataFst\nDataSnd\nfst\nsnd\nDataPair\nDataFst\nDataSnd\nfst: DataFst\nDataFst\nsnd: DataSnd\nDataSnd\nDataPair DataFst, DataSnd\nDataPair\nDataFst\nDataSnd\nDataPair.ts:28\nprivate _fst: DataFst\nprivate\nDataFst\nDataPair.ts:6\nprivate _snd: DataSnd\nprivate\nDataSnd\nDataPair.ts:17\nget fst(): DataFst\nget\nDataFst\nset fst(v): void\nset\nv\nvoid\nv: DataFst\nDataFst\nDataFst\nDataFst\nDataPair.ts:7\nget snd(): DataSnd\nget\nDataSnd\nset snd(v): void\nset\nv\nvoid\nv: DataSnd\nDataSnd\nDataSnd\nDataSnd\nDataPair.ts:18\nclone(): DataPair DataFst, DataSnd\nDataPair\nDataFst\nDataSnd\nDataPair DataFst, DataSnd\nDataPair\nDataFst\nDataSnd\nDataPair.ts:38\ntoString(): string\nstring\nstring\nstring\nDataPair.ts:44"
  },
  {
    "prompt": "cloneData?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / cloneData\ncloneData D (data): D\nD\ndata\nD\nD extends Data\nData\ndata: D\nD\nD\nD\nData.ts:103"
  },
  {
    "prompt": "constrNumberToCborTag?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / constrNumberToCborTag\nconstrNumberToCborTag(uint): bigint\nuint\nbigint\nNote [CBOR alternative tags]\nWe've proposed to add additional tags to the CBOR standard to cover (essentially) sum types. This is exactly what we need to encode the 'Constr' constructor of 'Data' in an unambiguous way. The tags aren't quite accepted yet, but they're clearly going to accept so we might as well start using them. The scheme is:\nuint: bigint\nbigint\nbigint\nbigint\nDataConstr.ts:61"
  },
  {
    "prompt": "dataFromCbor?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / dataFromCbor\ndataFromCbor(cbor): Data\ncbor\nData\ncbor: CanBeCborString\nCanBeCborString\nData\nData\nfromCbor.ts:98"
  },
  {
    "prompt": "dataFromCborObj?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / dataFromCborObj\ndataFromCborObj(cborObj): Data\ncborObj\nData\ncborObj: CborObj\nCborObj\nData\nData\nfromCbor.ts:12"
  },
  {
    "prompt": "dataFromJson?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / dataFromJson\ndataFromJson(json): Data\njson\nData\nall data instances (from any version) will have a toJson method this function will get back the data of this version if needed\ntoJson\njson\nData\nData\nData.ts:114"
  },
  {
    "prompt": "dataFromString?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / dataFromString\ndataFromString(str): Data\nstr\nData\nparses the result of data.toString()\ndata.toString()\nstr: string\nstring\ndata\nData\nData\nfromString.ts:111"
  },
  {
    "prompt": "dataToCbor?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / dataToCbor\ndataToCbor(data): CborString\ndata\nCborString\ndata: Data\nData\nCborString\nCborString\ntoCbor.ts:95"
  },
  {
    "prompt": "dataToCborObj?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / dataToCborObj\ndataToCborObj(data): CborObj\ndata\nCborObj\ndata: Data\nData\nCborObj\nCborObj\ntoCbor.ts:10"
  },
  {
    "prompt": "eqData?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / eqData\neqData(a, b): boolean\na\nb\nboolean\na: Data\nData\nb: Data\nData\nboolean\nboolean\nData.ts:35"
  },
  {
    "prompt": "hashData?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / hashData\nhashData(data): Uint8Array\ndata\nUint8Array\ndata: Data\nData\nUint8Array\nUint8Array\nhashData.ts:5"
  },
  {
    "prompt": "isData?",
    "completion": "@harmoniclabs/plutus-data Readme | API\n@harmoniclabs/plutus-data / isData\nisData(something): something is Data\nsomething\nsomething is Data\nsomething: any\nany\nsomething is Data\nsomething is Data\nData.ts:21"
  },
  {
    "prompt": "Interval?",
    "completion": "Represents a bound in a range with an associated inclusivity flag.\nRepresents an extended type that could either be a finite value or positive/negative infinity. It is used to generalize interval boundaries.\nUsed to describe the time interval in which a transaction is considered valid, defining a start and end time using PBound for each."
  },
  {
    "prompt": "PDCert?",
    "completion": "This method is deprecated as of Plutus V3"
  },
  {
    "prompt": "PubKey?",
    "completion": "A bytestring of length 28 representing a public key.\nA bytestring of length 28 representing the hash of a public key."
  },
  {
    "prompt": "ScriptsHashes?",
    "completion": "Represents a hash of a datum (piece of data associated with a transaction output), allowing the script to reference and verify the datum efficiently\nRepresents hash of a script, to uniquely identify a script and is essential for referencing and interacting with scripts associated with transaction outputs within transactions\nRepresents hash of a validator scripts, used to uniquely identify and reference these scripts."
  },
  {
    "prompt": "Time?",
    "completion": "Used to describe the time interval in which a transaction is considered valid"
  },
  {
    "prompt": "PTokenName?",
    "completion": "PTokenName\nDefinition:\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PTokenName = palias( bs );\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PTokenName = palias( bs );\naliased type: TermBS\nTermBS"
  },
  {
    "prompt": "POutputDatum?",
    "completion": "POutputDatum\nIntroduced in V2 version\nThis type defines various ways extra information (datum) can be attached to a transaction output.\nDefinition:\nimport { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { data } from \"../../../type_system/types\";import { PDatumHash } from \"../../V1/ScriptsHashes/PDatumHash\";export const POutputDatum = pstruct({ NoDatum: {}, DatumHash: { datumHash: PDatumHash.type }, InlineDatum: { datum: data }});\nimport { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { data } from \"../../../type_system/types\";import { PDatumHash } from \"../../V1/ScriptsHashes/PDatumHash\";export const POutputDatum = pstruct({ NoDatum: {}, DatumHash: { datumHash: PDatumHash.type }, InlineDatum: { datum: data }});\nNoDatum\nRepresents an output without any associated datum, this being the simplest form.\ntype: PTxOutRef.type\nPTxOutRef.type\nDatumHash\ndatumHash\nThe hash of datum that can be used to reference the datum. This is used instead of embedding the full datum in the output.\ntype: PDatumHash.type\nPDatumHash.type\nInlineDatum\nRepresents an inline datum in case the full datum needs to be readily accessible without any further lookup.\ndatum\nThe actual raw data associated with the transaction output\ntype: data\ndata\nNoDatum\nDatumHash\ndatumHash\nInlineDatum\ndatum"
  },
  {
    "prompt": "PDrep?",
    "completion": "PDrep\nIntroduced in V3 version\nThis type represents different kinds of decentralized representatives (DReps) within Cardano's governance model. This structure is part of the system that allows participants to express preferences on proposals, delegating their voting power to different types of DReps.\nDefinition:\nimport { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { PCredential } from \"../../V1/Address/PCredential\";export const PDrep = pstruct({ DRep: { credentials: PCredential.type }, AlwaysAbstain: {}, AlwaysNoConfidence: {}});\nimport { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { PCredential } from \"../../V1/Address/PCredential\";export const PDrep = pstruct({ DRep: { credentials: PCredential.type }, AlwaysAbstain: {}, AlwaysNoConfidence: {}});\nDRep\nA representative with specific credentials.\ncredentials\nThis field identifies the DRep either by public key hash or a script hash.\ntype: 'PCredential.type'\nAlwaysAbstain\nA DRep that always abstains from voting.\nAlwaysNoConfidence\nA DRep that always votes with 'no confidence'\nDRep\ncredentials\nAlwaysAbstain\nAlwaysNoConfidence"
  },
  {
    "prompt": "PGovernanceAction?",
    "completion": "PGovernanceAction\nIntroduced in V3 version\nDefinition:\nexport const PRational = pstruct({ PRational: { numerator: int, denominator: int }});export const PConstitution = pstruct({ PConstitution: { constitutionScriptHash: PMaybe( PValidatorHash.type ).type }});export const PGovernanceAction = pstruct({ ParameterChange: { govActionId: PMaybe( PTxOutRef.type ).type, changedParameters: PChangedParams.type, constitutionScriptHash: PMaybe( PValidatorHash.type ).type }, HardForkInitiation: { govActionId: PMaybe( PTxOutRef.type ).type, nextProtocolVersion: PProtocolVersion.type }, TreasuryWithdrawals: { withdrawals: map( PCredential.type, int ), constitutionScriptHash: PMaybe( PValidatorHash.type ).type }, NoConfidence: { govActionId: PMaybe( PTxOutRef.type ).type }, UpdateCommittee: { govActionId: PMaybe( PTxOutRef.type ).type, removedMembers: list( PCredential.type ), newMembers: map( PCredential.type, int ), newQuorum: PRational.type }, NewConstitution: { govActionId: PMaybe( PTxOutRef.type ).type, consitution: PConstitution.type }, InfoAction: {}});\nexport const PRational = pstruct({ PRational: { numerator: int, denominator: int }});export const PConstitution = pstruct({ PConstitution: { constitutionScriptHash: PMaybe( PValidatorHash.type ).type }});export const PGovernanceAction = pstruct({ ParameterChange: { govActionId: PMaybe( PTxOutRef.type ).type, changedParameters: PChangedParams.type, constitutionScriptHash: PMaybe( PValidatorHash.type ).type }, HardForkInitiation: { govActionId: PMaybe( PTxOutRef.type ).type, nextProtocolVersion: PProtocolVersion.type }, TreasuryWithdrawals: { withdrawals: map( PCredential.type, int ), constitutionScriptHash: PMaybe( PValidatorHash.type ).type }, NoConfidence: { govActionId: PMaybe( PTxOutRef.type ).type }, UpdateCommittee: { govActionId: PMaybe( PTxOutRef.type ).type, removedMembers: list( PCredential.type ), newMembers: map( PCredential.type, int ), newQuorum: PRational.type }, NewConstitution: { govActionId: PMaybe( PTxOutRef.type ).type, consitution: PConstitution.type }, InfoAction: {}});\nPRational\nThis type represents a rational number in the governance system, composed of a numerator and a denominator.\nnumerator\ntype: TermInt\nTermInt\ntype: TermInt\nTermInt\nPConstitution\nThis type represents the script hash of a constitution used in the governance system.\nconstitutionScriptHash\n(Optional) A validator hash representing the constitution\ntype: PMaybe( PValidatorHash.type ).type\nPMaybe( PValidatorHash.type ).type\nPGovernanceAction\nThis structure represents various types of governance actions that can occur in Cardano.\nParameterChange\nProposes changes to protocol parameters\ngovActionId\n(Optional) Transaction output reference for the action\ntype: PMaybe( PTxOutRef.type ).type\nPMaybe( PTxOutRef.type ).type\nchangedParameters\nA map of parameters that are being changed.\ntype: PChangedParams.type\nPChangedParams.type\nconstitutionScriptHash\n(Optional) Validator hash of the constitution.\ntype: PMaybe( PValidatorHash.type ).type\nPMaybe( PValidatorHash.type ).type\nHardForkInitiation\nInitiates a hard fork with a new protocol version.\ngovActionId\n(Optional) Transaction output reference.\ntype: PMaybe( PTxOutRef.type ).type\nPMaybe( PTxOutRef.type ).type\nnextProtocolVersion\nThe protocol version to be implemented after the hard fork.\ntype: PProtocolVersion.type\nPProtocolVersion.type\nTreasuryWithdrawals\nWithdraws funds from the treasury.\nwithdrawals\nA map of staking credentials to withdrawal amounts.\ntype: map( PCredential.type, int )\nmap( PCredential.type, int )\nelements's types:\nPCredential\nTermInt\nconstitutionScriptHash\n(Optional) Validator hash of the constitution.\ntype: PMaybe( PValidatorHash.type ).type\nPMaybe( PValidatorHash.type ).type\nNoConfidence\nA vote of no confidence.\ngovActionId\n(Optional) Transaction output reference.\ntype: PMaybe( PTxOutRef.type ).type\nPMaybe( PTxOutRef.type ).type\nUpdateCommittee\nUpdates the governance committee.\ngovActionId\n(Optional) Transaction output reference.\ntype: PMaybe( PTxOutRef.type ).type\nPMaybe( PTxOutRef.type ).type\nremovedMembers\nA list of committee members being removed.\ntype: list( PCredential.type )\nlist( PCredential.type )\nelements's types:\nPCredential\nnewMembers\nA map of new members with their credentials.\ntype: map( PCredential.type, int )\nmap( PCredential.type, int )\nelements's types:\nPCredential\nTermInt\nnewQuorum\nA rational number representing the new quorum.\ntype: PRational.type\nPRational.type\nNewConstitution\nProposes a new constitution.\ngovActionId\n(Optional) Transaction output reference.\ntype: PMaybe( PTxOutRef.type ).type\nPMaybe( PTxOutRef.type ).type\nconsitution\nThe proposed new constitution.\ntype: PConstitution.type\nPConstitution.type\ncold\nRepresents a governance action with no significant data (used for informational purposes).\nPRational\nnumerator\nPConstitution\nconstitutionScriptHash\nPGovernanceAction\nParameterChange\nHardForkInitiation\nTreasuryWithdrawals\nNoConfidence\nUpdateCommittee\nNewConstitution\ncold"
  },
  {
    "prompt": "PCurrencySymbol?",
    "completion": "PCurrencySymbol\nDefinition:\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PCurrencySymbol = palias( bs );\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PCurrencySymbol = palias( bs );\naliased type: TermBS\nTermBS"
  },
  {
    "prompt": "PAddress?",
    "completion": "PAddress\nRepresents an address which includes both a payment credential and an optional staking credential.\nDefinition:\nexport const PAddress = pstruct({ PAddress: { credential: PCredential.type, stakingCredential: PMaybe( PStakingCredential.type ).type }})\nexport const PAddress = pstruct({ PAddress: { credential: PCredential.type, stakingCredential: PMaybe( PStakingCredential.type ).type }})\ncredential\nThis field represents the main payment credential used in the address. It can be a public key credential or a script credential, defined by the PCredential type.\ntype: PCredential\nPCredential\nstakingCredential\nThis field represents the optional staking credential associated with the address. It uses PMaybe, meaning the staking credential might or might not be present.\ntype: PMaybe( PStakingCredential.type ).type\nPMaybe( PStakingCredential.type ).type\ncredential\nstakingCredential"
  },
  {
    "prompt": "PScriptHash?",
    "completion": "PScriptHash\nRepresents hash of a script, to uniquely identify a script and is essential for referencing and interacting with scripts associated with transaction outputs within transactions\nDefinition:\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PScriptHash = palias( bs );\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PScriptHash = palias( bs );\naliased type: TermBS\nTermBS"
  },
  {
    "prompt": "PStakingCredential?",
    "completion": "PStakingCredential\nStaking credentials used as the second (optional) part of an address and responsible of moving stake around.\nDefinition:\nexport const PStakingCredential = pstruct({ PStakingHash: { _0: PCredential.type }, PStakingPtr: { _0: int, _1: int, _2: int }});\nexport const PStakingCredential = pstruct({ PStakingHash: { _0: PCredential.type }, PStakingPtr: { _0: int, _1: int, _2: int }});\nPStakingHash\nactual stake credentials (either pubKeyHash or validator hash)\n_0\ntype: PCredential\nPCredential\nPStakingPtr\nstake credential pointer;\n_0\ntype: TermInt\nTermInt\n_1\ntype: TermInt\nTermInt\n_2\ntype: TermInt\nTermInt\nPStakingHash\n_0\nPStakingPtr\n_0\n_1\n_2"
  },
  {
    "prompt": "PValidatorHash?",
    "completion": "PValidatorHash\nRepresents hash of a validator scripts, used to uniquely identify and reference these scripts.\nDefinition:\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PValidatorHash = palias( bs );\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PValidatorHash = palias( bs );\naliased type: TermBS\nTermBS"
  },
  {
    "prompt": "PInterval?",
    "completion": "PInterval\nUsed to describe the time interval in which a transaction is considered valid, defining a start and end time using PBound for each. Both bounds (from and to) can represent either finite times or infinite boundaries (open-ended intervals).\nPBound\nfrom\nto\nDefinition:\nimport { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { PBound } from \"./PBound\";export const PInterval = pstruct({ PInterval: { from: PBound.type, to: PBound.type }});\nimport { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { PBound } from \"./PBound\";export const PInterval = pstruct({ PInterval: { from: PBound.type, to: PBound.type }});\ntype: PBound\nPBound\ntype: PBound\nPBound"
  },
  {
    "prompt": "PPubKey?",
    "completion": "PPubKey\nA bytestring of length 28 representing a public key.\nDefinition:\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PPubKey = palias( bs );\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { bs } from \"../../../type_system/types\";export const PPubKey = palias( bs );\naliased type: TermBS\nTermBS"
  },
  {
    "prompt": "PBound?",
    "completion": "PBound\nRepresents a bound in a range with an associated inclusivity flag. The PBound type is typically used to define the bounds of an interval, where each bound is either inclusive or exclusive, and the value of the bound itself is described by an PExtended type.\nPBound\nPExtended\nDefinition:\nimport { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { bool } from \"../../../type_system/types\";import { PExtended } from \"./PExtended\";export const PBound = pstruct({ PBound: { bound: PExtended.type, inclusive: bool }});\nimport { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { bool } from \"../../../type_system/types\";import { PExtended } from \"./PExtended\";export const PBound = pstruct({ PBound: { bound: PExtended.type, inclusive: bool }});\nbound\nThis field specifies the actual value of the boundary in the interval. This can either be a concrete value or an infinite one (i.e., open-ended bound). The PExtended type allows for this flexibility by supporting both finite and infinite bounds.\nPExtended\ntype: PExtended\nPExtended\ninclusive\nA boolean flag that indicates whether the bound is inclusive or exclusive, meaning part or not part of the interval\ntype: bool\nbool\nbound\ninclusive"
  },
  {
    "prompt": "PExtended?",
    "completion": "PExtended\nRepresents an extended type that could either be a finite value or positive/negative infinity. It is used to generalize interval boundaries.\nDefinition:\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { pfn } from \"../../../lib/pfn\";import { pInt } from \"../../../lib/std/int\";import { int } from \"../../../type_system\";export const PExtended = pstruct({ PNegInf: {}, PFinite: { n: int }, PPosInf: {}});const PPOSIXTime = palias( int )PPOSIXTime.from( pInt( 1 ) )\nimport { palias } from \"../../../PTypes/PAlias/palias\";import { pstruct } from \"../../../PTypes/PStruct/pstruct\";import { pfn } from \"../../../lib/pfn\";import { pInt } from \"../../../lib/std/int\";import { int } from \"../../../type_system\";export const PExtended = pstruct({ PNegInf: {}, PFinite: { n: int }, PPosInf: {}});const PPOSIXTime = palias( int )PPOSIXTime.from( pInt( 1 ) )\nPNegInf\nRepresents negative infinity\nPFinite\nRepresents a finite value.\nPPosInf\nRepresents positive infinity\nPNegInf\nPFinite\nPPosInf"
  }
]